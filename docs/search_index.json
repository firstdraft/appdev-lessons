[["index.html", "AD1 Welcome!", " AD1 Ben + Raghu 2023-02-09 Welcome! This is the AD1 Textbook. Enjoy. "],["intro-to-ruby.html", "1 Intro to Ruby", " 1 Intro to Ruby We now have an idea of webpage design with HTML and CSS. That’s frontend development in a nutshell. Now it’s time to learn how we develop the backend. To do so, we need to learn how to program with the Ruby language. Prepare for a crash course in the following sections. Expect short readings interspersed with interactive code exercises. Some of these examples are solved in the accompanying video tutorials, and others are left for you to work through. You will need to complete the exercises as you go. Do, or do not. There is no read. Look out for the exercise prompts: for sandbox experimentation and for graded projects. When you see those, if you aren’t typing out every expression, then you’re doing it wrong. If you’re just reading, you won’t be successful at learning programming; you have to do in order to build up some muscle memory. Practice is crucial. "],["nouns-verbs-and-grammar.html", "1.1 Nouns, verbs, and grammar", " 1.1 Nouns, verbs, and grammar 1.1.1 You already know how to program Programming is the art of getting a computer to do useful things with information. If you think about it that way, then you already know at least one programming language: In the case of a calculator, the “information” is numbers and the “useful things” are adding, subtracting, multiplying, etc. Like any computer (or person), we get the calculator to do useful work by writing instructions that it can understand. For example, if we press the keys 7 × 6 = (in that order), then the calculator will return 42 on the screen; but if we press the keys × 7 = 6, then it won’t. In the above example, 7 and 6 are known as data, or as I think of it, nouns. x and = are known as methods, or as I think of it, verbs. The order in which we press the keys is known as syntax, or as I think of it, grammar. Altogether, some data and some methods put together using correct syntax form an expression, or as I think of it, a sentence. Given a valid expression, the computer will process it and return a piece of useful data back to us. A basic calculator’s entire vocabulary consists of the following: Data 1 2 3 4 5 6 7 8 9 0 . Methods = + - × ÷ % ± AC Syntax There are only a few rules: Primary syntax: A number, then an operator, then another number, then the =. Numbers can contain a single decimal point. Numbers can be modified by the plus/minus sign. Numbers can be modified by the percentage sign. Can press AC to reset. It’s a very small language, but it demonstrates the same parts as any other programming language: data, methods, and syntax. Got it? Good, because that’s basically all that there is to any other programming language, too! It’s just that its vocabulary will be bigger, and it will have more grammar rules. 1.1.2 Ruby’s vocabulary Let’s start learning your second programming language — Ruby! As we now know, that means we need to familiarize ourselves with Ruby’s data, methods, and the syntax for putting them together. First of all, Ruby can work with many more kinds of data than just numbers. That’s what makes it much more powerful than the calculator language. Ruby has: Numbers Text Dates Times True/false Lists containing multiple pieces of data And a lot more Each kind, or class, of data has its own set of methods that it can perform. For example: Numbers can do the usual things — add, subtract, multiply, etc. Two dates can tell you how far apart they are from one another. Lists can tell how you long they are, or sort themselves. Ruby is known as a “batteries included” language because it comes with so many methods out-of-the-box, saving the programmer the trouble of having to re-invent the wheel. Finally, we can even make up our own nouns and verbs and add them to the language. For example, we can create a data type Venue, give it a method that calculates the average rating from its reviews, and then use that method whenever we want. One of the best things about Ruby is its wonderful open-source community: programmers very often share these new classes that they write with one another, making the language ever easier to use and ever more powerful. 1.1.3 Ruby’s primary syntax So, in terms of data and methods, Ruby comes with a powerful set out-of-the-box and is always getting better. That’s good news! Here’s even more good news: to access all of this power, the primary syntax is straightforward. It looks like this: some_object.some_method Here’s a real example: &quot;Hello, world!&quot;.upcase You try it. Click here to visit repl.it, a service that offers instant programming sandboxes within your browser. Click the “Fork” button in the top right and sign in with your Github account. “Forking” a REPL will copy the REPL to your own account and allow you to edit it. In the black window that appears on the right side under the &gt;_ Console tab1 This is a “command-line” or “terminal”. You enter text commands here by typing them out exactly, and the computer will execute them, similar to how you click on a program with your mouse to run it. You’ve already seen another terminal in your GitPod workspaces for running commands like bin/server and rails grade., type: irb and press return. This will launch interactive Ruby (IRB), a program that lets you evaluate one Ruby expression at a time. At the irb(main) prompt that appears, you can now try out \"Hello, world!\".upcase: If all went well, you should have seen =&gt; \"HELLO, WORLD!\" output by the command. Yay2 It is a time-honored tradition that the very first thing a programmer does in a new language is print out “Hello, World!” Congratulations — you’re now one of us ! What just happened? The primary way to write an expression in Ruby is: object.method. We ask the thing, or noun, on the left side of the dot to perform the action, or the verb, on the right side of the dot. The computer then evaluates that expression and returns a new piece of data in its place (just like with the calculator). In this case, we asked \"Hello, world!\", which is a string (Ruby’s name for a piece of text3 The name “string” is used in pretty much every programming language for the datatype that holds a piece of text, and refers to a string of characters; a holdover from back when we used to have to worry about conserving the computer’s physical storage space and had a separate datatype for an individual character. Now we usually don’t have to worry about storage space anymore, but the name “string” stuck with us.), to upcase itself, which it (very) happily does, and we’re left with \"HELLO, WORLD!\" at the end of the day. 1.1.4 Every class has different methods Different classes4 Almost everything in Ruby is an object. That’s the idea behind object-oriented programming. Text like \"Hello, world!\" is an object — specifically a string class object. (string being one) can perform different methods. Here are a few expressions to try out. Type each one into IRB. 7.odd? 7.even? &quot;Mississippi&quot;.length &quot;Raghu Betina&quot;.reverse &quot;Your Name&quot;.swapcase Click here for a REPL to try it. What do you expect will happen if we ask \"Mississippi\" if it is even?? Try it: &quot;Mississippi&quot;.even? 1.1.5 Error Messages Do, or do not. There is no read. When you saw the  exercise prompt, were you typing out every expression in a REPL? If not, then you’re doing this wrong. If you’re just reading, you won’t be successful at learning programming; you have to do in order to build up some muscle memory. Practice is crucial. In fact, not only should you be typing the things I ask you to type, but you should also be trying out random other things that occur to you. (E.g., “What if I tried \"Mississippi\".length.even?”) Experiment! Read. The. Error. Message. (A.k.a., “RTEM”) Aha! If you were typing out every expression and running it, then &quot;Mississippi&quot;.even? should have produced your very first error message!  Error messages can look scary, but one of the most important skills you have to develop when learning to program is to not panic when you see them. Slow down, read the error message, and see if you can make any sense of it at all. Over time, you will find that they are very helpful (and you will miss them if something goes wrong silently). So, what do you think undefined method `even?&#39; for &quot;Mississippi&quot;:String might mean? In this case, it is saying: “Hey, friend — there’s no method called even? for \"Mississippi\", which is a String. Sorry.” Fair enough, that makes sense. The bottom line The bottom line is — at all times as you are writing Ruby, you should be thinking: “What class is this object? What methods does this class have available?” Then, the syntax itself is simple — my_object.cool_method. 1.1.6 Arguments are inputs Alright, so the primary syntax in Ruby is straightforward — object.method. However, there’s a wrinkle: some methods require additional inputs. For example, there is a method called gsub which we can call on a String, which will substitute characters with other characters. Try it: &quot;Java is a joy&quot;.gsub(&quot;Java&quot;, &quot;Ruby&quot;) Click here for a REPL to try it. gsub is short for “globally substitute”, because it will replace all occurrences of one substring with another substring. In order to do its job, the gsub method needs to know what substring to get rid of and what to replace it with. So we give it inputs, or arguments, which must come in parentheses immediately following the method. If the method takes multiple arguments, as gsub does, then they are separated by commas. Try replacing \"Java is a joy\" with any string you like, and experiment with different arguments instead of \"Java\" and \"Ruby\". For example, use gsub to change \"Hello, world!\" to say \"Hello, you there!\". Then, start with \"resume\" and try to transform it into \"résumé\". What is the purpose of gsub’s first argument, and what is the purpose of the second argument? In reality, gsub is more often used to do things like removing illegal characters from usernames before saving, e.g.: &quot;Raghu@Bet@ina&quot;.gsub(&quot;@&quot;, &quot;&quot;) (\"\" is an empty string, so all @s will be replaced with nothing, i.e. removed.) 1.1.7 One of the only times when whitespace matters Unlike some other languages (e.g. Python) where indentation and spacing can change the entire meaning of a program, Ruby is, generally, very permissive about how you use whitespace. You can usually use spacing according to your own taste, and Ruby will be able to make sense of your code. So, for example, whether you have spaces between arguments doesn’t matter; these two are equivalent: &quot;Raghu@Bet@ina&quot;.gsub(&quot;@&quot;, &quot;&quot;) &quot;Raghu@Bet@ina&quot;.gsub(&quot;@&quot;,&quot;&quot;) (The most common style is to have one space after each comma.) However, one situation in which whitespace does matter has to do with the parentheses around arguments: &quot;Raghu@Bet@ina&quot;.gsub(&quot;@&quot;, &quot;&quot;) # good &quot;Raghu@Bet@ina&quot;.gsub (&quot;@&quot;, &quot;&quot;) # bad! Can you spot the difference? Don’t put a space between the method and the opening parenthesis. It’s a very easy mistake to make, so I just wanted to warn you early on so that you can begin developing good muscle memory. Try the bad version in your sandbox and see what the error message looks like: Click here for a REPL to try it. 1.1.8 Seriously: please read the error message Programming boils down to: Forming a plan of what you want to do (e.g. “I want to remove any @s in this input.”) Typing some code to try and do it. It never works the first time. Seeing an error message. Learning how to deal with that particular error message. The next time you encounter that error message, it will be vaguely familiar and it will take slightly less time to debug it. After you’ve encountered that error message for the 25th time, you will debug it instantly. Your skill level as a programmer is essentially the number of error messages that you have encountered in the past and now recognize. So start paying attention to them now — we want to collect ’em all! 1.1.9 An aside: Code comments Here’s a debate that will rage until the end of time: what do you call this symbol? # Is it a number sign? Is it a pound sign? Is it a hashtag? Is it a waffle? In this text, I’m going to refer to it as an octothorpe. The octothorpe is used quite a bit in Ruby. You can see one important way in the example above, where I said # bad! after some offending code. That is known as a “code comment”. The Ruby interpreter, when it sees the #, will ignore it and everything that comes after it; allowing us to leave notes to ourselves and to each other. Use comments liberally. Another nice trick is: when experimenting with some code and it’s not working, just comment it out and try a different approach on the next line. That way you can keep the old code around for reference without having to delete it, but it won’t break the program: # &quot;Raghu@Bet@ina&quot;.gsub (&quot;@&quot;, &quot;&quot;) # The code above was throwing an error message, # but I want to save it for reference as I try # to debug, so I put a #-symbol before it. # Now, let me see if this thing below fixes it &quot;Raghu@Bet@ina&quot;.gsub(&quot;@&quot;, &quot;&quot;) 1.1.10 Variables are boxes Now that you’ve seen arguments, you know all there is to know about crafting expressions in Ruby. No kidding: object.method(arguments) is the vast majority of what we’ll be doing. That’s it. However, so far we haven’t been doing much with the return value of each expression. We’ve just been reading it off the screen, and then dropping it on the ground. For example, try the following: # &quot;hello world&quot;.upcase # &quot;hello world&quot;.reverse Click here for a REPL to try it. Did it work? Did you copy-paste and forget to remove the leading # symbol..? We’re not really able to make any forward progress when we only perform one operation at a time. Programs get interesting only when we start to take the return value of one expression and feed it into the next method. That’s how we craft our own novel, useful applications from the basic building blocks of Ruby. So: let’s start to store our return values for future reference, instead of dropping them on the ground. We do this using variables, or as I like to think of them, boxes. Let’s get our feet wet: Type the following: s = &quot;hello world!&quot;.upcase s Click here for a REPL to try it. (Keep this REPL open when you are done, we’ll use it in the next few steps.) This creates a box, labels it s, and stores the string \"HELLO WORLD!\" in it. The variable assignment operator The single equals sign, =, is called the variable assignment operator. When I read s = &quot;hello world!&quot;.upcase out loud, I say “the string hello world dot upcase is assigned to the variable s”. I read the right side first, because that’s how Ruby reads it too; it first evaluates the expression on the right side of the =, and then it stores the resulting value in the variable on the left. Now add another line to the previous REPL, s = &quot;hello world!&quot;.upcase s.reverse s And keep this REPL open, since we’ll be using it below. Great! Now we’re making progress. Storing the next return value What would you expect to happen if you add a third line so that your program reads: s = &quot;hello world!&quot;.upcase s.reverse s.gsub(&quot;L&quot;, &quot;Z&quot;) Do it! Type the above code into your current REPL. What do you think s contains now? Try it: s Did it match your expectations? Most Ruby methods don’t modify the object that they are called upon; they just return a modified copy. The original variable is untouched, so if we want to hold on to the new value then we better store that too. Type this: s = &quot;hello world!&quot;.upcase t = s.reverse u = t.gsub(&quot;L&quot;, &quot;Z&quot;) u Do it! Type the above code into your current REPL. Fortunately, we can create as many variables as we want. Updating variables It can get old coming up with different variable names for every step of the program. Instead, we usually want to re-use existing variables. We can throw away what we have in the box and put in something entirely different with the same assignment operator, =. Type this: s = &quot;hi&quot; s = 2.odd? s Do it! Type the above code into your current REPL. We can even replace the value in the box with an updated version of the old value, because the expression on the right side of the assignment operator is evaluated before the assignment takes place. Type this: s = &quot;hello, world!&quot; s = s.capitalize s = s.reverse s Do it! Type the above code into your current REPL. That may look strange — how can we use s on the left side and the right side of the =? But it’s because this is not the equals sign from math class; this is the variable assignment operator, and the right side is evaluated first until only a single value is left; and then that object is assigned into the box on the left (replacing whatever was there before). So you will very often see something like this: counter = counter + 1 When we’re keeping track of e.g. how many times we’ve printed something out on the screen. We are taking the original value of counter, adding 1 to it, and then replacing the contents of counter with that new total. Variable syntax You may have noticed that the variable assignment syntax is a departure from the primary syntax of object.method. But we do it all day long, so we need to know it just as well. Our programs will end up looking like this (these are made-up method names, so this code won’t work): storage_box_1 = &quot;starting data&quot;.first_transformation storage_box_2 = storage_box_1.second_step storage_box_3 = storage_box_2.third_method.maybe_even(&quot;another&quot;, &quot;one&quot;) # etc for dozens or hundreds of lines First, the expression on the right side of the assignment operator will be evaluated until there are no methods left and there’s just a piece of data remaining. Then, that value will be placed in the variable named on the left side of the assignment operator, which will be created if it doesn’t exist, or will have its value replaced if it does exist. Most programs are just a long succession of statements where we do some work with object.method and store the result in some variable, then we do some more work on that variable and store the result in yet another variable, and a hundred steps later we’ve produced our final result and we display that to our user. Variable naming rules When you are choosing your variable names, there are some rules: Variable names can only contain lowercase letters (a..z), numbers (0..9), and underscores (_) — they can’t contain spaces. Variable names cannot begin with a number. Rubyists strive to choose descriptive variable names, no matter how long they are, so that it’s obvious to teammates what the contents are at a glance. Please avoid naming your variables x, y, and z. Use underscores to separate words in multi-word variable names, since we can’t use spaces. 1.1.11 That’s it That’s it for the fundamental grammar of Ruby! storage_box = noun.verb(input1, input2) It’s not that much worse than the calculator language, is it? Of course, there’s a bit more syntax (like how to define our own nouns and verbs) that we need to learn, but for the most part, object.method is the bulk of what we do. Now we need to spend some time expanding our vocabulary — what are the most commonly used data types in Ruby, and what are some of their methods? That’s coming up next. "],["a-few-program-notes.html", "1.2 A few program notes", " 1.2 A few program notes Before we continue, I want to pause and discuss what, why, and how we’re going to be learning. 1.2.1 What’s our goal? Our goal is to build and deploy a fully-functional application, which will require that we learn a little bit about every part of the “stack” — the interface that users interact with all the way through to the server that the application runs on. We’re going to work from the inside-out. We’ll start by learning how to manage information with a database, because that is the heart of any useful application. Then we’re going to learn how to expose an interface for users to get information in and out of our database — we’ll be starting with a web client because that’s the quickest way to get up and running, but we could add an iPhone or Android client later. 1.2.2 Why Ruby? For all of the above, we’re going to use the Ruby language. There are many languages we could have chosen, but Ruby has a lot of advantages for beginners: Developer happiness Compared to other languages, Ruby is a pleasure to write and to read. Here’s Yukihiro Matsumoto (a.k.a. “Matz”), the creator of Ruby: Often people, especially computer engineers, focus on the machines. They think, “By doing this, the machine will run faster. By doing this, the machine will run more effectively. By doing this, the machine will something something something.” They are focusing on machines. But in fact we need to focus on humans, on how humans care about doing programming or operating the application of the machines. — Yukihiro Matsumoto, The Philosophy of Ruby Matz’s focus when he designed Ruby was on “developer happiness”, which was pretty bold back in 1995 when Ruby was first released. Optimizing for human readability rather than computer readability meant paying a cost in terms of performance, and computers were slow back then; but Matz didn’t care. Happily, computers are very fast today5 From a business perspective, servers are very cheap while developers are very expensive; so you should pick the language that makes developers the most productive., and they can run Ruby just fine; so now we beginners can have the best of both worlds. Besides, once you’ve learned the basic concepts of programming, they’re not hard to translate into the syntax of another language6 If you decide to pursue software development, you’ll end up learning at least half-a-dozen languages. Whatever challenge is thrown your way, you’ll choose the right tool for the job.. Ruby on Rails and other libraries People often ask “What’s the best language for task X?” Depending on the task, sometimes a language is particularly well-suited to it technically; but that is very rare. In general, any programming language can do anything that any other language can (unless maybe there is some kind of proprietary platform lock-out). However, there’s another very important consideration: which language has the largest community of developers doing task X? More community means more shared code (known as libraries, or in Ruby-land, gems7 Gems are little collections (folders and files) that contain Ruby objects and methods written by another developer, which we can import into our code and use. Most gems are hosted here.), more blog posts, more answers when you Google a question, etc. For example, Python and Ruby are very similar languages in terms of their technical features and performance profile. However, by some historical accident, Python seems to have gathered more of the scientific/data analysis/machine learning community around it, so more open-source libraries in those areas have been developed and shared in Python than in Ruby; and so now Python is the go-to language for those tasks. On the other hand, for agile development of database-backed applications, Ruby has a huge and thriving community. In particular, there is an open-source library for building applications called Ruby on Rails (“Rails”, for short) that makes small teams or even solo developers incredibly productive. The existence of Rails alone makes the Ruby language a good choice8 Here’s a longer blog post on why Ruby on Rails is still a good choice in 2019. for both startups and beginners. The philosophy of Rails is “convention over configuration” — it makes a lot of decisions on your behalf, and if you go with the flow, then things “just work”. (If you want to fiddle with settings, then of course you can, to your heart’s content; but you don’t have to spend hours or days doing so before anything will even show up, like you do in most other frameworks.) You can focus on building the unique features of your application, not on plumbing that’s common to all applications. There are a lot of other powerful, easy-to-use Ruby libraries that have philosophies similar to Rails. Ruby seems to have gathered a community of developers around it who are more about creating value for our users, and less about bike shedding over technical details9 I, personally, agree with this author who prefers boring technologies over cutting-edge ones.. MINASWAN The programming world at large can be pretty competitive and harsh, but I’ve found that the Ruby community is very inclusive and welcoming, which is a relief for beginners. Maybe this can also be traced back to Matz; from his Wikipedia page, His demeanor has brought about a motto in the Ruby community: “Matz is nice and so we are nice,” commonly abbreviated as MINASWAN. Heroku and other integrations Another way in which the ergonomics of Ruby excels is the amount of tooling that exists around it. For example, Heroku was the first “platform as a service”, a layer on top of Amazon Web Services that makes it incredibly easy to deploy applications to an industrial-grade infrastructure. Something that would have itself required a whole separate course to learn how to do, we can now do with just one click; and we can focus instead on building features for our users. Rails was the first platform that Heroku supported, and Rails developers are still Heroku’s primary users. There are many other services, everything from performance monitoring to error reporting to email delivery to A/B testing to analytics, that offer tight integrations with Ruby and/or Rails and make using them hyper-productive for small teams, solo developers, and therefore also for us beginners. 1.2.3 How are we going to go from zero to Hero(ku)? To go from complete beginner to deploying a fully functional application is quite a bit of ground to cover. Here’s how we’re going to do it: Cloud editors As you’ve already seen, we’re going to start by writing Ruby right here in your browser. This is the lowest-friction way to get started, and will allow us to focus on learning Ruby without having to waste mental energy on installing tools. Later, if you decide to continue with software development for the long-term, you may want to install Ruby on your own computer and switch to a more powerful code editor. We’ll provide guidance on how to do that. Make the invisible visible One of our foundational principles while programming, learning, and almost anything else, is to find a way to make the invisible visible — that is, find a way to give yourself concrete feedback on what you’re doing. Don’t guess what’s happening at each step of the program — find a way to see what’s happening, if at all possible. Feedback is crucial. Printing values Let’s talk a little bit more about how the REPLs work. So far, we’ve been using IRB to run one line of Ruby at a time. But our programs will be thousands of lines long, ultimately; and we want to save them permanently into files, not type them in one line at a time. So, from now one we’ll write them in the editor on the left side of the REPL window; then we’ll run the program by clicking “▶ Run” and seeing the output in the neighboring terminal. There won’t be any output unless we specifically say what we want to print into the terminal. It turns out there’s a special method in Ruby called Kernel.p (p is short for “print inspect”) that will display its argument in the terminal. Try running the following in a REPL: s = &quot;hello world!&quot;.upcase t = s.reverse u = t.gsub(&quot;L&quot;, &quot;Z&quot;) Kernel.p(s) Kernel.p(t) Kernel.p(u) Click here for a REPL to try it. Printing values to the terminal is something we’re going to want to do a lot, and so Ruby makes it easy for us; rather than having to type Kernel.p, we can just type the shorthand of p. Change Kernel.p to p above and give it a try. Optional parentheses around arguments To make it even easier to make the invisible visible, here’s another shortcut: When we discussed arguments, we said that they always come within parentheses. That’s not quite true. Ruby allows you to, optionally, leave out the parentheses; so the following will also work: p &quot;HELLO WORLD!&quot; And when you are roaming the internet, you will see this style often, especially with p. My advice to you is: you can drop the parentheses when you are printing, but other than that, always include them. They help to keep things clear, and they prevent order-of-operations errors. Use p a lot I like to use p a lot while I am programming. As I said, one of my fundamental programming principles is make the invisible visible — don’t try to guess what’s going on, find a way to see what’s going on. p is an excellent tool for that, so I use p like crazy, sometimes before almost every line while I am debugging. It can be tedious to wrap every line in parentheses, and it’s convenient instead to just pop a p at the beginning of a line. So in this one case, I give you permission to omit the parentheses around arguments to a method. Enjoy! Passing tests The REPLs are good for experimentation and getting a feel for how things work. But, in the following chapters, we’re also going to have a separate GitPod assignment with graded exercises that include automated tests. Look out for the ✏️ prompt for those. You will have to complete these exercises as you go through the chapter and rails grade to ensure comprehension. Hopefully this will surface questions — our constant goal. 1.2.4 Onwards Okay! With that housekeeping out of the way, let’s move on and learn more about the Fundamental Classes of Ruby, starting with String in the next chapter. "],["string.html", "1.3 String", " 1.3 String Let’s start by getting a more formal introduction to our friend, String. First of all, notice that when I refer to Ruby classes, I capitalize the first letter. The only time we use capital letters when we’re programming is when we refer to Ruby classes. All other times — variable names, file names, etc — we’re going to use lowercase letters only (other than when we’re writing some copy inside a string, of course). 1.3.1 Creating strings We’ve actually been taking a shortcut this whole time when we’ve been saying something like s = &quot;Hello, world!&quot; In Ruby, the formal way to create a new object is to use the .new method on the parent class: s = String.new This will, however, just give us back an empty string \"\". Make the invisible visible in GitPod Let’s practice making the invisible visible. We will spend a moment getting a GitPod workspace set up, and then running Ruby programs from the terminal there. The steps are: Sign up for a Gitpod.io account. It will ask you to sign in using your GitHub account. We will create a workspace for each project that we work on. Each workspace is based on a GitHub repository (i.e., a folder with some code in it). For example, here is a repository: https://github.com/appdev-projects/helloruby To create a Gitpod workspace based on a repo, in the address bar of your browser enter https://gitpod.io/# and then the URL of the repo. For example, https://gitpod.io/#https://github.com/appdev-projects/helloruby This creates a blank, brand-new computer. This is not a REPL, nor is it an HTML application like we made for Rock, Paper, Scissors. But Ruby is installed on this computer. We can create a Ruby file by right-clicking in the file explorer and selecting “New File”. We can call our file howdy.rb, making sure to end it with the extension .rb. With howdy.rb open in the editor window, we can add some code like p \"Hello, world!\", and save the file (or turn on “Auto Save”). Now we can run the file by clicking on the terminal and typing (after the $-sign): ruby howdy.rb. When we press return on our keyboard, the code in howdy.rb will execute and show us the result! To get more comfortable with these steps, create another file called invisible_to_visible.rb, and fill it with this code: # One-by-one, uncomment the p statements # below and rerun the code s = String.new # p s s = &quot;Hello, world!&quot; # p s s = s.upcase # p s Once the file is saved, remove the leading # from the print statements one by one, and run the code each time with ruby invisible_to_visible.rb at the terminal prompt. You don’t need to type it out every time, you can just press the Up ↑ arrow key when your cursor is at the terminal $-sign prompt to cycle to the previous entry. When you are done experimenting, feel free to close the GitPod project window. We will open another project momentarily and only one GitPod tab will limit confusion. ASCII Codes With the String.new approach, we would have to add each character to our variable s one by one. One way to do so is by using the .concat method, which accepts a number as an argument, interprets it as an ASCII code, translates it into a single character, and adds it on to the end of the original string. What’s an ASCII code? At the hardware level, computers only store integers (specifically, in binary form — using only 0s and 1s); so all other datatypes need to be encoded somehow as a number. ASCII, or American Standard Code for Information Interchange, was one scheme that was developed in the early days of computing to store English characters as integers10 Nowadays we use much more sophisticated encoding schemes such as Unicode that supports glyphs from many more languages, and even emojis  Fortunately, Ruby handles most of this low-level stuff for us behind the scenes, so we never really have to worry about it anymore.. The codes are as follows: ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character 32 (space) 48 0 64 @ 80 P 96 ` 112 p 33 ! 49 1 65 A 81 Q 97 a 113 q 34 \" 50 2 66 B 82 R 98 b 114 r 35 # 51 3 67 C 83 S 99 c 115 s 36 $ 52 4 68 D 84 T 100 d 116 t 37 % 53 5 69 E 85 U 101 e 117 u 38 &amp; 54 6 70 F 86 V 102 f 118 v 39 ' 55 7 71 G 87 W 103 g 119 w 40 ( 56 8 72 H 88 X 104 h 120 x 41 ) 57 9 73 I 89 Y 105 i 121 y 42 * 58 : 74 J 90 Z 106 j 122 z 43 + 59 ; 75 K 91 [ 107 k 123 { 44 , 60 &lt; 76 L 92 \\ 108 l 124 | 45 - 61 = 77 M 93 ] 109 m 125 } 46 . 62 &gt; 78 N 94 ^ 110 n 126 ~ 47 / 63 ? 79 O 95 _ 111 o Given those ASCII codes, we can now build up a new string from scratch like so: # instantiate a new variable of String class my_string = String.new # make the invisible visible! p my_string # =&gt; &quot;&quot; # use the concat method to add characters # one-by-one to the empty string variable my_string.concat(72) my_string.concat(101) my_string.concat(108) my_string.concat(108) my_string.concat(111) my_string.concat(44) # make the invisible visible! p my_string # =&gt; &quot;Hello,&quot; # add some more characters again my_string.concat(32) my_string.concat(119) my_string.concat(111) my_string.concat(114) my_string.concat(108) my_string.concat(100) my_string.concat(33) # make the invisible visible! p my_string # =&gt; &quot;Hello, world!&quot; This is just a quick sandbox, so click here for a REPL to try it. Start the GitPod Project Once you’ve played with the REPL, it’s time to move into the graded project environment. In our previous steps, we opened a GitPod workspace via https://gitpod.io/#[SOME REPO]. But, for most projects, you will be “forking” an existing GitHub repo to your account, then opening it on GitPod, so that you can save changes and keep your own copy around for future reference. We prepared these steps, so you just need to click on the Load assignment button when you see it. Note: these steps go for opening any GitPod project, just change the project and file names. Open the GitPod String project for this chapter and start with the exercises. Follow the instructions below and complete the task in the concat.rb file. LTI{Load assignment}(https://github.com/bpurinton-appdev/string-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[string_project] Open the concat.rb file in the editor window. Modify the file per the instructions on top. Run your Ruby file by typing ruby and then the name of the file you want to run in the terminal. If we want to run concat.rb, we can write the command: ruby concat.rb Remember, if there are multiple files with similar names, start typing the name and then just press Tab on your keyboard to let the terminal complete the name. You rarely need to type full filenames out — use tab completion! To re-run this command, you can use the Up ↑ and Down ↓ arrow keys to look at the history of commands you’ve run in a terminal. When you think you have the required output, run rails grade at the terminal prompt and proceed when the test(s) passes without errors. If you are struggling, try to experiment directly in the irb environment by typing irb into the terminal and pressing enter. This will start an interactive Ruby terminal, where you can enter individual lines of Ruby to see their output. If you start irb then the terminal will no longer be in the bash environment so things like rails grade won’t work. You will need to open a second terminal with the plus (+) icon and switch between the irb and bash terminals as needed. Alternatively type exit at the irb terminal prompt to return to the bash environment. If you ever want to clear the terminal output to see a fresh new line, press Ctrl+K. And if you ever close the terminal and need to re-open it, press Ctrl+J. String literals Done with concat.rb? What a pain! Now that we’ve shown that, under the hood, even creating a string follows the syntax of noun.verb — let’s never do it again. From now on, we’ll use the shortcut of creating string “literals” in place by typing the characters we want within quotes: \"Thank goodness!\" These kinds of exceptions to the regular grammar in order to make life easier are known as “syntactic sugar”. 1.3.2 Methods Next, let’s familiarize ourselves with some of the String class’s methods. For each method below, there is a an .rb exercise in the GitPod project. So keep that project window open and work through it with rails grade as you go! For each method below, we’ve provided some REPLs. They are there for you to experiment with the code, click “▶ Run”, or use the irb terminal and see how the methods work. Keep these methods in mind when working on the assignments in Gitpod. String addition, a.k.a. + We’ve already met the .concat method. .concat can accept an integer as an argument, which it interprets as an ASCII code, translates into a single character, and adds to the original string: &quot;hi&quot;.concat(33) # =&gt; &quot;hi!&quot; .concat can also accept a string literal as an argument, in which case it just adds the whole thing to the end of the original string. &quot;hi&quot;.concat(&quot; there&quot;) # =&gt; &quot;hi there&quot; There’s also a shorthand for .concat: .+.11 This is not quite true. The + method is not just an alias for concat — they do slightly different things. But they’re close enough, for our purposes. That may look a little funny, but it’s nothing special, really; it’s just a method with a very short (one letter long) name: &quot;hi&quot;.+(&quot; there&quot;) # =&gt; &quot;hi there&quot; But here’s where it gets interesting; Ruby has another bit of nice syntactic sugar for us. If a class has a method named +, then you are allowed to drop the . before the method name when you call it, and just say: &quot;hi&quot; +(&quot; there&quot;) # =&gt; &quot;hi there&quot; Wild! And, as we learned earlier when we were introduced to the p method, Ruby also allows you to omit the parentheses around arguments if you want to; so this can be further shortened to: &quot;hi&quot; + &quot; there&quot; # =&gt; &quot;hi there&quot; Now this is really starting to look familiar! It’s a lot like the calculator language, actually. Developer happiness, indeed. a = &quot;Hello&quot; b = &quot;World&quot; p a + b # =&gt; &quot;HelloWorld&quot; # You can add strings together Click here for a REPL to try it. Return to the GitPod String project and work through addition.rb String multiplication, a.k.a * Strings can be multiplied by numbers using the * method12 More syntactic sugar here, like with the + method above; you can say \"Ya\" * 5 rather than \"Ya\".*(5).: &quot;Ya&quot; * 5 # =&gt; &quot;YaYaYaYaYa&quot; This sort of makes sense, if you think about multiplication as being repeated addition. p &quot;Hello&quot; * 3 Click here for a REPL to try it. The order matters, though. See what happens when you try: 3 * &quot;Hello&quot; Read The Error Message (RTEM)! Does this make sense? \"Hello\" * 3 is calling the String method * with an argument of 3, which kinda makes sense (add \"Hello\" to itself 3 times). But 3 * \"Hello\" is calling the Integer method * with an argument of \"Hello\", which doesn’t make much sense (what would it mean to add 3 to itself \"Hello\" times?). Thus, we can see why the String version of * and the Integer version of * both need an integer argument. Again, the bottom line is — at all times as you are writing Ruby, you should be thinking: “What class is this object? What methods does this class have available?” Even when there’s some syntactic sugar making things look unconventional, don’t forget your basics! It’s still noun.verb under the hood. Return to the GitPod String project and work through multiplication.rb upcase The upcase method returns a copy of the String with all lowercase letters replaced with their uppercase counterparts. p &quot;hello&quot;.upcase Click here for a REPL to try it. downcase The downcase method returns a copy of the String with all uppercase letters replaced with their lowercase counterparts. p &quot;I&#39;M NOT YELLING AT YOU&quot;.downcase Click here for a REPL to try it. swapcase The swapcase method returns a copy of the String with all uppercase letters replaced with their lowercase counterparts, and vice versa. p &quot;FaMiLy&quot;.swapcase # =&gt; &quot;fAmIlY Return to the GitPod String project and work through case.rb reverse The reverse method returns a new String with the characters from the String in reverse order. p &quot;I can speak in backwords words&quot;.reverse Click here for a REPL to try it. length The length method returns the number of characters (as an Integer) that a String has. p &quot;Supercalifragilisticexpialidocious&quot;.length Click here for a REPL to try it. chomp The chomp method is mostly used to remove the \"\\n\" (newline) character from the end of a string, if it is present: &quot;Raghu\\n&quot;.chomp # =&gt; &quot;Raghu&quot; &quot;Raghu&quot;.chomp # =&gt; &quot;Raghu&quot; This seemingly strange task is very common due to the way that getting user input works; usually someone has to type something at a prompt and then they press return to submit it, and that adds a “newline” (\"\\n\") to the end of the string that they typed. Typically, we want to chomp that off the end of their input before we do anything further with it. chomp can also remove other specified character(s) from the end of the string, if they are provided as an argument: &quot;1 apples&quot;.chomp(&quot;s&quot;) # =&gt; &quot;1 apple&quot; &quot;1 apple&quot;.chomp(&quot;s&quot;) # =&gt; &quot;1 apple&quot; Click here for a REPL to try it. Return to the GitPod String project and work through chomp.rb gsub The gsub method returns a copy of the String it was called on with all occurrences of the first argument substituted for the second argument. a = &quot;Hello&quot; p a.gsub(&quot;ll&quot;, &quot;ww&quot;) # =&gt; &quot;Hewwo&quot; Click here for a REPL to try it. Advanced gsub techniques gsub also supports accepting a regular expression as its first argument. We won’t get into regular expressions in detail right now, but all languages (C, C++, Python, etc.) include a way to write regular expressions and they are a very powerful way to check whether input strings match certain patterns. In Ruby, we work with regular expressions the way we work with everything else — via a class, Regexp. We create Regexp literals with forward slashes (like we use quotes to create String literals), and then put the pattern that we’re trying to match between the slashes. For now, we’re just going to copy-paste a few simple regexes13 If your project requires scanning text for patterns, then RegexOne is a good resource for learning more. Rubular is handy for quickly testing your regular expressions against some example strings. that come in handy with gsub, in particular: /\\s+/ matches all whitespace, so we can use it with gsub to remove all whitespace: &quot;Hello there,\\nfriend&quot;.gsub(/\\s+/, &quot;&quot;) # =&gt; &quot;Hellothere,friend&quot; /[^0-9]/ matches everything except numeric digits, so we can use it with gsub to remove everything except digits: &quot;March 29th!&quot;.gsub(/[^0-9]/, &quot;&quot;) # =&gt; &quot;29&quot; /[^a-z]/i matches everything except letters (case-insensitively using the i mode after the // slashes). So we can use it with gsub to remove everything except letters: &quot;March 29th!&quot;.gsub(/[^a-z]/i, &quot;&quot;) # =&gt; &quot;Marchth&quot; /[^a-z0-9\\s]/i matches everything except letters, digits, and whitespace, so we can use it to remove everything except for those: &quot;March 29th!&quot;.gsub(/[^a-z0-9\\s]/i, &quot;&quot;) # =&gt; &quot;March 29th&quot; Return to the GitPod String project and work through gsub.rb Return to the GitPod String project and work through regex.rb to_i Sometimes you have a string that contains a number, usually input from a user, and want to do math on it. to_i will attempt to convert a String object into an Integer object. p &quot;8&quot;.to_i Click here for a REPL to try it. strip strip removes all leading and trailing whitespace. p &quot; This has a lot of space on the outside &quot;.strip Click here for a REPL to try it. capitalize capitalize returns a String with the first character converted to uppercase and the remainder to lowercase. p &quot;beginning&quot;.capitalize Click here for a REPL to try it. Return to the GitPod String project and work through strip.rb include? include? takes a String argument and returns true or false if the argument exists in the String that include? is called on. p &quot;Happy Days&quot;.include?(&quot;H&quot;) p &quot;Happy Days&quot;.include?(&quot;Z&quot;) Click here for a REPL to try it. 1.3.3 More on adding strings together We spend a lot of time composing strings of output for our users, so let’s see a few more examples. Try this: number = 6 * 7 message = &quot;Your lucky number for today is &quot; + number + &quot;.&quot; Click here for a REPL to try it. You’ll see that Ruby gets confused (RTEM!), because we are trying to add an integer to a string and it doesn’t feel comfortable with that. The solution is to tell the Integer to convert itself to a String first using the method called .to_s, or “to string”. Try this instead: number = 6 * 7 message = &quot;Your lucky number for today is &quot; + number.to_s + &quot;.&quot; The above technique for composing strings, adding them together with +, is called string addition. There’s another technique for composing strings that I personally find a bit easier; it’s called string interpolation. Try this instead: number = 6 * 7 message = &quot;Your lucky number for today is #{number}.&quot; Basically, inside the string, you place #{} where you eventually want your value to go. Inside the curly braces, you can write any Ruby expression without worrying about whether it is a string or not. The expression will be evaluated, converted to a string, and added to the string right in that spot. You can interpolate as many expressions as you want into a single string. Pretty neat! If you find interpolation confusing, feel free to just use addition. 1.3.4 Getting strings from users with gets We can make our programs much more interesting if we allow the users of the program to interact with them by supplying input. We can do this with the gets method (pronounced “get S”, short for “get string”), which will pause the program and wait for the user to type something in the terminal and press return. The return value of the gets method will be a String containing what the user typed, which we can store in a variable and then process further like any other String. For example, rather than saying “Hello, world!”, let’s have the computer say hello to the user by name instead. When you run this program, it will pause after saying \"What's your name?\" and you will have to type something in and press return. Click on the terminal to put focus there, and then you’ll be able to type into it: p &quot;What&#39;s your name?&quot; their_name = gets p &quot;Hello, &quot; + their_name + &quot;!&quot; Click here for a REPL to try it. Great! Our first user input. However, you’ll notice a couple of things. First of all, there’s a \\n sneaking into the input. \\n represents a newline character, and it’s in there because of the return that is pressed to submit the input. puts If you want to see the newline in action, we can use a different printing method called Kernel.puts (pronounced “put S”, short for “put string”). puts is actually the printing method that is used most when crafting the final output of command-line programs; as opposed to Kernel.p, which is used most for making the invisible visible while debugging. Try switching p &quot;Hello, &quot; + their_name + &quot;!&quot; to puts &quot;Hello, &quot; + their_name + &quot;!&quot; and see how the output is different. You can see that the quotes around the string are removed, which makes sense if you’re actually displaying output to a user and not debugging — users should not know or care about the quotes around Ruby string literals. And the newline character causes a line break when a string is printed with puts, as it should. Most of the time, we’ll stick with p, since it provides more details while debugging; but it’s good to know that puts exists. gets.chomp We almost never want to keep the \\n that results from the return keypress that submits the user’s input. Fortunately, the handy .chomp method does exactly what we need — if there’s a \\n at the end of a string, it will remove it; if there isn’t, it does nothing. So, in practice, when we call gets we almost always tack a .chomp on to it immediately. Try modifying the program to: their_name = gets.chomp and see how it’s different. Return to the GitPod String project and work through gets.rb 1.3.5 Conclusion That’s about all we’ll need to know about strings to do most anything related to web applications! Next, we’ll take a look at numbers, starting with Integer. "],["integer.html", "1.4 Integer", " 1.4 Integer Ruby differentiates between whole numbers, or Integers, and decimal numbers, or Floats. 7.class # =&gt; Integer 7.0.class # =&gt; Float (In fact, you can always call the method .class on any object, ever, at any time, to ask it what class it is.) We’ll learn about integers first. 1.4.1 Syntax Integers begin with a digit (0-9) and end when Ruby meets anything other than a digit (a space, a comma in an array, a closing parentheses at the end of method arguments, etc) — except for underscores, which you can use as a delimiter if it helps to understand the number: 10000000 # Is this 1 million? 100 million? 10_000_000 # Ah, it&#39;s easier to tell now. 1.4.2 Methods Let’s experiment with some common methods for Integers: + - * / % ** (math) We, of course, have the standard math methods, like the calculator language. These methods all have the same syntactic sugar that the String versions did, so we can say 12 + 5 rather than 12.+(5) (thankfully). Try each of the following: 12 + 5 12 - 5 12 * 5 12 / 5 Click here for a REPL to try it. Whoa! Did you get what you expected for that last one? It turns out that the Integer version of division will only return another Integer, and so / only returns the whole part (like in elementary school). If you want the remainder, you have to use the % (called the “modulus”) operator. Try this: 12 % 5 Another maybe unexpected thing: raising a number to a power, e.g. 32, is not done using the ^ like in many other computing environments. Instead, use the double-star ** operator: 3 ** 2 Once you’ve played with the REPL, it’s time to move into the graded project environment. Open the GitPod Integer project for this chapter and start with the exercise math.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/integer-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[integer_project] For a GitPod refresher, see here. odd? and even? The .odd? and .even? methods return true or false based on whether the number is, well, odd or even. Don’t be thrown off by the question mark at the end of the method name — it’s nothing special, just another letter. Rubyists like to end method names with a question mark when methods return true or false. p 7.odd? Click here for a REPL to try it. Return to the GitPod Integer project and work through odd.rb rand There’s another special method like p that we are allowed to call “in space”, i.e. not on the right side of a dot14 This is another method defined on Kernel, so the longhand would be Kernel.rand(6)., called rand. It returns a random number, and is very useful for all kinds of stuff, everything from games to statistical analysis: rand(6) # =&gt; returns a random integer between 0 and 5 Somewhat oddly, rand(n) will return a random integer between 0 and n - 1 rather than between 1 and n. That may seem surprising, but it’s actually pretty handy because a lot of times what we want to do is generate a random offset and it’s convenient for that to include 0 as a possibility. Give it a try: # random number between 0 and 8 p rand(9) Click here for a REPL to try it. to_s We often will want to combine our Integers with Strings when crafting output for our users. Give it a try: lucky_number = rand(100) p &quot;Your lucky number is&quot; + lucky_number Uh oh! RTEM! It turns out that String’s + method can only add two strings together, not a string and an object of some other class. So, a lot of times we’ll need to convert an Integer into a String prior to output. Fortunately Integer has a handy method, to_s (or “to string”), that does just that: p 98.to_s Click here for a REPL to try it. to_f Similarly, there’s a to_f (or “to float”) method to convert an Integer to a Float, which is often handy for doing math, as we’ll see next. BENP: maybe combine to_i, to_f and to_s here in a gitpod exercise / modify integer_birth_year. integer_birth_year could move to dates chapter Return to the GitPod Integer project and work through birth_year.rb 1.4.3 Conclusion That’s it for Integer. Next up, its close cousin: Float. "],["float.html", "1.5 Float", " 1.5 Float Ruby calls decimal numbers Floats. To create a Float rather than an Integer, just make sure to include a decimal point: 5.class # =&gt; Integer 5.0.class # =&gt; Float 1.5.1 Methods + - * / ** (math) The math methods work mostly like you’d expect, and similarly to the ones for integers. The main difference to keep in mind is with /. Division with floats works the way that we’re used to — it returns fractional results, as a Float: 12.0 / 5.0 # =&gt; 2.4 Try the following and see what you get: 12 / 5 12.0 / 5 12 / 5.0 Click here for a REPL to try it. What did you discover? If either side is a float, float division will be performed. This is why Integer’s .to_f method can come in handy while doing math; at some point if you need to do division and need a fractional answer, then convert it to a Float first. One other thing to keep in mind: you can use ** in conjunction with fractions to calculate roots, since 91/2 is the same as the square root of 9, 81/3 is the same as the cube root of 8, etc. 9 ** 0.5 # =&gt; 3.0 8 ** (1/3.0) # =&gt; 2.0 Open the GitPod Float project for this chapter and start with the exercise find_hypotenuse.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/float-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[float_project] For a GitPod refresher, see here. Remember: the Pythagorean Theorem says that where a and b are the lengths of the shorter sides, and c is the length of the longest side. Read more about the formula here. round Floats can round themselves. Play around with the .round method: pi = 3.1415926535897932384626433832795028841976939937510 p pi.round(3) Click here for a REPL to try it. Return to the GitPod Float project and work through round.rb rand The rand method that we met earlier can also be called with no arguments, in which case it returns a Float between 0 and 1. This is very handy for e.g. probabilities. Give it a try: p rand Click here for a REPL to try it. 1.5.2 Conclusion That’s it for Float. Next up, we’ll learn to manipulate dates and times with the Date and Time classes. Addendum: Even more Float methods Looking for even more Float methods? Ruby on Rails enhances certain Ruby classes with additional convenience methods that aren’t included in plain ol’ Ruby. Many of these are included in the activesupport gem that comes with Rails; you could also include it in a pure Ruby program if you wanted to. To use the following methods within Ruby on Rails, you don’t have to do anything. To use the following methods in a plain Ruby script, include the line: require &#39;activesupport&#39; Formatting Floats as Strings As we know, you can call the .to_s method on a Float to convert the number into a String: 10.25.to_s # =&gt; &quot;10.25&quot; Within a Rails application15 Or anywhere using activesupport., you can provide a Symbol16 A Symbol is a Ruby Class that is similar to a String. Symbols start with a colon (:) at the beginning. See the chapter section here. as an argument to Float’s to_s method. This allows you to convert the Float to a String and add additional formatting at the same time. Phone 5551234.to_s(:phone) # =&gt; &quot;555-1234&quot; In addition to providing a Symbol to the to_s method, you can provide an additional Hash17 A Hash is another Class is Ruby that. See the Hash chapter. Until you read that chapter, just be aware that this kind of formatting is possible and easy to do in a Rails application. argument to tweak the some finer details about how we want to format the Float. 1235551234.to_s(:phone, { :area_code =&gt; true } # =&gt; &quot;(123) 555-1234&quot; 1235551234.to_s(:phone, { :country_code =&gt; 1 } ) # =&gt; &quot;+1-123-555-1234&quot; 1235551234.to_s(:phone, { :area_code =&gt; true, :extension =&gt; 555 }) # =&gt; (123) 555-1234 x 555 Currency 1234567890.50.to_s(:currency) # =&gt; &quot;$1,234,567,890.50&quot; 67890.506.to_s(:currency, { :precision =&gt; 3 }) # =&gt; &quot;$67,890.506&quot; Percentage 100.to_s(:percentage) # =&gt; &quot;100.000%&quot; 100.to_s(:percentage, { :precision =&gt; 0 } ) # =&gt; &quot;100%&quot; 1000.to_s(:percentage, { :delimiter =&gt; &quot;.&quot;, :separator =&gt; &quot;,&quot; }) # =&gt; &quot;1.000,000%&quot; "],["date.html", "1.6 Date", " 1.6 Date Sure, we could just use a String to represent a date, like \"April 19, 1987\". But Ruby has a built-in class that makes it much easier to work with dates: Date. 1.6.1 Creating a date The Date class isn’t loaded into every Ruby program by default, so to use it we first need to say require &quot;date&quot; (Usually we omit the parentheses around the string argument to the require method. Just like when we use p \"Hello, world!\" as opposed to p(\"Hello, World!\").) 1.6.1.1 Date.new After require \"date\", we can create a new instance as usual with: Date.new # =&gt; #&lt;Date: -4712-01-01 ((0j,0s,0n),+0s,2299161j)&gt; By default, the new date is January 1st, of the year -4712! Interesting18 Year 1 of the Julian Period was 4713 BC (−4712)., but not very helpful. You can also pass Date.new arguments to initialize with a specific year, month, and day: Date.new(2001) #=&gt; #&lt;Date: 2001-01-01 ...&gt; Date.new(2001,2,3) #=&gt; #&lt;Date: 2001-02-03 ...&gt; Date.new(2001,2,-1) #=&gt; #&lt;Date: 2001-02-28 ...&gt; 1.6.2 Date Methods Date.today The Date.today method returns an object initialized to the current date. Date.today # =&gt; #&lt;Date: 2019-04-16 ((2458590j,0s,0n),+0s,2299161j)&gt; year Call the year method on a Date object to return just the year of the date as an Integer. t = Date.today # =&gt; #&lt;Date: 2019-04-16 ((2458590j,0s,0n),+0s,2299161j)&gt; t.year # =&gt; 2019 month Call the month method on a Date object to return just the month of the date as an Integer. t = Date.today # =&gt; #&lt;Date: 2019-04-16 ((2458590j,0s,0n),+0s,2299161j)&gt; t.month # =&gt; 4 day Call the day method on a Date object to return just the day of the date as an Integer. t = Date.today # =&gt; #&lt;Date: 2019-04-16 ((2458590j,0s,0n),+0s,2299161j)&gt; t.day # =&gt; 16 Open the GitPod Date project for this chapter and start with the exercise formatted.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/date-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[date_project] For a GitPod refresher, see here. Date.parse The Date.parse() method accepts a String argument and tries to interpret it as a date, initializing a Date object. Date.parse(&quot;2001-02-03&quot;) #=&gt; #&lt;Date: 2001-02-03 ...&gt; Date.parse(&quot;20010203&quot;) #=&gt; #&lt;Date: 2001-02-03 ...&gt; Date.parse(&quot;3rd Feb 2001&quot;) #=&gt; #&lt;Date: 2001-02-03 ...&gt; Subtraction You can subtract two dates from one another, which will return the number of days between them. The return value class is a Rational, which can be converted to a regular Integer with .to_i: number_of_days = Date.today - Date.parse(&quot;July 4, 1776&quot;) =&gt; (88674/1) days.to_i =&gt; 88674 Return to the GitPod Date project and work through math.rb monday? Returns true if the date is a Monday. tuesday? Returns true if the date is a Tuesday. wednesday? Returns true if the date is a Wednesday. thursday? Returns true if the date is a Thursday. friday? Returns true if the date is a Friday. saturday? Returns true if the date is a Saturday. sunday? Returns true if the date is a Sunday. wday Returns the day of week (0-6, Sunday is zero). Date.new(2001,2,3).wday #=&gt; 6 Return to the GitPod Date project and work through monday.rb 1.6.3 Time Ruby has a Time class as well, that shares most of its methods with the Date class. Time.now.wday # =&gt; 6 Time.now.saturday? # =&gt; true Time.now.day # =&gt; 3 strftime The strftime method is used on a Date or Time object. It requires a String argument that will be used to format the Date or Time in a particular way. Assuming today is Monday, September 7th 2020 Time.now.strftime(&quot;%A&quot;) # =&gt; &quot;Monday&quot; Time.now.strftime(&quot;%B&quot;) # =&gt; &quot;September&quot; Time.now.strftime(&quot;%b&quot;) # =&gt; &quot;Sep&quot; Time.now.strftime(&quot;%a %e, %R %p&quot;) # =&gt; &quot;Mon, 7 14:35 PM&quot; You should not try to memorize what these patterns mean. Tools like strftime.net and For a Good Strftime exist to help compose the formatting string argument. 1.6.4 Conclusion That’s it for Date and Time. Next up, we’ll learn how we can make lists of data with the Array class. "],["array.html", "1.7 Array", " 1.7 Array Next, we have a very important class: Array. Most of what we do as developers is manage lists of things. Lists of photos, likes, followers, reviews, listings, messages, rides, events, concerts, projects, etc etc etc. The first data type we’re going to learn to help us manage lists of things is Array. This class, unlike the ones we’ve seen until now, is really just a container for other objects, and can hold however many objects we want. 1.7.1 Creating arrays As always, we have the formal way of creating a new object in Ruby: use the .new method on the parent class: cities = Array.new Try it out and see what you get if you p cities: Click here for a REPL to try it. push As you can see, Ruby represents an Array with square brackets, []. The brand new array is empty; let’s add some elements to it with the .push method. Try this: cities = Array.new cities.push(&quot;Chicago&quot;) cities.push(&quot;NYC&quot;) p cities cities.push(&quot;LA&quot;) # Add some of your own, if you like p cities Now we’re talking! We’ve stored multiple strings within a single array using the .push method19 You might come across a shorthand for .push, the &lt;&lt; method, known as the “shovel” operator. This allows you to write something like: cities.&lt;&lt;(\"Chicago\"). Or with the syntactic sugar that we’re very accustomed to by now: cities &lt;&lt; \"Chicago\" I personally prefer .push — I think it’s more readable — but feel free to use the shovel if you like it better.. Ruby separates the elements in an array with commas. Array literals Much like with Strings, there’s a shortcut to creating Arrays. Rather than starting with Array.new and building it up from scratch one .push at a time, we can type an array “literal” directly into the code: cities = [&quot;Chicago&quot;, &quot;NYC&quot;, &quot;LA&quot;] This is the technique that we’ll be using most often. 1.7.2 Methods Now let’s familiarize ourselves with some of Array’s methods. at After adding elements to the list, the next most important thing we need to be able to do is retrieve an element back out from the list. Our first tool for doing that is .at. The .at method takes an Integer argument, which is interpreted as the position, or index, in the Array of the element that you want to retrieve. Give it a try: cities = [&quot;Chicago&quot;, &quot;NYC&quot;, &quot;LA&quot;, &quot;SF&quot;, &quot;NOLA&quot;] p cities p cities.at(2) Click here for a REPL to try it. Whoa! Did you expect cities.at(2) to return \"LA\"? I sure didn’t, the first time I tried it; I was expecting \"NYC\". It turns out that pretty much every programming language indexes the elements in an array starting at zero, not at one. So the first element is retrieved with cities.at(0), the second element with cities.at(1), etc. You’ll get used to it after a while. A couple of other things for you to experiment with: What happens when you use an index greater than the length of the array? This is our first contact with nil, an object that represents the absence of anything. When you use an index “outside” the array, you might have expected to see an error message; but instead, Ruby returns nil. What happens when you use a negative index? at shorthand, [] There’s a shorthand for .at() which is very common, so you should be familiar with it. It’s the .[] method, so we could write: cities = [&quot;Chicago&quot;, &quot;NYC&quot;, &quot;LA&quot;, &quot;SF&quot;, &quot;NOLA&quot;] p cities.[](2) # =&gt; &quot;LA&quot; You guessed it — there’s some syntactic sugar coming up. When a class has a method named .[], Ruby allows the dot to be dropped, but the method name has to then move immediately next to the object it’s being called on (no space), and the argument moves inside the method name! Altogether, this allows us to write: cities = [&quot;Chicago&quot;, &quot;NYC&quot;, &quot;LA&quot;, &quot;SF&quot;, &quot;NOLA&quot;] p cities[2] # =&gt; &quot;LA&quot; Which is sort of nice. I prefer .at because I think it reads better, but feel free to use the square brackets if you like that style better. array = [8, 3, 1, 19, 23, 3] p array[2] Click here for a REPL to try it. first, last Since retrieving the elements at positions 0 (the first one) and -1 (the last one) is so common, there are handy shortcut methods for those: .first and .last. Give them a try. index The .index method is sort of the inverse of .at: given an object, .index searches within the array and returns the index where it resides. Give it a try: cities = [&quot;Chicago&quot;, &quot;NYC&quot;, &quot;LA&quot;, &quot;SF&quot;, &quot;NOLA&quot;] p cities.index(&quot;SF&quot;) Click here for a REPL to try it. Some further things for you to experiment with: What will .index return if the element is present in the array more than once? What will .index return if the element is not present in the array at all? String#split Before we proceed with more Array methods, I want to go back for a minute and talk about a method for the String class: .split. This method, when called on a String, will return an Array of substrings: &quot;alice bob carol&quot;.split # =&gt; [&quot;alice&quot;, &quot;bob&quot;, &quot;carol&quot;] If you provide no argument, the string is split upon whitespace, which is handy for e.g. turning a sentence into a list of words: If you do provide an argument to .split, then the string will be chopped up wherever that argument occurs instead of whitespace — for example, use \"4,8,15,16,23,42\".split(\",\") to split on commas. You can also split with the empty string, \"\", as an argument in order to turn a string into an Array of its individual characters: a = &quot;Hello!&quot;.split(&quot;&quot;) # =&gt; [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;!&quot;] a.at(0) # =&gt; &quot;H&quot; a.at(-1) # =&gt; &quot;!&quot; BENP: need an exercise here, split(\"\") is important in .each project. Also, first time with negative indexing? Maybe insert something about this earlier in section (with exercise) This is particularly handy for us because it allows us to get a String of input from users with gets and then transform it into an Array for processing: p &quot;Enter a series of numbers, separated by spaces:&quot; user_string = gets.chomp user_numbers = user_string.split length = user_numbers.count p user_string p user_numbers p &quot;You entered &quot; + length.to_s + &quot; numbers.&quot; Click here for a REPL to try it. We’ll be using this technique frequently to make things more interesting. Open the GitPod Array project for this chapter and start with the exercise element_square.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/array-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[array_project] For a GitPod refresher, see here. count .count counts how many elements are in the list, if called with no arguments. If an argument is provided, it counts how many times that argument occurs in the list. a = [8, 3, 1, 19, 23, 3] p a.count p a.count(3) BENP: add project with count() with an argument, becomes important again in .each Click here for a REPL to try it. Return to the GitPod Array project and work through count.rb include? A thin convenience layer on top of .count, .include? will quickly tell you whether a value is present within an Array: a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] a.include?(&quot;b&quot;) # =&gt; true a.include?(&quot;z&quot;) # =&gt; false exclude? Similar to .include?, but the opposite: a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] a.exclude?(&quot;b&quot;) # =&gt; false a.exclude?(&quot;z&quot;) # =&gt; true reverse array = [8, 3, 1, 19, 23, 3] p array.reverse # =&gt; [3, 23, 19, 1, 3, 8] Click here for a REPL to try it. Return to the GitPod Array project and work through reverse.rb sort array = [12, 4, 5, 13, 56, 32] p array.sort # =&gt; [4, 5, 12, 13, 32, 56] Click here for a REPL to try it. shuffle array = [1, 2, 3, 4, 5] p array.shuffle # Returns a copy of array in random order Click here for a REPL to try it. sample array = [8, 3, 1, 19, 23, 3] p array.sample # =&gt; Returns a single random element from the array Click here for a REPL to try it. min a = [8, 3, 1, 19, 23, 3] p a.min # =&gt; 1 Click here for a REPL to try it. max a = [8, 3, 1, 19, 23, 3] p a.max # =&gt; 23 Click here for a REPL to try it. Return to the GitPod Array project and work through min_max_difference.rb sum a = [8, 3, 1, 19, 23, 3] p a.sum # =&gt; 57 Click here for a REPL to try it. Return to the GitPod Array project and work through sum_elements.rb join You can think of Array’s .join method as the inverse of String’s .split method: &quot;hello!&quot;.split(&quot;&quot;) # =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;!&quot;] [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;!&quot;].join # =&gt; &quot;hello!&quot; That is, the .split method is called on a String and returns an Array of substrings; while the .join method is called on an Array (where each element must be a String) and returns a single String. 1.7.3 Conclusion That’s it for Arrays. Now we’ll have a look at conditionals with if statements. "],["if-statements.html", "1.8 If statements", " 1.8 If statements Now that we can get input from our users, we can start to make our programs smart, by behaving differently based on different conditions. To do this, we need to add a new grammar to our toolbox: the if/end keywords. Here’s how it looks: lucky_number = rand(100) p &quot;Your lucky number is &quot; + lucky_number.to_s + &quot;.&quot; if lucky_number.odd? p &quot;The number is odd.&quot; end Click here for a REPL to try it. Try running this program a few times and see how it behaves. These expressions, which conditonally run some code based on the truth or falseness of some condition, are known as conditionals or if statements. 1.8.1 The basic anatomy of if statements The anatomy of an if statement is: if condition # code that runs if the condition is true end First comes the if keyword. After the if, on the same line, comes any Ruby expression, which is evaluated until only one piece of data is left. If that final return value of condition is “truthy”, then the code on the lines between the if and end keywords is executed. If the final return value of condition is “falsy”, then the code on the lines between the if and end keywords is ignored. Either way, the program picks up execution on the next line after the end keyword and continues on. Don’t forget the end Every if requires a matching end, and forgetting it is a very common mistake. My advice: type the end immediately after typing the if so that you don’t forget it; then worry about typing the condition, and the code that comes on the lines between the if and the end. (While you’re at it, indent the code on the lines between by two spaces so that it is visually clear what’s inside the if statement.) 1.8.2 Multibranch if statements We can also have multibranch if statements, where we specify fallback conditions to check and code to execute if the first condition is falsy: the_temp = rand(100) p the_temp if the_temp &gt; 75 p &quot;It&#39;s going to be a great day today&quot; else p &quot;Don&#39;t leave home today&quot; end Or you can have multiple conditions that get checked, one after the other: the_temp = rand(100) p the_temp if the_temp &gt; 75 p &quot;It&#39;s going to be a great day today&quot; elsif the_temp &gt; 32 p &quot;It&#39;ll be an okay day today&quot; else p &quot;Don&#39;t leave home today&quot; end Click here for a REPL to try it. Note that there is no space in the elsif keyword, and that there is no e in the middle of the elsif keyword. (In other languages, this construct is elseif, else if, etc; but in Ruby it’s just elsif.) The conditions are checked in top-down priority, so even if more than one is true, whichever one is first has its branch executed; the rest are ignored. If none are true, the final else fallback branch is executed; but you don’t have to have one if you don’t want one. Inside a branch of an if statement, you can have as many lines of code as you want — and you can even have whole other multi-branch if statements, if that’s what you need. Try to indent the code within each branch by two spaces, especially if you have multiple nested if statements within one another. 1.8.3 truthiness and falsiness Why did I say “truthy” and “falsy” instead of just true and false? Because many — most — Ruby expressions return values other than true or false. Any expression can appear next to an if, and some will cause the code inside the if statement to execute (these values are known as “truthy”) and some will not (these are “falsy”). In the REPL below, try replacing 1 == 1 with each of the following. Before clicking “run” for each one, ask yourself, do you expect to see the output \"The expression is truthy.\" or not? 0 \"false\" [] nil true \"\" false if 1 == 1 # Replace this with each expression. Which of them count as &quot;truthy&quot;? p &quot;The expression is truthy.&quot; else p &quot;The expression is falsy.&quot; end Click here for a REPL to try it. For how many of the above did you correctly predict the output? What did you learn about what objects count as truthy and what objects count as falsy in Ruby? It turns out that only false and nil are falsy. All other objects in Ruby are truthy — even 0, \"\", and []. 1.8.4 Comparisons That said, we’ll mostly use expressions after if that return true or false. There are lot of methods that are designed to do this; we’ve seen Integer’s .odd? and .even?, but there are a lot more. For example, most classes have ways to compare instances of the class to one another: 1 &lt; 2 # &quot;1 is less than 2&quot; 2 &lt; 1 # &quot;2 is less than 1&quot; 24*365 &gt; 10000 # There are more than 10,000 hours in a year 1 == 1 # &quot;1 is equivalent to 1&quot; 1 == 2 # &quot;1 is equivalent to 2&quot; 1 &lt;= 2 # &quot;1 is less than or equal to 2&quot; 1 &gt;= 2 # &quot;1 is greater than or equal to 2&quot; 1 != 1 # &quot;1 is NOT equivalent to 1&quot; 1 != 2 # &quot;1 is NOT equivalent to 2&quot; &quot;apple&quot; &lt; &quot;banana&quot; &quot;apple&quot; &gt; &quot;banana&quot; &quot;apple&quot; == &quot;banana&quot; &quot;apple&quot; != &quot;banana&quot; Equivalence vs assignment Note the difference between the equivalence operator — two equals signs, == — and the variable assignment operator — one equals sign, =. Mixing up the two of them is probably the most common typo programmers make: x = 2 if x = 3 p &quot;x is 3&quot; else p &quot;x is not 3&quot; end If you run the code above, what would be printed? Why? We accidentally used the assignment operator instead of the equivalence comparison, and in doing so, we set x = 3 when we meant to check if x == 3. You will  make this typo, we all do at some point — when your conditional always is going into the true branch inexplicably, let this ring a bell! 1.8.5 Combining conditions with AND and OR Finally, another handy thing to have in your toolbelt are the logical operators &amp;&amp; (AND) and || (OR). These allow you to combine expressions; try these combined expressions out below: 3.odd? &amp;&amp; 4.even? 3.odd? &amp;&amp; 4.odd? 3.even? &amp;&amp; 4.odd? 3.odd? || 4.even? 3.odd? || 4.odd? 3.even? || 4.odd? When used with if statements, this ability is very powerful: if 3.odd? &amp;&amp; 4.even? p &quot;The combined expression is truthy.&quot; end Click here for a REPL to try it. Basically, &amp;&amp; is stricter than ||; both comparisons have to be true in order for the whole statement to be true when combined with &amp;&amp;; either one being true is sufficient for ||. Open the GitPod if statements project for this chapter and start with the exercise rps.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/if-statements-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[conditionals_project] For a GitPod refresher, see here. Also, work through palindrome.rb 1.8.6 Conclusion That’s it for if statements. Now we’ll have a look at loops for iterating. "],["loops-chapter.html", "1.9 Loops", " 1.9 Loops 1.9.1 if: conditionally doing something once Consider the following program, which utilizes an if statement: numbers = Array.new if numbers.length &lt; 10 new_number = rand(100) numbers.push(new_number) end len = numbers.length p numbers p len What do you expect the output of this program to be? Try to interpret the program yourself before you ask Ruby to. Click here for a REPL to try it. Hopefully you clicked “▶ Run”. Did you guess right? We start off with a blank array, numbers. If its length is less than 10 (this is true, since length is currently 0), we push a new random number into it. Once Ruby reaches the if’s end, it proceeds to the next line and continues to execute the rest of the code (whether the if’s condition was true or not). At the end of the day, numbers has one element in it and len is 1. 1.9.2 while: conditionally doing something multiple times Now, consider almost identical code, but with the if keyword swapped for a new keyword — while: numbers = Array.new while numbers.length &lt; 10 new_number = rand(100) numbers.push(new_number) end len = numbers.length p numbers p len Click here for a REPL to try it. while works almost exactly like if — it evaluates the expression next to it, and if the expression is truthy, it executes the code on the lines between it and its end; if not, it ignores the code on the lines between it and its end. There is one key difference: if the condition next to a while is truthy, after we reach its end, the execution of the program jumps back up to the while statement. Then the condition is evaluated again. If it is still true, then the code inside the while statement is executed again. And then the execution of the program jumps back up to the while statement again. Etc. So in this case, The first time we reach the end, we jump back up to the while. Evaluate a.length &lt; 10 again — still true, since 1 &lt; 10. So we push in another random number, and jump back up. 2 &lt; 10? Yep, so we do it again. We push in another random number, and jump back up. 3 &lt; 10? Yep, so we do it again. 4 &lt; 10? Yep, so we do it again. Etc. 10 &lt; 10? Nope, so now proceed to the line after the end and continue. And len ends up being 10. What we’ve seen here is our very first loop; code that is executed multiple times. It could be an arbitrary number of times, perhaps even an infinite number of times if we aren’t careful. 1.9.3 Blocks Fundamentally, all looping is implemented with while; but, this being Ruby, there are all sorts of convenience methods on top to make it as easy as possible to create loops for various contexts. For example, let’s say I wanted to print: &quot;1 Mississippi&quot; &quot;2 Mississippi&quot; &quot;3 Mississippi&quot; # etc &quot;10 Mississippi&quot; exactly 10 times. I could do it using while like this; try interpreting the following code before you click “run”: mississipis = 1 while mississipis &lt;= 10 p mississipis.to_s + &quot; Mississippi&quot; mississipis = mississipis + 1 end Click here for a REPL to try it. Does the code make sense to you?20 If the line mississipis = mississipis + 1 looks a little odd to you, you’re not alone. Remember, this is variable assignment, not equivalence. So the expression on the right side (mississipis + 1) is evaluated first until there’s just one object (e.g 2) left; and then that object replaces the contents of the variable (mississipis) named on the left. Rinse and repeat. Or, rather than while, I could use Integer’s .times method, like this: mississipis = 1 10.times do p mississipis.to_s + &quot; Mississippi&quot; mississipis = mississipis + 1 end Click here for a REPL to try it. Notice there’s a new keyword here: do. This is because the .times method, in order to do its job of executing some code 10 times, needs a special argument — the code to execute. In order to pass a method some lines of code as an argument, we need to wrap the lines of code within the do and end keywords, creating what’s called a block of code. So, given a block of code, the 10.times method will execute it for us exactly 10 times; this saves us the trouble of writing a condition for while. Block variables But the .times method will save us even more trouble than that; we can stop worrying about creating and incrementing the counter variable, mississipis, too. The .times method will create a block variable and assign values to it for us automatically, but we have to choose a name for it using some new syntax after the do: the vertical bars, | |, or “pipes”. It looks like this: 10.times do |mississipis| p mississipis.to_s + &quot; Mississippi&quot; end Click here for a REPL to try it. Try running it. Here’s what’s going on: We created a block of code with do/end and gave it to .times. We chose a name for a block variable, mississipis, with the | | after the do. Behind the scenes, the .times method did mississipis = 0 before the first iteration. The .times method executed the block of code the first time. Behind the scenes, the .times method did mississipis = 1 before the second iteration. The .times method executed the block of code the second time. Etc. Why does .times start by assigning 0 to its block variable during the first iteration, rather than 1? Well, that’s just how the author of the .times method made it work. Remember, Ruby, like many other languages uses zero-indexing. Fortunately, Ruby provides lots of other looping convenience methods that we can take advantage of instead, and each one assigns different values to its block variable. In the REPL above, replace 10.times with each of the following and play around with the arguments to get a sense of how each method works: 5.upto(10) 99.downto(90) 1.step(10, 3) 10.step(1, -4) Open the GitPod loops project for this chapter and start with the exercise letter_count.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/loops-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[loops_project] For a GitPod refresher, see here. When you’re done with the first one, work through multiples.rb And finally, work through fizzbuzz.rb 1.9.4 Conclusion Now that we have an understanding of loops, we can have a look at the super important .each method for iterating over data structures. "],["each.html", "1.10 Each", " 1.10 Each When we met the Array class, we noted that most of what we do as developers is manage lists of things — photos, likes, followers, reviews, listings, messages, rides, events, concerts, projects, etc etc etc — and Array is the data structure that we’ll most commonly use to contain these lists. Therefore, the most common reason we’ll have to write loops is to visit each element in an Array and do something interesting with it — for example, display the element to the user with some formatting around it. 1.10.1 Iterating over arrays with Integer’s times method Try transforming the words in an Array using what you’ve learned so far about loops: Write a program that, given a list of words from the user, would take each word and print it in three forms: Capitalized Reversed Upcased For example, for the input: apple banana orange Your program should output the following: &quot;Apple&quot; &quot;elppa&quot; &quot;APPLE&quot; &quot;Banana&quot; &quot;ananab&quot; &quot;BANANA&quot; &quot;Orange&quot; &quot;egnaro&quot; &quot;ORANGE&quot; Click here for a REPL to try it. After you’ve got it working, examine the model solution here. You’ll see that I chose to use .times for this job. On Line 6, we count the length of the array. On Line 8, we use that length with the .times method to kick off a loop with the correct number of iterations. Within the block, we use the block variable (which we named the_index) to access the correct element within the array. BENP: need an exercise using indexing in a loop here, this method is important in Ruby Gym Using .times to iterate over an Array is not bad at all, especially because .times’s block variable starts at 0, just like array indexing does. Using .times is certainly cleaner than using while, where we would have to create and increment a counter variable ourselves, and then write a condition to make sure that the loop stops after the correct number of iterations (the length of the array). 1.10.2 Array’s each method But we can do even better than using Integer’s .times method to iterate over an Array. There’s a method that you can call directly on the Array itself called .each. Compare the code below to the model solution above and try to find the differences: p &quot;Enter at least 2 words, separated by spaces:&quot; user_words = gets.chomp.split p &quot;user_words:&quot; p user_words user_words.each do |the_word| p the_word.capitalize p the_word.reverse p the_word.upcase end Click here for a REPL to try it. Click “Run” and verify that both programs do the same thing. Nice! .each has two clear benefits over using .times: We don’t need to count the length of the array; .each does it for us and will take care of looping for the correct number of iterations. The block variable, rather than containing an integer that we can use to access the correct element, will contain the element itself. So now when we name the block variable, we should choose a name21 I like to name the variables that contain arrays plurally (e.g. photos), and block variables singularly (e.g. photo) to make it clear to myself which is which — the list itself versus one element within the list. Whatever you do, don’t name the block variable plurally — that’s very confusing when you come back to your code later and have to make sense of it. that reflects what each element in the list is. .each will, behind the scenes, pull the correct element out of the array before each iteration begins and assign it to that block variable. Then, we just use that variable directly, and we don’t have to worry about accessing the array with .at. The hardest part, I think, is getting your head around the block variable; in this case, |the_word|. It takes some practice. Try to remember that it’s just a name that we make up, and .each takes care of putting each element in that variable for us behind the scenes. I could have called it zebra if I wanted to; there’s nothing special about the name — in particular, it doesn’t have to match the name of the variable containing the array. Just try to pick something descriptive of an individual element in the list. Open the GitPod .each project for this chapter and start with the exercise spell_word.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/each-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[each_project] For a GitPod refresher, see here. When you’re done with the first one, work through even_word.rb And finally, work through letter_count.rb 1.10.3 Sneak peek Just a sneak peek as to why .each is so important to get comfortable with: soon, you’ll be embedding Ruby loops in your web applications to create dynamic, data-driven pages with code that looks something like this: &lt;% newsfeed_photos.each do |the_photo| %&gt; &lt;div class=&quot;card&quot;&gt; &lt;img src=&quot;&lt;%= the_photo.image_source %&gt;&quot;&gt; &lt;p&gt; &lt;%= the_photo.caption %&gt; &lt;/p&gt; &lt;/div&gt; &lt;% end %&gt; Code like this is what drives the dozens of dynamic applications you interact with on a daily basis — we pull a list of records from a database table, then we loop over them, and then we format each one using some markup language (in this case HTML for the browser, but it could be XML for native apps, etc). 1.10.4 Conclusion That’s it for .each and loops. It’s time to meet a very important data structure class that we will be seeing a lot: Hash. Addendum: each_with_index There are some rare cases when you are looping over an array and, within the block, you would like access to the element and its index. For example, maybe you want to print a line after every other element. You could fall back to .times in these scenarios, but there’s also another Array method that has your back: .each_with_index. It looks like this: p &quot;Enter at least 2 words, separated by spaces:&quot; user_words = gets.chomp.split p &quot;user_words:&quot; p user_words user_words.each_with_index do |the_word, the_index| p the_word.capitalize p the_word.reverse p the_word.upcase if the_index.odd? p &quot;=&quot; * 20 end end Click here for a REPL to try it. As you can see, some methods provide more than one block variable. .each_with_index allows you to name two variables within the pipes; the first one will receive the element, and the second one will receive the index of the iteration. Within the block you can use both variables as you see fit. In rare cases, handy. "],["hash-chapter.html", "1.11 Hash", " 1.11 Hash Array is a very good structure for containing multiple objects, but it’s not the only one. In some situations, another structure is a better tool for the job: Hash. Suppose we have instructors and students: instructors = [&quot;Raghu&quot;, &quot;Logan&quot;, &quot;Jelani&quot;] students = [&quot;Jocelyn&quot;, &quot;Arthur&quot;, &quot;Tom&quot;, &quot;Lindsey&quot;] Suppose we want add last names and roles? person1 = [&quot;Raghu&quot;, &quot;Betina&quot;, &quot;Instructor&quot;] person2 = [&quot;Jocelyn&quot;, &quot;Williams&quot;, &quot;Student&quot;] # etc p person1.at(0) + &quot; is an &quot; + person1.at(2) p person2.at(0) + &quot; is a &quot; + person2.at(2) This may suffice if the list of attributes is small, but six months later when you come back to this code, do you really want to remember which index number was last name and which was first name and which was role? Not to mention always dealing with the array-indexes-begin-with-0-and-not-1 thing in your head. There’s a better way: rather than having Arrays automatically number each piece of data, we can give them meaningful labels in a Hash. 1.11.1 A brief interlude: Symbols There is one datatype that we haven’t discussed until now that will come in handy: Symbols. Symbols are like Strings: a sequence of characters. However, Symbols follow the same rules as variable names: Cannot contain spaces. Can only contain lowercase letters, underscores, and numbers. Cannot begin with a number. Otherwise, they are just like strings, and we can use them to hold text data: &quot;hello&quot; # I am a String :hello # I am a Symbol Symbols are created by starting them off with a colon. You don’t need a closing colon, since they cannot contain spaces; Ruby can figure out where they end. Strings are usually used to contain copy for the user or input from the user; whereas Symbols are mostly used when we, the developers, need to label something internally in our code. That’s why they can’t contain spaces, etc; we’re not going to use them to hold user input. Accordingly, Symbols don’t have as many methods for transforming their contents, like .reverse. So, that’s that. Symbols are lightweight strings that we, the developers, use when we need to label things. Let’s continue. 1.11.2 Creating hashes and storing values Back to the problem of storing a list of attributes about a person effectively, without mixing them up. Hashes are like Arrays, except each cell isn’t automatically numbered — we get to label each cell ourselves. So instead of representing a person with an Array like [\"Raghu\", \"Betina\", \"Instructor\"], we instead can use a Hash like this: person1 = Hash.new p person1 person1.store(:first_name, &quot;Raghu&quot;) p person1 person1.store(:last_name, &quot;Betina&quot;) p person1 person1.store(:role, &quot;Instructor&quot;) p person1 p person1.fetch(:role) Click here for a REPL to try it. Click “Run” and see what it looks like to build up a Hash. A few things to note: Ruby represents a Hash with curly brackets, {}, as opposed to the square brackets ([]) of an Array. We use the .store method to add elements to a Hash, as opposed to the .push method of Array. The .store method takes two arguments, not one: the first argument is the label, or key to store the element under; and the second argument is the piece of data itself, or the value. Ruby represents each key/value pair by separating them with a =&gt;, known as a “hash rocket”22 Rubyists are weird.. As in Arrays, elements in the list (each element is one key/value pair) are separated by commas. If the key already exists when you try to .store something under it, its value will be replaced. 1.11.3 fetch To retrieve a piece of data from a Hash, we use the .fetch method (as opposed to Array’s .at): person1 = Hash.new person1.store(:first_name, &quot;Raghu&quot;) person1.store(:last_name, &quot;Betina&quot;) person1.store(:role, &quot;Instructor&quot;) p person1.fetch(:last_name) Click here for a REPL to try it. Beautiful! Now we don’t have to remember that position number 1 is last name, position number 2 is role, etc. We can retrieve objects from the list using meaningful labels instead. Let’s put it all together with multiple Hashes: person1 = Hash.new person1.store(:first_name, &quot;Raghu&quot;) person1.store(:last_name, &quot;Betina&quot;) person1.store(:role, &quot;Instructor&quot;) person2 = Hash.new person2.store(:first_name, &quot;Jocelyn&quot;) person2.store(:last_name, &quot;Williams&quot;) person2.store(:role, &quot;Student&quot;) p person1.fetch(:first_name) + &quot; is a &quot; + person1.fetch(:role) p person2.fetch(:first_name) + &quot; is a &quot; + person2.fetch(:role) Click here for a REPL to try it. A few things to try: What happens when you try to .fetch using a String like \"role\"? What happens when you try to .fetch using a key that doesn’t exist, like :middle_name? Get used to those error messages. You’re going to see them a lot. fetch fallback Sometimes you may want to call .fetch using a key that may not be present in the Hash, and you don’t want the program to crash with the “key not found” error message. In that case, you can provide a second argument which will be used as a fallback return value: person1 = Hash.new person1.store(:first_name, &quot;Raghu&quot;) person1.store(:last_name, &quot;Betina&quot;) person1.store(:role, &quot;Instructor&quot;) p person1.fetch(:first_name, &quot;None provided&quot;) p person1.fetch(:middle_name, &quot;None provided&quot;) Click here for a REPL to try it. 1.11.4 Hash literals Like String and Array, there’s a shortcut to creating Hashes: rather than formally instantiating a new Hash with Hash.new and then building it up from scratch one key/value pair at a time with .store, you can type out the hash literal directly into your code: person1 = { :first_name =&gt; &quot;Raghu&quot;, :last_name =&gt; &quot;Betina&quot;, :role =&gt; &quot;Instructor&quot; } person2 = { :first_name =&gt; &quot;Jocelyn&quot;, :last_name =&gt; &quot;Williams&quot;, :role =&gt; &quot;Student&quot; } Like with String and Array, this is the style that we’re going to use the vast majority of the time. In particular, Hashes are very often used as the arguments to methods, because they let us pass in a list of inputs with nice labels. When we get to Ruby on Rails, especially, we will very often type hash literals directly into the parentheses of method arguments, things like: Movie.where({ :title =&gt; &quot;The Shawshank Redemption&quot; }) Open the GitPod Hash project for this chapter and start with the exercise person.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/hash-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[hash_project] For a GitPod refresher, see here. 1.11.5 fetch shorthand, [] Much like Array’s shorthand for .at, Hash also a shorthand for retrieving elements with .fetch: .[] (and the associated syntactic sugar). So we could write: person1 = { :first_name =&gt; &quot;Raghu&quot;, :last_name =&gt; &quot;Betina&quot;, :role =&gt; &quot;Instructor&quot; } p person1[:last_name] However, unlike with Array, Hash’s .[] method and .fetch method do not do the exact same thing. Experiment with them and see if you can find the difference: person1 = { :first_name =&gt; &quot;Raghu&quot;, :last_name =&gt; &quot;Betina&quot;, :role =&gt; &quot;Instructor&quot; } p person1.fetch(:last_name) p person1[:last_name] Click here for a REPL to try it. Were you able to find the difference between the two methods? Hash’s .[] method, when used with a key that is not present in the hash, returns nil rather than throwing an error. I personally prefer getting the descriptive error message if the key is not present in the hash, because it means that I probably made a typo or some other mistake, and I prefer being alerted to that fact rather than the program proceeding quietly only to fail elsewhere. In the rare case that it should be possible for a key to be optionally present in a hash, then I can use a fallback second argument to .fetch, as described above. That said, out on the internet, using .[] is the most prevalent style of accessing hashes, so you should be familiar with it. But in this text, I will stick with .fetch. 1.11.6 store shorthand, []= Similar to the shorthand for .fetch above, there’s a shorthand for .store: []= person1 = Hash.new person1[:first_name] = &quot;Raghu&quot; person1[:last_name] = &quot;Betina&quot; person1[:role] = &quot;Instructor&quot; p person1 # =&gt; { :first_name =&gt; &quot;Raghu&quot;, :last_name =&gt; &quot;Betina&quot;, :role =&gt; &quot;Instructor&quot; } This syntactic sugar makes it feel like we’re doing variable assignments to keys within the Hash, but under the hood it’s identical to .store(:key, :value). 1.11.7 Use .keys to explore A very important method to use when you’re dealing with Hashes that you didn’t create yourself is .keys: h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 } h.keys #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] h.fetch(&quot;b&quot;) # =&gt; 200 The .keys method returns an Array showing all of the keys that are present in the Hash, so that we know what we can .fetch. This helps tremendously when dealing with a data structure that we didn’t create ourselves, especially when it’s deeply nested (a hash containing arrays which might contain other hashes, etc). 1.11.8 keys can be anything The keys in a Hash can be any class — String, Integer, whatever — but we almost always use Symbols as keys to our Hashes. (I like using symbols as the keys simply because since the values are usually strings, syntax highlighting makes keys stand out from values in our code.) 1.11.9 values can be anything Similarly, the value stored under a key can be an object of any class. This means that you can have a Hash that contains an entirely separate Hash or Array object. Take this example: dictionary = { :colors =&gt; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;], :person =&gt; { :name =&gt; &quot;Jenna Parker&quot;, :age =&gt; 32 } } In order to retrieve the value \"green\" from this Hash, we first need to access the Array under the key :colors. colors_array = dictionary.fetch(:colors) # =&gt; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;] Now we can access the value at the second position with .at: colors_array.at(1) # =&gt; &quot;green&quot; Similarly, to retrieve 32 from the Hash, we first need to access the inner Hash under the key :person. person_hash = dictionary.fetch(:person) # =&gt; { :name =&gt; &quot;Jenna Parker&quot;, :age =&gt; 32 } Once the inner Hash has been retrieved, we can access the value stored under :age using fetch: person_hash.fetch(:age) # =&gt; 32 Return to the GitPod Hash project and work through dig.rb 1.11.10 key The .key method is sort of the inverse of .fetch: given an object, .key searches through each value in the hash and returns the key where it resides or nil if it doesn’t exist in the hash. h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 } h.key(100) #=&gt; &quot;a&quot; h.key(200) #=&gt; &quot;b&quot; h.key(300) #=&gt; &quot;c&quot; h.key(400) #=&gt; &quot;d&quot; h.key(500) #=&gt; nil Return to the GitPod Hash project and work through find_value.rb Finally, in the GitPod Hash project complete list.rb 1.11.11 Conclusion Arrays are very useful for storing a list of things that are all basically the same, and for lists that are of unknown length, and so it’s nice for Ruby to automatically number them for you. But when you are storing a list of things that are categorically different from one another and you’d rather label them yourself, then Hashes are a better choice. That’s about it! The last intro topic to cover in the next section is creating our own classes in Ruby. "],["our-own-classes.html", "1.12 Our own classes", " 1.12 Our own classes 1.12.1 Modeling real world things We can model a person pretty well with an Array: a = Array.new # This is the longhand for a = [] a.push(&quot;Raghu&quot;) a.push(&quot;Betina&quot;) a.push(&quot;Instructor&quot;) a # =&gt; [&quot;Raghu&quot;, &quot;Betina&quot;, &quot;Instructor&quot;] a.at(1) # =&gt; &quot;Betina&quot; a.class # =&gt; Array And we can model a person even better with a Hash: h = Hash.new # This is the longhand for h = {} h.store(:first_name, &quot;Raghu&quot;) h.store(:last_name, &quot;Betina&quot;) h.store(:role, &quot;Instructor&quot;) h # =&gt; { :first_name =&gt; &quot;Raghu&quot;, :last_name =&gt; &quot;Betina&quot;, :role =&gt; &quot;Instructor&quot; } h.fetch(:last_name) # =&gt; &quot;Betina&quot; h.class # =&gt; Hash But we can do even better than a Hash. We can define our own class to represent people with the class keyword: class Person end Remember, the only time we use capital letters in Ruby is when we’re referring to classes — and this goes for when we’re naming our own classes, too. So class person will not work. If you have a multi-word name, then CamelCase it — class VeryImportantPerson. And we can declare what attributes a person can have with the attr_accessor keyword: class Person attr_accessor :first_name attr_accessor :last_name attr_accessor :role end And now the Person class is a first-class citizen in the language, just like Array and Hash. Compare the code below to the code above for creating Arrays and Hashes to store information: class Person attr_accessor :first_name attr_accessor :last_name attr_accessor :role end c = Person.new c.first_name = &quot;Raghu&quot; c.last_name = &quot;Betina&quot; c.role = &quot;Instructor&quot; p c.last_name # =&gt; &quot;Betina&quot; p c.role p c.class # =&gt; Person Click here for a REPL to try it. For each attribute that we declared, we get methods that we can call to assign and retrieve values. Defining instance methods There are a few reasons I like using classes more than Hashes to model things, but here is the big one: in addition to just storing a list of attributes about a thing, we can also define our own methods with the def keyword. For example, try adding the following full_name method to the class we defined in the REPL above: class Person attr_accessor :first_name attr_accessor :last_name def full_name return self.first_name + &quot; &quot; + self.last_name end end Now, in addition to being able to store data (first and last names), I can ask any Person to compute its full name: hs = Person.new hs.first_name = &quot;Homer&quot; hs.last_name = &quot;Simpson&quot; &quot;Hello, &quot; + hs.full_name + &quot;!&quot; # =&gt; &quot;Hello, Homer Simpson!&quot; Two new keywords to note: I used the return keyword to signify what value I wanted to replace hs.full_name in the original expression after it’s been evaluated. I used the self keyword to refer to the object who was asked to calculate its full name, since I can’t know in advance what (if any) variable name will be used. Here’s a slightly more involved example: class Person require(&quot;date&quot;) # We need to pull in the Date class, which is not loaded by default attr_accessor :birthdate def age dob = Date.parse(self.birthdate) now = Date.today age_in_days = now - dob age_in_years = age_in_days / 365 return age_in_years.to_i end end Now every Person that we create will have the ability to compute their age based on their own dob attribute: hs = Person.new hs.birthdate = &quot;April 19, 1987&quot; hs.age # =&gt; 32, as of this writing Note that we had to require(\"date\")23 The parentheses are almost always dropped after require. in order to load the Date class into the program; Ruby doesn’t load this class into every program by default, like it does with the core classes (String, Integer, etc). So, rather than using a Hash to model real world things, it’s a good idea to create classes, and then empower them with behavior (methods) in addition to information. Defining class methods The methods full_name and age above are known as instance methods, because we call them on individual instances of the Person class (Homer, Mickey, Minnie, etc). We can also define class-level methods, that we call directly on Person itself. This can be handy if we want to define re-usable utility methods that don’t really belong to any one individual person. Here’s an example similar to Date.parse — what if we wanted users of the Person class to quickly be able to create new instances of the class like this: Person.parse(&quot;Betina, Raghu&quot;) # =&gt; should return a new person with first # and last name attributes already populated Then, we can define the class-level method parse, called directly on Person, like this: class Person attr_accessor :first_name attr_accessor :last_name def Person.parse(last_comma_first) last_first_array = last_comma_first.split(&quot;,&quot;) the_last_name = last_first_array.at(0).strip the_first_name = last_first_array.at(1).strip a_new_person = Person.new a_new_person.first_name = the_first_name a_new_person.last_name = the_last_name return a_new_person end end The new things to note in the code above: When defining the method, we do def Person.parse rather than just def parse to make it a class method rather than an instance method. That way, we call the method directly on capital-P Person. We give the method the ability to accept an argument by adding parentheses and choosing a name for the argument when defining the method. Then we can use the input within the method definition, sort of like how we use a block variable. 1.12.2 Inheritance When you define new classes, you can choose to inherit all the power of a “parent” class, and then add some custom behavior: class Instructor &lt; Person attr_accessor :role end class Student &lt; Person attr_accessor :grade end Instructors and Students can do everything people can, and a little bit more. Creating the first individual instance of the Instructor class: person1 = Instructor.new person1.first_name = &quot;Raghu&quot; person1.last_name = &quot;Betina&quot; person1.role = &quot;Lecturer&quot; Creating the second individual instance of the Instructor class: person2 = Instructor.new person2.first_name = &quot;Arjun&quot; person2.last_name = &quot;Venkataswamy&quot; person2.role = &quot;Faculty Coach&quot; Creating the first individual instance of the Student class: person3 = Student.new person3.first_name = &quot;Trenton&quot; person3.last_name = &quot;Arthur&quot; person3.grade = &quot;A&quot; Creating the second individual instance of the Student class: person4 = Student.new person4.first_name = &quot;Tom&quot; person4.last_name = &quot;Besio&quot; person4.grade = &quot;Incomplete&quot; Now we can use them: person1.full_name # =&gt; &quot;Raghu Betina&quot; person1.role # =&gt; &quot;Lecturer&quot; person2.full_name # =&gt; &quot;Arjun Venkataswamy&quot; person2.role # =&gt; &quot;Faculty Coach&quot; person3.full_name # =&gt; &quot;Trenton Arthur&quot; person3.grade # =&gt; &quot;A&quot; person4.full_name # =&gt; &quot;Tom Besio&quot; person4.grade # =&gt; &quot;Incomplete&quot; What would happen if I tried doing person4.role? How about person1.grade? Why? What would the error message be? Try defining all of the above and give it a shot in a REPL: class Person end class Instructor end class Student end Click here for a REPL to try it. Open the GitPod “our own classes” project for this chapter and start with the exercise person.rb: LTI{Load assignment}(https://github.com/bpurinton-appdev/our-own-classes-chapter/tree/bp-additions)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[our_own_classes_project] For a GitPod refresher, see here. "],["ruby-conclusions.html", "1.13 Ruby Conclusions", " 1.13 Ruby Conclusions That’s it for our crash course! Congratulations, you’re ready to begin using Ruby in your web applications to develop the backend code. 1.13.1 Our Technical Reference vs. Google-Fu Much of what we covered in the previous sections is collected in the Ruby technical reference. This is intended to be a quick reference of the classes and methods, and includes many things yet to come in the course. Nevertheless, it’s very handy to keep open. At this point we have all the building blocks: Expressions: object.method(argument) # =&gt; returns a value Variables to save the results of expressions. Conditionals (If statements). Loops. That’s all we need. We can build anything with these, using just some careful thought and the technical reference. We are inventors When you signed up to learn how to program, you signed up to become an inventor. Software developers, by definitions, tackle unsolved problems. There aren’t predefined solutions to look up and apply. Otherwise, we’d just buy something off the shelf and be software users. (Much cheaper, if a solution to your problem already exists.) When faced with a task, your first instinct should be: “How can I solve this puzzle with the tools I have?” Your first instinct shouldn’t be: “Let me Google for a solution to this problem.” Developers do a lot of that, of course, but only after we’ve tried to solve it with what we already have. “Google-Fu” is a hugely important skill to practice in software development, but in this course you should resist Googling. The answers you find are not suitable for beginners; they will more than likely slow you down. Any assigned task will be achievable using the classes, methods, and keywords introduced in the Ruby Chapters. Your job is to invent a combination of them that gets the job done. 1.13.2 Ruby Gym Before we go on, let’s stop, take a breath, and try to put what we’ve learned so far to good use. The idea with the following exercises is to use the building blocks from the previous sections to write some small programs. These are longer projects than the exercises we’ve seen so far, and they may require a few different tools to complete; so keep the chapter sections open for reference and scan through them for things that may help when you get stuck. All the tools are there. There are likely a few ways to solve an exercise. Just get the code to pass all of the rails grade tests and you are good to move on. Remember, we are inventors; don’t rely on Google-Fu. Please follow the instructions below to enter the Ruby Gym for some weight training ️! Open the GitPod Ruby Gym project and complete the exercises: LTI{Load assignment}(https://github.com/bpurinton-appdev/ruby-gym/tree/bp-edits)[MV4dKHMwdAFhfRn752YW3TAY]{KBpPhe42o6wDRi35rWagKY4F}(20)[ruby_gym_project] For a GitPod refresher, see here. The suggested order (feel free to go in whatever order you’d like) is: think_fast.rb two_fer.rb dice_roll.rb character_types.rb accumulate.rb secret_encoder.rb secret_decoder.rb leap_year.rb raindrops.rb count_the.rb sum_odd_integers.rb black_jack.rb Optional stretch goal If you finished the previous exercises, and you want some more, feel free to also work on these optional exercises found in the Ruby Gym: anagram.rb isogram.rb hamming.rb darts.rb phrase.rb Addendum: Optional Ruby Practice If this is your first time programming, then it’s a lot of new concepts to absorb! Sometimes hearing the same concepts in different words helps. Here are some other optional resources you can go through at your leisure if you’d like more Ruby practice: Treehouse’s Ruby Basics Other than the introduction to Ruby that I’ve written specifically for our purposes, Treehouse’s is the one I like best. If you would like even more practice before we get to our own introduction to Ruby, then there’s also: CodeCademy’s Learn Ruby track, up to and including Part 4 (Arrays and Hashes). (After Part 4, they touch on quite a few concepts that we won’t use much during AppDev, but are useful in the long run if you continue with Ruby.) Both Treehouse and CodeCademy have an in-browser programming environment, so it’s easy to just start learning right away (no installing of things on your laptop required). However, be warned that both Treehouse and CodeCademy mention some language features of Ruby that I deliberately cut out in order to keep our learning load as slim as possible. It’s not necessarily bad to see them, but we won’t be using them in class. "],["terminology-technical-reference.html", "A Terminology Technical Reference", " A Terminology Technical Reference "],["the-one-ruby-reference.html", "B The One Ruby Reference", " B The One Ruby Reference This glossary should be used as a quick reference for Ruby; for more depth, click through to the “Full Explanation”s. How to interpret this reference This reference is (with a few exceptions) organized by Ruby Class, e.g. String, Array, Hash, etc. Click the firstdraft icon in the top-left corner of the page to slide out the table of contents, scan it, and find a section that interests you. Usually, each section describes a Ruby method. For example, here’s what the section String#split looks like: String#split =&gt; Array is called the method signature: String since the method is defined for that class. # since it is an instance method (as opposed to a class method, in which case the notation would be .). =&gt; Array since the return value of this method is an instance of the class Array. Then a description of the method. Then examples. Then, usually, a link to the longer explanation from the original chapter where the method was first introduced. Please let us know if you find errors, omissions, or have any other suggestions or comments. Thank you! "],["activerecord_relation-array-of-records.html", "B.1 ActiveRecord_Relation (array of records)", " B.1 ActiveRecord_Relation (array of records) B.1.1 All Array methods ActiveRecord_Relations inherit from Array, so all Array methods work: .each .at() (and its aliases [], .first for .at(0), .last for .at(-1)) .count .reverse .sample .shuffle B.1.2 .where ActiveRecord_Relation#where(Hash) ⇒ ActiveRecord_Relation Call .where on an ActiveRecord_Relation to filter the array of records based on some criteria. where returns an ActiveRecord_Relation based on the given Hash. .where returns an ActiveRecord_Relation regardless of how many results there are. In particular, even if there is only one result, the return value will still be another ActiveRecord_Relation. The argument to .where is usually a Hash: Filtering by an exact match within a column: { :id =&gt; 42 } Filter by multiple columns at once: { :photo_id =&gt; 23, :user_id =&gt; 42 } Filter using an Array (results will match any of the values in the Array): { :owner_id =&gt; [4, 8, 15 ] } Filtering within a range of values: { :dob =&gt; (1.year.ago..Date.today) } { :last_name =&gt; (&quot;A&quot;..&quot;C&quot;) } If you really want to, you can omit the curly brackets around the Hash for brevity, and Ruby will figure out what you mean. So, ultimately, you can write something like this: Contact.where(:last_name =&gt; (&quot;A&quot;..&quot;C&quot;)) instead of this: Contact.where({ :last_name =&gt; (&quot;A&quot;..&quot;C&quot;) }) Related Methods: .where.not, .or, .limit, .order Full explanation B.1.3 where.not ActiveRecord_Relation#where.not(Hash) ⇒ ActiveRecord_Relation Call .where.not on an ActiveRecord_Relation to filter the array of records to exclude records based on the given Hash. .where.not will return an ActiveRecord_Relation. Contact.where({ :last_name =&gt; &quot;Mouse&quot; }).where.not({ :first_name =&gt; &quot;Mickey&quot; }) Returns an ActiveRecord_Relation. The acceptable arguments to .not are the same as to .where; see that method for a list. Related methods: .where, .order, .limit Full explanation B.1.4 .or ActiveRecord_Relation#or(ActiveRecord_Relation) ⇒ ActiveRecord_Relation Call .or on an ActiveRecord_Relation to combine the array of records with another array of records: Returns an ActiveRecord_Relation. The argument to .or must be another ActiveRecord_Relation from the same table. Broadens the result set. Contact.where({ :first_name =&gt; &quot;Mickey&quot; }).or(Contact.where({ :last_name =&gt; &quot;Betina&quot; })) Full explanation B.1.5 .order ActiveRecord_Relation#order(Hash) ⇒ ActiveRecord_Relation or ActiveRecord_Relation.order(Symbol) ⇒ ActiveRecord_Relation Call .order on an ActiveRecord_Relation to sort the array based on one or more columns. This method returns an ActiveRecord_Relation. Contact.all.order({ :last_name =&gt; :asc, :first_name =&gt; :asc, :date_of_birth =&gt; :desc }) Returns an ActiveRecord_Relation. The argument to .order is usually a Hash. The keys in the Hash must be Symbols that match names of columns in the table. These are the columns that will be used for sorting. If there are multiple keys, the order in which they are provided will be used to break ties. The value associated to each key must be either :asc (for ascending order) or :desc (for descending order). The argument to .order can also just be one Symbol, a column name. Contact.all.order(:last_name) In that case, :asc order is assumed. Full explanation B.1.6 .limit ActiveRecord_Relation#limit(Integer) ⇒ ActiveRecord_Relation Call .limit on an ActiveRecord_Relation to cap the number of records in the array. Returns an ActiveRecord_Relation. The argument to .limit must be an Integer. Contact.where({ :last_name =&gt; &quot;Mouse&quot; }).limit(10) Full explanation B.1.7 .offset ActiveRecord_Relation#offset(Integer) ⇒ ActiveRecord_Relation Call .offset on an ActiveRecord_Relation to discard the first few records in the array: Returns an ActiveRecord_Relation. The argument to .offset must be an Integer. Contact.where({ :last_name =&gt; &quot;Mouse&quot; }).offset(10).limit(10) Full explanation B.1.8 .map_relation_to_array ActiveRecord_Relation#map_relation_to_array(Symbol) ⇒ Array Call .map_relation_to_array on an ActiveRecord_Relation to retrieve the values stored in just one column of the records, and discard all other data. .map_relation_to_array returns a regular Ruby Array of scalar values in the column. Not a single value, even if there was only one record in the ActiveRecord_Relation. Not an ActiveRecord_Relation, so you can no longer use methods like .where, .order, etc. You can use Array methods like .sort, .sample, etc. The argument to .map_relation_to_array must be a Symbol that matches the name of a column in the table. You cannot call .map_relation_to_array on an individual ActiveRecord row. If you want the value in a column for an individual row, simply call the accessor method directly: Contact.all.map_relation_to_array(:last_name) # =&gt; [&quot;Betina&quot;, &quot;Mouse&quot;, &quot;Woods&quot;] # for an array of records people.last_name # undefined method for array; bad people.map_relation_to_array(:last_name) # =&gt; [&quot;Betina&quot;, &quot;Woods&quot;]; good Full explanation B.1.9 .maximum ActiveRecord_Relation#maximum(Symbol) ⇒ Object Call .maximum on an ActiveRecord_Relation to grab and return the biggest value of a particular column. User.all.maximun(:age) # =&gt; 102 Returns a value from an ActiveRecord column. Full explanation B.1.10 .minimum ActiveRecord_Relation#minimum(Symbol) ⇒ Object Call .minimum on an ActiveRecord_Relation to grab and return the smallest value of a particular column. Photo.all.minimum(:caption) # =&gt; &quot;... a mind needs books as a sword needs a whetstone, if it is to keep its edge.&quot; Returns a value from an ActiveRecord column. Full explanation B.1.11 .sum ActiveRecord_Relation#sum(Symbol) ⇒ Integer or ⇒ Float or ⇒ String Call .sum on an ActiveRecord_Relation to find the sum of the values in a single column: @poem.scores.sum(:points) Returns an Integer or Float (or even a String), depending on datatype of the column that was summed. The argument to .sum must be a Symbol that matches the name of a column in the table. Full explanation B.1.12 .average ActiveRecord_Relation#average(Symbol) ⇒ Integer or ⇒ Float Call .average on an ActiveRecord_Relation to find the mean of the values in a single column: @restaurant.reviews.average(:rating) Returns an Integer or Float, depending on datatype of the column that was averaged. The argument to .average must be a Symbol that matches the name of a column in the table. Full explanation "],["activerecord-a-single-record.html", "B.2 ActiveRecord (A single record)", " B.2 ActiveRecord (A single record) B.2.1 All column names You get a method for every column in the table; for example, if you have retrieved an individual record from the Contact table, you can call .first_name, .last_name, etc, on it. This means that every ActiveRecord object will have methods .id, .created_at, and .updated_at, since every table has those columns. Full explanation B.2.2 Any other instance methods you define in the class It’s often helpful to define your own instance methods in the model file; for example, you might want to define a method .full_name: class Contact &lt; ApplicationRecord def full_name return self.first_name + &quot; &quot; + self.last_name end end You would then be able to call .full_name anywhere in the application that you wind up with an individual Contact object. Full explanation "],["association-helper-methods.html", "B.3 Association Helper Methods", " B.3 Association Helper Methods B.3.1 belongs_to belongs_to(Symbol, Hash) ⇒ ActiveRecord Let’s say I have a movie in a variable m. It is annoying and error prone to, whenever I want the director associated with a movie, have to type d = Director.where({ :id =&gt; m.director_id }).at(0) Wouldn’t it be great if I could just type d = m.director and it would know how to go look up the corresponding row in the directors table based on the movie’s director_id? Unfortunately, I can’t, because .director isn’t a method that Movie objects automatically know how to perform — the method would be undefined. (Movie objects know how to perform .director_id because we get a method for every column in the table.) We could define such an instance method in the model ourselves without too much trouble. But, fortunately, since domain modeling and associations are at the heart of every application’s power, Rails gives us a shortcut. Go into the Movie model and add a line like this: belongs_to(:director, { :class_name =&gt; &quot;Director&quot;, :foreign_key =&gt; &quot;director_id&quot; }) This line tells Rails: belongs_to: We only one result (not an array of results). :director: Define a method called .director for all movie objects. :class_name =&gt; \"Director\": When someone invokes .director on a movie, go fetch a result from the directors table. :foreign_key =&gt; \"director_id\": Use the value in the director_id column of the movie to query the directors table for a row. This is exactly what we would do if we defined the instance method by hand: def director return Director.where({ :id =&gt; m.director_id }).at(0) end Either way, we now can utilize this handy shortcut anywhere in our application when we have a movie m and we want to get the record in the directors table associated with it: m.director Even better, if you’ve named your method and foreign key column conventionally (exactly matching the name of the other table), you can use the super-shorthand version: belongs_to(:director) If you omit specifying the :class_name, Rails assumes that the table that you want to query is named the same thing as the method you are defining. If you omit specifying the :foreign_key, Rails assumes that the foreign key column is named the same thing as the method plus _id. If either of those things happens to not be true, then just include the Hash as the second argument to belongs_to and spell it all out: belongs_to(:owner, { :class_name =&gt; &quot;User&quot;, :foreign_key =&gt; &quot;poster_id&quot; }) This would give us a method called .owner that returns a User, even though the foreign key column is called poster_id. We still have complete control, if we need to depart from conventional method/foreign key names for some reason. B.3.2 has_many has_many(Symbol, Hash) ⇒ ActiveRecord_Relation Let’s say I have a director in a variable d. It is annoying and error prone to, whenever I want the films associated with the director, have to type f = Movie.where({ :director_id =&gt; d.id }) Wouldn’t it be great if I could just type f = d.movies and it would know how to go look up the corresponding rows in the movies table based on the director’s id? Unfortunately, I can’t, because .movies isn’t a method that Director objects automatically know how to perform — the method would be undefined. We could define such an instance method in the model ourselves without too much trouble. But, fortunately, since domain modeling and associations are at the heart of every application’s power, Rails gives us a shortcut. Go into the Director model and add a line like this: has_many(:movies, { :class_name =&gt; &quot;Movie&quot;, :foreign_key =&gt; &quot;director_id&quot; }) This line tells Rails: has_many: We want many results in an array. :movies: Define a method called .movies for all director objects. :class_name =&gt; \"Movie\": When someone invokes .movies on a director, go fetch results from the movies table. :foreign_key =&gt; \"director_id\": Use the director_id column of the movies table to filter using the id of the director. This is exactly what we would do if we defined the instance method by hand: def movies return Movie.where({ :director_id =&gt; self.id }) end Either way, we now can utilize this handy shortcut anywhere in our application when we have a director d and we want to get the records in the movies table associated with it: d.movies Even better, if you’ve named your method and foreign key column conventionally (exactly matching the name of the other table), you can use the super-shorthand version: has_many(:movies) If you omit specifying the :class_name, Rails assumes that the table that you want to query is named the same thing as the method you are defining. If you omit specifying the :foreign_key, Rails assumes that the foreign key column is named the same thing as this model plus _id. If either of those things happens to not be true, then just include the Hash as the second argument to belongs_to and spell it all out: has_many(:filmography, { :class_name =&gt; &quot;Movie&quot;, :foreign_key =&gt; &quot;director_id&quot; }) This would give us a method called .filmography that returns Movies. We still have complete control, if we need to depart from conventional method/foreign key names for some reason. B.3.3 has_many/through has_many(Symbol, Hash) ⇒ ActiveRecord_Relation After you have established all of your one-to-many association helper methods, you can also add many-to-many helper methods with the :through option on has_many: class Movie &lt; ApplicationRecord has_many(:characters) has_many(:actors, { :through =&gt; :characters, :source =&gt; :actor }) end class Character &lt; ApplicationRecord belongs_to(:movie) belongs_to(:actor) end class Actor &lt; ApplicationRecord has_many(:characters) has_many(:movies, { :through =&gt; :characters, :source =&gt; :movie }) end "],["string-1.html", "B.4 String", " B.4 String B.4.1 .concat (.+) String#concat(Integer) ⇒ String or String#concat(String) ⇒ String Appends the given arguments to a string. when given an integer as an argument, it converts the integer into ASCII code. &quot;hi&quot;.concat(33) # =&gt; &quot;hi!&quot; &quot;Rub&quot;.concat(121) # =&gt; &quot;Ruby&quot; When given a string literal as an argument, it adds that string to the original string. .+ or + is similar to the .concat method. + will return a new combined String instead of modifying the original String. Each line of code below will give the same output. \"hi\".concat(\" there\") \"hi\".+(\" there\") \"hi\" +(\" there\") \"hi\" + \" there\" This method returns a new String Full explanation B.4.2 * method Multiplies the original string by the given integer and returns the new modified String. &quot;Ya&quot; * 5 Returns \"YaYaYaYaYa\" &quot;Ya&quot; * 0 Returns \"\" Full explanation B.4.3 .upcase String#upcase ⇒ String Converts all lowercase letters to their uppercase counterparts in the given string and returns the new modified String. &quot;hello&quot;.upcase` Returns \"HELLO\" Full explanation B.4.4 .downcase String#downcase ⇒ String Converts all the uppercase letters to their lowercase counterparts from the given String. Returns the new modified String. &quot;HI&quot;.downcase` Returns \"hi\" Full explanation B.4.5 .swapcase String#swapcase ⇒ String Converts all the uppercase letters to their lowercase counterparts and lowercase letters to their uppercase counterparts from the given string. Returns the new modified String. &quot;Hi There&quot;.swapcase Returns \"hI tHERE\" &quot;hI tHERE&quot;.swapcase Returns \"Hi There\" Full explanation B.4.6 .reverse (String) String#reverse ⇒ String Returns a new String with the characters from the original String in reverse order. &quot;stressed&quot;.reverse Returns \"desserts\" Full explanation B.4.7 .length String#length ⇒ Integer Returns the Integer number of charactersin the String. &quot;hippopotamus&quot;.length Returns 12 Full explanation B.4.8 .chomp String#chomp ⇒ String or String#chomp(String) ⇒ String When not given any argument, removes the \"\\n\" (newline) character from the end of the string. When given an argument of a charcter or a string, it remove that argument from the end of the orginal string. Returns a new String with the character removed. &quot;Hey!\\n&quot;.chomp &quot;Hey!&quot;.chomp(&quot;!&quot;) &quot;Hey There&quot;.chomp(&quot;There&quot;) &quot;Hey!&quot;.chomp(&quot;y&quot;) &quot;Hey!&quot; &quot;Hey&quot; &quot;Hey &quot; &quot;Hey!&quot; p &quot;What is your name?&quot; name = gets # supposes the user inputs &quot;Clark&quot; and then hits return p &quot;Hi&quot; + name Prints \"Hi Clark\\n\" p &quot;What is your name?&quot; name = gets # supposes the user inputs &quot;Clark&quot; and then hits return p &quot;Hi&quot; + name.chomp Prints \"Hi Clark\" p &quot;What is your name?&quot; name = gets.chomp # supposes the user inputs &quot;Clark&quot; and then hits return p &quot;Hi&quot; + name \"Hi Clark\" Full explanation B.4.9 .gsub String#gsub(String, String) ⇒ String Substitutes the all occurances of the first argument with the second argument in original string and returns a new String with the substitutes made. &quot;Hello&quot;.gsub(&quot;ello&quot;, &quot;i&quot;) Returns \"Hi\" &quot;Hi.there&quot;.gsub(&quot;.&quot;, &quot; &quot;) Returns \"Hi there\" Giving an empty string as the second arugment deletes any occurences of the first arugument in the string. &quot;example @ ruby.com&quot;.gsub(&quot; &quot;, &quot;&quot;) Returns \"example@ruby.com\" Full explanation B.4.10 .to_i (String) String#to_i ⇒ Integer Converts a string literal that contains a number to an integer. The Integer is returned. &quot;8&quot;.to_i Returns 8 p &quot;What is your lucky number?&quot; lucky_number = gets.chomp # Suppose the user types is &quot;7&quot; and then hits return square = lucky_number ** 2 # This will throw an error. Returns NoMethodError (undefined method '**' for \"7\":String) This is where the .to_s method comes handy. p &quot;What is your lucky number?&quot; lucky_number = gets.chomp # Suppose the user types is &quot;7&quot; and then hits return square = lucky_numbe.to_i ** 2 # This will throw an error. p square Returns \"49\" Full explanation B.4.11 .strip String#strip ⇒ String Removes all leading and trailing whitespace in the string. Returns a new String that has been modified from the original. &quot; hi there &quot;.strip Returns \"hi there\" Full explanation B.4.12 .capitalize String#capitalize ⇒ String Capitalizes the first character of a string. Returns a new String that has been modified from the original. &quot;capitalize&quot;.capitalize Returns \"Capitalize\" Full explanation B.4.13 .split String#split ⇒ Array or String#split(String) ⇒ Array Splits a string into an substrings and creates an Array of these substrings. when not given argument, .split uses whitespace to divide the string. when given an argument, .split divides the string on that argument. Returns an Array of the divided String. &quot;Hello hi byebye&quot;.split Returns [\"Hello\", \"hi\", \"byebye\"] &quot;one!two!three!&quot;.split(&quot;!&quot;) Returns [\"one\", \"two\", \"three\"] Full explanation B.4.14 .include? String#include?(String) ⇒ Boolean Returns a boolean(true or false) based on whether the string argument is inside the string the method is being called on. &quot;Happy&quot;.include?(&quot;H&quot;) Returns true &quot;Happy&quot;.include?(&quot;Z&quot;) Returns false Full explanation "],["integer-1.html", "B.5 Integer", " B.5 Integer whole numbers B.5.1 Math Operations for the Integer Class 12 + 5 # =&gt; 17 12 - 5 # =&gt; 7 12 * 5 # =&gt; 60 12 / 5 # =&gt; 2 The / operator for integers only returns a whole number and omits the remainder. Full explanation B.5.2 % (modulus) operator Integer % Integer ⇒ Integer Returns the Integer remainder from a divisions. 13 / 5 Returns 3 B.5.3 ** operator Integer Integer ** Integer ⇒ Integer Raises a number to a power. Returns an Integer 3 ** 2 # =&gt; 9 2 ** 3 # =&gt; 8 Full explanation B.5.4 .odd? and .even? method Integer#odd? ⇒ Boolean or Integer#even? ⇒ Boolean Returns a boolean(true or false) based on whether the integer is odd or even. 7.odd? Returns true 8.odd? Returns false 8.even? Returns true 7.even? Returns false Full explanation B.5.5 rand Integer#rand ⇒ Float or Integer#rand(Integer) ⇒ Integer or Integer#rand(Range) ⇒ Integer Creates a random Float between 0 to 1 Can be given an optional Integer argument that will generate and return an Integer between 0 and the argument. Can be given an optional argument of a Range that will generate a random Integer that between the Range. rand # returns =&gt; 0.21374618638... rand(10) # returns =&gt; 7 rand((10..20)) # returns =&gt; 19 Full explanation B.5.6 .to_s Integer#to_s ⇒ String Converts an integer to a string literal. Returns a String 8.to_s “8” lucky_number = rand(10) # assigns a random integer between 0 to 9 to the variable lucky_number p &quot;My lucky number is &quot; + lucky_number + &quot;!&quot; The above block of code won’t work and will throw an error. TypeError (no implicit conversion of Integer into String) This is where the .to_s method comes handy. lucky_number = rand(10) # assigns a random integer between 0 to 9 to the variable lucky_number p &quot;My lucky number is &quot; + lucky_number.to_s + &quot;!&quot; “My lucky number is 7!” \"There are \" + 7.to_s + \" pineapples.\" “There are 7 pineapples” Full explanation B.5.7 .to_f Integer#to_f ⇒ Float converts an integer to a Float(decimal). 7.to_f 7.0 number = 10 # p number / 3 # Returns =&gt; 3 p number.to_f / 3 # Returns =&gt; 3.3333333333333335 More examples Full explanation "],["float-1.html", "B.6 Float", " B.6 Float decimals B.6.1 Math Operations for the Float Class Standard operations are similar to those for the Integer class. The only exception is the / operator which returns fractional results. 12 / 5 # =&gt; 2 12.0 / 5.0 # =&gt; 2.4 12 / 5.0 # =&gt; 2.4 12.0 / 5 # =&gt; 2.` B.6.2 ** Float operator Float ** Float ⇒ Float The **operator for Floats can additionally be used to calculate roots. 9 ** 0.5 # =&gt; 3.0, since 9^(1/2) = sqaureroot of 9 8 ** (1/3.0) # =&gt; 2.0, since 8^(1/3) = cuberoot of 8 Full explanation B.6.3 .round Float#round ⇒ Integer or Float#round(Integer) ⇒ Float Returns the whole part (Integer) of a decimal when not given any argument. When given an argument, returns a Float rounded to the number of decimal places specified by the argument. 3.14159.round # =&gt; 3 3.14159.round(3) # =&gt; 3.142 3.14139.round(3) # =&gt; 3.141 Full explanation B.6.4 .to_i (Float) Float#to_i ⇒ Integer Converts a float to an integer by rounding the float down to closest whole number. Returns an Integer \"8.9\".to_i 8 \"8.1\".to_i 8 B.6.4.1 Integer and Float division examples 12 / 5 # =&gt; 2 (12 / 5).to_f # =&gt; 2.0 12.to_f / 5 # =&gt; 2.4 12 / 5.to_f # =&gt; 2.4 (12.0 / 5 ).to_i # =&gt; 2 (12 / 5.0).to_i # =&gt; 2 "],["date-1.html", "B.7 Date", " B.7 Date B.7.1 Creating a Date To use the Date class in a Ruby program, we need to say: require \"date\" Note: Only Ruby programs need to have a require statement for the Date class. Rails already does this for you. B.7.2 Date.new Date.new ⇒ Date Use the .new method to create a new instance of a Date object. The .new method can be used with or without argument. When given no arguments, the default date is set to Jan 1st, -4712 BCE. Date.new # =&gt; #&lt;Date: -4712-01-01 ((0j,0s,0n),+0s,2299161j)&gt; Date.new(2001) # =&gt; #&lt;Date: 2001-01-01 ...&gt; Date.new(2001,2,3) # =&gt; #&lt;Date: 2001-02-03 ...&gt; Date.new(2001,2,-1) # =&gt; #&lt;Date: 2001-02-28 ...&gt; Full explanation B.7.3 Date.today Date.today ⇒ Date Initializes a Date object to the current date. Returns a Date Date.today # =&gt; #&lt;Date: 2019-04-16 ((2458590j,0s,0n),+0s,2299161j)&gt; Full explanation B.7.4 Date.parse() Date.parse(String) ⇒ Date Returns a Date object initialized to a date, interpreted from the given String argument. Date.parse(&quot;2001-02-03&quot;) # =&gt; #&lt;Date: 2001-02-03 ...&gt; Date.parse(&quot;20010203&quot;) # =&gt; #&lt;Date: 2001-02-03 ...&gt; Date.parse(&quot;3rd Feb 2001&quot;) # =&gt; #&lt;Date: 2001-02-03 ...&gt; Full explanation B.7.5 Subtraction Two dates can be subtracted from one another. The - operator returns a Rational which can be converted into an Integer to find the days in between the two dates. number_of_days = Date.today - Date.parse(&quot;July 4, 1776&quot;) # =&gt; number_of_days = (88674/1) number_of_days.to_i # =&gt; 88674 Full explanation B.7.6 Date.mday Date.mday ⇒ Integer Returns the day of the month (1-31). held_on = Date.new(2001,2,3) held_on.mday # =&gt; 3 Full explanation B.7.7 Date.wday Date.wday ⇒ Integer Returns the day of the week as an Integer (0-6, Sunday is 0). held_on = Date.new(2001,2,3) held_on.wday # =&gt; 6 Full explanation B.7.8 Days of the Week Date#moday? ⇒ Boolean date = Date.new date.monday? # =&gt; true if date is a Monday. date.tuesday? # =&gt; true if date is a Tuesday. date.wednesday? # =&gt; true if date is a Wednesday. date.thursday? # =&gt; true if date is a Thursday. date.friday? # =&gt; true if date is a Friday. date.saturday? # =&gt; true if date is a Saturday. date.sunday? # =&gt; true if date is a Sunday. Returns a Boolean, true or false, if this given Date is a particular day of the week. Full explanation "],["array-1.html", "B.8 Array", " B.8 Array list of objects represented with square brackets, []. B.8.1 Creating an Array Array.new ⇒ Array initializes a new empty Array. cities = Array.new # =&gt; cities = [] or cities = [] # =&gt; cities = [] B.8.2 .push Array#push(Object) ⇒ Array Adds elements to the end of an Array. Returns the modified Array. cities.push(&quot;Chicago&quot;) cities.push(&quot;Los Angeles&quot;) cities.push(&quot;New York City&quot;) or cities = [&quot;Chicago&quot;, &quot;Los Angeles&quot;, &quot;New York City&quot;] # Initializes and adds elements to an Array B.8.3 .at() Array#.at(Integer) ⇒ Object Takes an Integer argument and return the element in that position of an Array. The following lines of code show the various forms of the .at method and return the same output. Returns an Object cities = [&quot;Chicago&quot;, &quot;Los Angeles&quot;, &quot;New York City&quot;] cities.at(2) cities.[](2) cities[2] \"New York City\" Note: 1. Ruby indexes the elements in an array starting at zero, that is, the first element of an array will have the index zero. 2. Trying to access an element using an index greater than the length of the array will give you nil. cities.at(3) # =&gt; nil 3. Using a negative index will retrieve elements from the end of the least. cities.at(-1) # =&gt; \"New York City\" cities.at(-2) # =&gt; \"Los Angeles\" cities.at(-3) # =&gt; \"Chicago\" cities.at(-4) # =&gt; nil Full explanation B.8.4 .first and .last Array#first ⇒ Object or Array#last ⇒ Object Retrieves and returns the first or the last element of an array. Returns an Object cities.first # =&gt; \"Chicago\" cities.last) # =&gt; \"New York City\" B.8.5 .index Array#index(Object) ⇒ Integer Returns an Integer that is the index of an element. cities.index(\"Los Angeles\") # =&gt; 1 B.8.6 .count Array#count ⇒ Integer or Array#count(Object) ⇒ Integer Returns the number of elements in a list, when give no arguments. If given an argument, returns the number of times that arguments occurs in the array. In both instances, this method returns an Integer nums = [8, 3, 1, 19, 23, 3] nums.count # =&gt; 6 nums.count(3) # =&gt; 2 nums.count(2) # =&gt; 0 Full explanation B.8.7 .reverse (Array) Array#reverse ⇒ Array Returns a new ArrayArray with the elements of the original Array but in the reversed order. nums.reverse # =&gt; [3, 23, 19, 1, 3, 8] Full explanation B.8.8 .sort Array#.sort ⇒ Array Returns a new Array with the elements of the original Array but in the sorted in increasing order. nums.sort # =&gt; [1, 3, 3, 8, 19, 23] B.8.8.1 Example: Sorting an Array in decreasing order nums = [8, 3, 1, 19, 23, 3] nums.sort # =&gt; [1, 3, 3, 8, 19, 23] nums.reverse # =&gt; [3, 23, 19, 1, 3, 8] nums.sort.reverse # =&gt; [23, 19, 8, 3, 3, 1], first sorts then reverses the Array. B.8.9 .shuffle Array#shuffle ⇒ Array Returns a new Array with the elements of the original Array but with the order shuffled randomly. nums.shuffle # =&gt; [3, 23, 8, 19, 1, 3] nums.shuffle # =&gt; [19, 3, 1, 8, 3, 23] Full explanation B.8.10 .sample Array#sample ⇒ Array Returns a random element from the array. nums.sample # =&gt; 23 nums.sample # =&gt; 3 Full explanation B.8.11 .min and .max Array#min ⇒ Object or Array#max ⇒ Object Retrieve the elements of minimum and the maximum values in the array. nums.min # =&gt; 1 nums.max # =&gt; 23 Full explanation B.8.12 .sum (Array) Array#sum Returns the sum of all the elements in the array. nums.sum # =&gt; 57 Note This method only works in the elements in the Array are not a Hash Full explanation "],["hash.html", "B.9 Hash", " B.9 Hash list of objects represented with curly brackets, {}. Unlike Arrays, each cell is not automatically numbered but given a label by us. B.9.1 Interlude: Symbol Symbols are a sequence of characters and are used to to label something internally in the code. They are created by starting them off with a colon and follow the same naming conventions as variables, :hello. :hello.class # =&gt; Symbol Full explanation B.9.2 Creating a Hash Hash.new ⇒ Hash person1 = Hash.new or person2 = {} B.9.3 .store Hash#store(Object, Object) ⇒ Object Adds elements to a Hash by taking two arguments, a label (or key) and a piece of data (or value). This method returns the Object that was stored. The key can be any type, although is usually a Symbol. The value can also be of any type. person1.store(:first_name, &quot;Raghu&quot;) person1.store(:last_name, &quot;Betina&quot;) person1.store(:role, &quot;Instructor&quot;) # =&gt; person1 = {:first_name=&gt;&quot;Raghu&quot;, :last_name=&gt;&quot;Betina&quot;, :role=&gt;&quot;Instructor&quot;} or we can fill up a hash by typing in the hash literal person2 = { :first_name =&gt; \"Jocelyn\", :last_name =&gt; \"Williams\", :role =&gt; \"Student\" } Note: 1. Ruby represents each key/value pair by separating them with a =&gt;, known as a “hash rocket.” 2. If the value associated with a key already exists when you try to .store something under it, its value will be replaced. Full explanation B.9.4 .fetch Hash#fetch(Object) ⇒ Object or Hash#fetch(Object, Object) ⇒ Object Both .fetch and .[] can be used to retrieves the data held by a key. person1.fetch(:last_name)# =&gt; \"Betina\" person2.[:last_name] # =&gt; \"Williams\" If .fetch is given key that is not present in the hash, it will throw an error. But .[] is given key that is not present in the hash, it returns nil. Fallback: pass in a second default argument that .fetch will return if the key is not present in the hash. person1.fetch(:middle_name, \"None provided\") # =&gt; \"None provided\" Full explanation "],["conditionals.html", "B.10 Conditionals", " B.10 Conditionals Basic Anatomy of multibranch if statements: if condition1 # do something if condition1 is true elsif condition2 # do something if condition2 is true else # if both condition1 and condition2 were falsy # do something else end Example: p &quot;Type a number less than 10 and greater than 0:&quot; user_input = gets.chomp.to_i # gets user input, removes newline character, converts the string to integer. if user_input == 5 p &quot;You win!&quot; # Will print this if the user input is 5 elsif user_input &lt; 10 &amp;&amp; user_input &gt; 0 # check if the user input is valid p &quot;You lose!&quot; # Will print this if the user input is between 1 and 9 else p &quot;You didn&#39;t type in a valid number.&quot; # Will print this if the user input is not between 1 and 9 end Don’t forget the end keyword. Full explanation "],["loops.html", "B.11 Loops", " B.11 Loops while statements: while boolean # ruby code here end ⇒ nil while is similar to if. The difference is everytime the execution of the program reaches the end it jumps back and evaluates the truthiness of the condtion next to the while statement and decides whether or not to execute the code within the while loop. while condition # do something while condition is true end # jump back to the while statement Example: limit = 5 while limit &gt; 0 p limit limit = limit - 1 end 5 4 3 2 1 Note: If the condition next to the while always evaluates to be “truthy,” then the program will be stuck in a neverending loop, infamously known as an infinite loop. Full explanation "],["blocks-1.html", "B.12 Blocks", " B.12 Blocks B.12.1 .times Integer#times do # ruby code here end ⇒ Integer or Integer#times do |Integer| # ruby code here end ⇒ Integer The .times method takes a Block as an argument and will execute the code within that block the number of times specified by the integer. A Block of code is the code written in between the keywords do and end. This looping method returns an Integer of the number of times the loop ran. 10.times do p &quot;Hi&quot; end The above block of code will print “Hi” 10 times all on newlines. To keep a track of the iteration number, .times can create a block variable that starts of counting the iteration number starting at zero. After each execution of the code within the block, the block variable is incremented by 1. 10.times do |counter| p counter end The above block of code will print the numbers 0 to 9 all on newlines. Full explanation B.12.1.1 Other methods B.12.2 .upto Integer#upto do |Integer| # ruby code here end ⇒ Integer The upto method takes the first Integer the method is called on and uses it to initialize the value of the block variable. The second Integer becomes the stopping condition to the loop as the block variable’ increases by one after each iteration. The method returns an Integer; the initial value of the block variable. 5.upto(10) do |counter| # do something end The above block of code starts the block variable counter at 5 and executes the block until counter is 10. B.12.3 .downto Integer#downto do |Integer| # ruby code here end ⇒ Integer The downto method takes the first Integer the method is called on and uses it to initialize the value of the block variable. The second Integer becomes the stopping condition to the loop as the block variable’ decreases by one after each iteration. The method returns an Integer; the initial value of the block variable. 10.downto(5) do |counter| # do something end The above block of code starts the block variable counter at 10 and executes the block until counter is 5. B.12.4 .step Integer#step(Integer, Integer) do |Integer| # ruby code here end ⇒ Integer The step method initializes the block variable to be the value of the Integer that called the method. The first Integer argument is the the value the block variable is when the loop will stop. The last Integerargument is what value to modify the block variable after each iteration. This method returns the Integer that called the method. 1.step(10, 3) do |counter| p counter end 1 4 7 10 The above block of code starts the block variable counter at 1 and executes the block until counter is 10 but after each iteration the counter will be incremented by 3 instead of 1. .step can also be used to decrement the counter by a certain value. 10.step(1, -4) do |counter| p counter end 10 6 2 "],["looping-through-arrays.html", "B.13 Looping through Arrays", " B.13 Looping through Arrays B.13.1 .each Array#each do |Object| # ruby code here end ⇒ Array Given an array, the .each method will loop through each element of the array starting with the very first one. Returns the Array the method was called on. cities = [&quot;Chicago&quot;, &quot;LA&quot;, &quot;NYC&quot;] cities.each do |city| p city end &quot;Chicago&quot; &quot;LA&quot; &quot;NYC&quot; The block variable city holds the value of the elements in the array cities. It starts with the first element \"Chicago\" and then changes with each interation, holding the value of the next element (\"LA\") in the array and so on. Full explanation B.13.2 .each_with_index Array#each_with_index do |Object, Integer| # ruby code here end ⇒ Array To keep a track of the iteration number while looping through an array, .each_with_index creates an additional block variable that starts of counting the iteration number starting at zero. After each execution of the code within the block, the block variable is incremented by 1. cities.each_with_index do |city, count| p count.to_s + &quot; &quot; + city end &quot;0 Chicago&quot; &quot;1 LA&quot; &quot;2 NYC&quot; city holds the value of elements in the array cities. count holds the index of the element that city currently holds. Note: Variables created as a block variables can only be used within that block (between do and end). Using that variable outside that block will throw an error. Full explanation "],["different-ruby-styles.html", "C Different Ruby Styles", " C Different Ruby Styles Ruby, unlike many other languages, often supports multiple different syntax styles to achieve the same thing. This is both good and bad. It’s good because it lets us choose a style that we are most comfortable with, but it’s bad because we need to learn to at least recognize all of the styles so that we can read other people’s code. Here are a few optional syntax styles to become familiar with: "],["no-parentheses-around-arguments.html", "C.1 No parentheses around arguments", " C.1 No parentheses around arguments When we call a method that has arguments, we put the arguments within parentheses (()) immediately next to the method name (with no space between the method name and the opening parenthesis): &quot;hello&quot;.gsub(&quot;l&quot;, &quot;z&quot;) # =&gt; &quot;hezzo&quot; Ruby will allow you to, optionally, drop the parentheses around arguments: &quot;hello&quot;.gsub &quot;l&quot;, &quot;z&quot; # =&gt; &quot;hezzo&quot; It’s important to remember not to mix these two by putting a space before parentheses! # If you&#39;re going to use parens, don&#39;t also have a space &quot;hello&quot;.gsub (&quot;l&quot;, &quot;z&quot;) # bad I like to include the parentheses around arguments because it makes it clear what’s what, especially when you are chaining multiple methods together. The only time that I drop the parentheses is if I am using trivial methods at the beginning of a line, like p or ap: # Rather than p(&quot;Hi there&quot;) # I will usually do this instead: p &quot;Hi there&quot; "],["curly-braces-around-hash-arguments.html", "C.2 Curly braces around hash arguments", " C.2 Curly braces around hash arguments Consider a hypothetical method that accepts a Hash as its last argument: some_method(&quot;first_argument&quot;, 2, { :this =&gt; &quot;argument&quot;, :is =&gt; &quot;a Hash&quot; }) How many arguments does the above method have? You might be tempted to say four or even six if you just count, but really it’s three: a string is first, an integer is second, and the entire hash ({ :this =&gt; \"argument\", :is =&gt; \"a Hash\" }) is the third and final argument. In the case that a Hash literal is being used as the last argument to a method, you can optionally drop the curly braces around it: some_method(&quot;first_argument&quot;, 2, :this =&gt; &quot;argument&quot;, :is =&gt; &quot;a Hash&quot;) Now it really looks like the method is taking more than three arguments, but it’s not; Ruby can figure out from the hash rockets that the stuff at the end is really just one Hash. Note that you can only drop the curly braces around a Hash in this one, very specific case — if the Hash is the last argument to a method. So this: # Creating a Hash literal and storing it in a variable: my_hash = { :fruit =&gt; &quot;banana&quot;, :sport =&gt; &quot;hockey&quot; } is not the same as this: # The below is nonsensical, as far as Ruby is concerned: my_hash = :fruit =&gt; &quot;banana&quot;, :sport =&gt; &quot;hockey&quot; # You can&#39;t drop the curly braces around the Hash unless it is the last argument to a method. "],["new-hash-syntax.html", "C.3 New Hash Syntax", " C.3 New Hash Syntax Consider a Hash: { :fruit =&gt; &quot;banana&quot;, :sport =&gt; &quot;hockey&quot; } We can also (as of Ruby version 1.9) write the same thing as: { fruit: &quot;banana&quot;, sport: &quot;hockey&quot; } In other words, if the key in a key-value pair in a hash is a Symbol, you can move the colon (:) from the beginning of the symbol to the end of the symbol, and get rid of the hash rocket (=&gt;). This is known as the “new hash syntax” (even though Ruby 1.9 is pretty old by now). Consider the following Hash: { 1 =&gt; &quot;pink&quot;, 2 =&gt; &quot;cookies&quot; } Can we do the same trick and write this as: { 1: &quot;pink&quot;, 2: &quot;cookies&quot; } No! The “new” hash syntax is for when the keys are Symbols — then you can swing the Symbol’s colon around to the other side of it. "],["putting-it-all-together.html", "C.4 Putting it all together", " C.4 Putting it all together Consider a method that is designed like the following (very common in Rails); it has one or two arguments followed by a Hash in the last position: get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) Since the keys are symbols, we can use the new hash syntax: get(&quot;/photos&quot;, { controller: &quot;photos&quot;, action: &quot;index&quot; }) Since the Hash is the final argument to the get() method, we can drop the curly braces: get(&quot;/photos&quot;, controller: &quot;photos&quot;, action: &quot;index&quot; ) And since there are no order-of-operations concerns, we can drop the parentheses around the arguments: get &quot;/photos&quot;, controller: &quot;photos&quot;, action: &quot;index&quot; Much more concise! Again, I personally prioritize readability far above brevity, so I like making things explicit rather than concise. However, when you are reading Ruby code out in the wild (on Stack Overflow or gem READMEs on GitHub), you will most often encounter code using all of these shortcuts, so you have to know how to read it. Most importantly, the Rails team has adopted the above optional syntaxes as their default, so when you’re reading the Rails Guides, you will often see things like this: class Holiday &lt; ApplicationRecord validates :name, uniqueness: { scope: :year, message: &quot;should happen once per year&quot; }, presence: true end Holy moly! What’s going on here? You just have to unwind each optional syntax one by one to get to something more familiar. First of all, they have dropped the parentheses around the arguments to the validates() method. We can replace them: class Holiday &lt; ApplicationRecord validates(:name, uniqueness: { scope: :year, message: &quot;should happen once per year&quot; }, presence: true) end Next: whenever you see a colon at the end of a token, you know it’s the new Hash syntax. So we can unwind it by moving the colons to the beginning and putting back the Hash rockets: class Holiday &lt; ApplicationRecord validates(:name, :uniqueness =&gt; { :scope =&gt; :year, :message =&gt; &quot;should happen once per year&quot; }, :presence =&gt; true) end Notice that I didn’t (and can’t) move the colon in :name — it’s already at the beginning, and this Symbol is not being used as the key in a Hash. It is simply the first argument to the validates method. Similarly, the Symbol:year is the value associated to the key :scope, so we leave it alone. Next: the second and last argument to the validates() method is a Hash with two keys (:uniqueness and :presence), so the Rails Guides dropped the curly braces around it. We can put them back: class Holiday &lt; ApplicationRecord validates(:name, { :uniqueness =&gt; { :scope =&gt; :year, :message =&gt; &quot;should happen once per year&quot; }, :presence =&gt; true }) end We might also take advantage of whitespace to indent more helpfully: class Holiday &lt; ApplicationRecord validates( :name, { :uniqueness =&gt; { :scope =&gt; :year, :message =&gt; &quot;should happen once per year&quot; }, :presence =&gt; true } ) end Now that we’ve fully unwound the optional syntaxes, it’s easier to see that: The validates() method is taking two arguments; the first is a Symbol and the second is a Hash. The value associated with the :uniqueness key is itself another, nested, Hash: { :scope =&gt; :year, :message =&gt; \"should happen once per year\" }. That Hash has two keys in it: :scope and :message. We cannot drop the curly braces around { :scope =&gt; :year, :message =&gt; \"should happen once per year\" } because it is not the last argument to a method — it is the value associated to the key :uniqueness in a parent hash. If we tried to drop them, we’ll run into problems: class Holiday &lt; ApplicationRecord validates(:name, { :uniqueness =&gt; :scope =&gt; :year, :message =&gt; &quot;should happen once per year&quot;, :presence =&gt; true }) end Ruby can’t make sense of :uniqueness =&gt; :scope =&gt; :year, and can’t tell which things are in the inner hash vs. the outer hash. So: don’t fret when you see seemingly unfamiliar syntax like scope: :year — it’s nothing new, it’s just a different style. You’ve got the tools you need to understand any Ruby you encounter. "],["single-line-blocks.html", "C.5 Single line blocks", " C.5 Single line blocks Often, we only have one line of code within our do/end blocks: numbers = [8, 3, 1, 4, 3, 9] numbers.select do |num| num &gt; 3 end # =&gt; [8, 4, 9] If you wanted to, you could fit it all on one line: numbers = [8, 3, 1, 4, 3, 9] numbers.select do |num| num &gt; 3 end # =&gt; [8, 4, 9] You can also replace the do with an opening curly bracket ({) and the end with a closing curly bracket (}): numbers = [8, 3, 1, 4, 3, 9] numbers.select { |num| num &gt; 3 } # =&gt; [8, 4, 9] This can get confusing, because now we’re overloading the curly braces ({}) for more than one purpose: Hash literals and blocks. However, it’s a very common style so you should get used to figuring out which one it is from the context. If the curly braces are next to a method and there are no key/value pairs, then it’s a block, not a Hash. This style is most often used when chaining more methods: numbers = [8, 3, 1, 4, 3, 9] numbers.select { |num| num &gt; 3 }.sort # =&gt; [4, 8, 9] Ruby wants developers to be happy, so it gives them lots of options — this is a double-edged sword! It means we can be expressive, but it also means we need to be able to parse many different styles when reading other people’s writing. As beginners, it can be frustrating; but in the long-run, you’ll appreciate it. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
