[["index.html", "AD1 Preface", " AD1 Ben + Raghu 2023-01-15 Preface This document is originally based on a chronological outline of the AppDev course content, from the Canvas material for “BUSN 36110 81 (Summer 2022) Application Development”. "],["planned-lms.html", "Planned LMS", " Planned LMS This is the basic outline of a “Lesson” in the planned LMS app, including the syntax for LTI placement and quiz questions class Person attr_accessor :first_name, :last_name def full_name &quot;#{first_name} #{last_name}&quot; end end Bullets More bullets A paragraph. LTI{Launch the tool}(https://lti-provider-example.herokuapp.com/lti_tool)[test]{secret}(20)[foo]{400} Bullets More bullets LTI{ }(https://lti-provider-example.herokuapp.com/lti_tool)[test]{secret}(10)[bar] Choose one First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option This is not correct because of xyz reason {: .choose_best #bin points=“30” answer=“3” } Choose all that apply First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option That’s right! Because of xyz reason {: .choose_all #baz points=“30” answer=“[3, 4]” } "],["outline-notes.html", "1 Outline Notes", " 1 Outline Notes Although originally based on the chronological assignments on Canvas in “BUSN 36110 81 (Summer 2022) Application Development”, this book has some re-ordering. "],["updated-diátaxis.html", "1.1 Updated Diátaxis", " 1.1 Updated Diátaxis Update: in the original outline, sections were tagged with the type. We don’t need to be so strict, but we should adhere to some rules of thumb Terminology and code syntax should be collected in technical reference glossaries Video tutorials should not digress too much into explanations and generalizations How-to written guides and accompaniments to videos should be concise, with code that can be copy-pasted Explanations are room to expand on ideas and digress 1.1.1 Original Outline Diátaxis In an effort towards Diátaxis, the content is identified by small chunks of material with tags: da=“Tutorial” pratical-study quadrant practical guided tutorials that produce meaningful results avoid abstraction, generalization, explanation, choices da=“HowTo” pratical-work quadrant similar to tutorial, but more concise with no digression or teaching da=“Explain” theoretical-study quadrant understanding-oriented discussions referring to big-picture topics include concepts, connections, abstraction, generalzation, alternatives, optional readings da=“TechRef” theoretical-work quadrant indexes, glossaries, dictionaries pure information, concise, no ambiguity, provide examples da=“Exercise” our own this is not part of the cannon, but we add it The “TechRef” (glossaries) and “Exercise” (quizzes + projects) tags are obvious, so content in these categories is not explicitly labelled in the outline. Note, the difference between “Tutorials” and “HowTo” here. They are distinguished by the user needs: study (“Tutorial”) vs. work (“HowTo”). Tutorials provide a learning experience, how-to-guides help the user accomplish a task. Any video walkthroughs are “Tutorials” and their written accompaniments are “HowTos”. How-to-guides should never be videos, because a user should be able to quickly refer to what they need, without buffering or scrubbing. "],["technical-references-code-vs.-terminology.html", "1.2 Technical References: Code vs. Terminology", " 1.2 Technical References: Code vs. Terminology There are two types of technical references. One is for terms, the terminology reference, which can be related to specific programming languages, however, any examples of HTML tags, Ruby methods, etc. should go into the code reference. There is one code reference for each subject area: HTML+CSS, Ruby, etc. Both of these glossaries could be built up through the class, meaning the students would only see the most recent terms and those introduced previously. By the end, this is a long glossary sectioned by course units. These code references already exist: Ruby: Ruby Foundations Slides the-one-reference.md optional-syntaxes-in-ruby.md HTML + CSS: HTML + CSS Recap Slides html-reference.md html-cheatsheet.md classbook.md "],["whats-missing.html", "1.3 What’s missing?", " 1.3 What’s missing? Running list of things TODO: The location(s) of the technical references (“TechRef”), and how they are built up, currently found in glossaries. Command-line basics could just be a short “Tutorial” video along with a “TechRef” of all the commands shown in the course place to explain directory structure and filepaths Dedicated video + text content of technical setup. Gitpod and github accounts, opening gitpod workspace, tab organization, /git commiting, rails grade, etc. Can be done with “RPS HTML” or “String” as example. See [Gitpod Technical Setup]. Dedicated video + text content of gems and Gemfile (and maybe bundle). This is found throughout content right now. CSS reference, there is some here: classbook.md Text doc with “keyboard magic” commands (e.g., TAB completion, opening/clearing terminal). Dedicated video + text for ideas.firstdraft.com with domain model for OfferUp. See Domain Modeling Video tutorial for https://association-accessors.firstdraft.com/. This is in the last 10 minutes of Day 7 recording right now. Maybe a dedicated chapter for belongs_to, has_many, scope, through, and use of .joins() for queries. Dedicated video + text content for starting from scratch, generator resources, and migration. This is spread across videos (e.g., Day 7 video, Day 8 short video, Photogram and MSM signin), chapters (e.g., active-record.md, draft-generators.md, draft-account.md), classroom examples (Day 8 recordings). See Starting from Scratch with Generators API videos for Mailgun, Twilio, etc. Print stylesheet applied to any lesson to make hard copies (pdf) Heroku alternative video / writeup "],["course-overview.html", "2 Course Overview", " 2 Course Overview Notes: Non-transcribed video: Day 1 Recording Each Bird’s Eye View Slides section could be a separate sub-section: 01-09: Course intro 10-15: What does it mean to know how to code? 16-21: SaaS 22-26: URLs 27-33: Raghu’s journey 34-40: How learning SaaS has evolved 41-46: Ruby on Rails, Play the whole game 47-49: Teaching team 50-79: Record keeping (history, tables, databases, domain modeling, CRUD) 80-88: Must See Movies example relational database tables "],["course-intro.html", "2.1 Course intro", " 2.1 Course intro "],["what-does-it-mean-to-know-how-to-code.html", "2.2 What does it mean to know how to code?", " 2.2 What does it mean to know how to code? "],["saas.html", "2.3 SaaS", " 2.3 SaaS "],["urls.html", "2.4 URLs", " 2.4 URLs "],["etc.-from-slides.html", "2.5 etc. from slides", " 2.5 etc. from slides "],["technical-setup.html", "3 Technical Setup", " 3 Technical Setup Notes: These steps are done in the RPS HTML content (original video), and String exercise (original video) This is a place to collect dedicated how-to-guides to refer students back to Dedicated video tutorials would be helpful here as well Project: N/A Target: N/A Useful chapters: day-2-notes.md getting-started-with-gitpod.md rails-grade.md fixing-your-organization-permissions.md gitpod-snapshot.md hard-reload.md using-git-to-experiement-and-save-work.md tips-and-tricks.md "],["setting-up-accounts.html", "3.1 Setting Up Accounts", " 3.1 Setting Up Accounts Notes: sections from day-2-notes.md 3.1.1 Get a GitHub account Sign up for a free GitHub account at github.com/join I recommend using your .edu email address, as that will qualify you for some discounts and coupons that you might want to use later. Remember to verify your email address after signing up. If you already have a GitHub account, I recommend making a new one for this class, because some of the tools that we use will ask for permission to view all of your repositories. If you have access to e.g. private work repositories, then you should make a new account and keep things separate. 3.1.2 Get a Heroku account Sign up for a free Heroku account at signup.heroku.com If asked what your primary development language is, say Ruby. You can use any one of your email addresses, but remember to verify it. 3.1.3 GitHub and Heroku readings While you’re waiting for everyone to finish creating accounts, read up on GitHub and Heroku. Think of question: Read about GitHub: http://bit.ly/2skLlYx Read about Heroku: http://bit.ly/2uLVTAP "],["gitpod.html", "3.2 GitPod", " 3.2 GitPod Notes: sections from getting-started-with-gitpod.md, tips-and-tricks.md, and hard-reload.md can use RPS HTML as example should include forking, workspace layout, bin/server, tab management could be chance to talk about file structures and terminal 3.2.1 Getting Started With Gitpod One of the most painful parts of learning how to program, in the old days, was simply setting up your computer to be able to write and run code. At a minimum, we needed to install: An application to write your code with. Something like Microsoft Word is not be ideal for writing code, since code needs to be plain text (just a series of characters in a file, nothing else) for the computer to understand it. Word is designed to write rich text (for humans) with fonts, colors, sizes, margins, layouts, etc. Computers come bundled with some plain text editors (Notepad, TextEdit, etc) but they are very basic. We would instead prefer to use powerful tools specifically designed for writing code with like Microsoft’s VSCode or JetBrains’ RubyMine. Ruby itself. Writing code is not useful on its own if we don’t have something to run it with; just like we need a browser installed to interpret .html files we need Excel installed to interpret .xls files, and we need Photoshop installed to interpret .ps files, we need Ruby installed in order to interpret the .rb files that we write. Not only that, we need the correct version installed. If your computer happened to come with an older version, upgrading to a newer version could be complicated — especially if some other application you use depends on the older version. There are so many different combinations of hardware, operating systems, previously installed software, permission levels (for example if you are using a work-owned computer), that just getting these things installed would often stop you before you started writing your first program. We can’t allow that! Instead, we’re going to use a write our code using a cloud computer. “Cloud” just means that it’s a computer that’s sitting in someone’s warehouse1 somewhere, and we rent it from them. It already has all of the software that we need installed on it, and we access it through our browsers. No muss, no fuss! Gitpod.io is a great new service that provides instantaneous, full-fledged cloud development environments from any codebase that is on GitHub.com — which is great, because we (and 98% of other teams) use GitHub to store all of our projects, homeworks, etc. The text editor they provide is based on Microsoft’s VSCode — my editor of choice. It will have the exact right version of Ruby, Rails, and everything else we need. And they have a very generous free tier. Great! Sign up for a Gitpod.io account. It will ask you to sign in using your GitHub account. We will create a workspace for each project that we work on. Each workspace is based on a GitHub repository (i.e., a folder with some code in it). For example, here is a repository: https://github.com/appdev-projects/helloruby To create a Gitpod workspace based on a repo, in the address bar of your browser enter https://gitpod.io/# and then the URL of the repo. For example, https://gitpod.io/#https://github.com/appdev-projects/helloruby To make that process easier, Gitpod has a browser extension that you can install if you want to. Typically, we will assign you a project in Canvas. The assignment will include a button that says “Load assignment in a new window”. When you click on that button, it will create a fork (i.e. a copy) of the repository (i.e. the folder of code) on your own GitHub account. You will then create a Gitpod workspace2 based on your fork, so that you can save the work that you do back to your own GitHub account. A button to create your Gitpod workspace will appear within the assignment, so usually all you need to do is click on it after clicking “Load assignment in a new window”. And then you can get right to work, with the exact right version of all of the project’s dependencies ready to go! 3.2.2 Forcing Chrome to “Hard” Refresh Sometimes, when we update a CSS stylesheet, our page appears not to change. This is especially frequent when we’re working on static HTML files in the public/ folder. The cause is usually Chrome’s aggressive “caching”, i.e. re-using static assets that it has already downloaded (for performance reasons). If we refresh an HTML page that we’ve updated, Chrome won’t necessarily also refresh all &lt;link&gt;ed CSS files — unless we ask it to by “hard” refreshing. To do so: Open the Dev Tools… from the View &gt; Developer menu or right-click on any element and Inspect or press F12 or Ctrl+Shift+J (on Windows) or Option+Command+J (on Mac) Right-click on the refresh button. Select “Empty cache and hard reload”. Open Dev Tools: With Dev Tools open, “hard” refresh: Your HTML document should now have the latest CSS and any other linked assets (like images or javascripts). 3.2.3 Gitpod keyboard shortcuts and other productivity tips 3.2.3.1 Important Terminal keystrokes to know 3.2.3.1.1 Jump to beginning of line You can’t use your mouse at the command line, so it’s important to know how to move around quickly so you’re not restricted to just using your arrows. Jump back to the beginning of the line with Ctrl + A: 3.2.3.1.2 Jump to end of line Mac OS, Windows: Ctrl + E 3.2.3.1.3 Up and down arrows to scroll through your history Use your up and down arrows to scroll through your command history so that you don’t have to re-type your commands over and over. 3.2.3.1.4 Clear Terminal Mac OS: Command + K Windows: Disabled by default3 From the menu open Preferences and select Keyboard shortcuts. Then search for “terminal clear” in the search bar and click the plus icon to the left of it. Finally, type ctrl + k and Enter to confirm. 3.2.3.1.5 Interrupt command If something goes wrong with a terminal program (i.e. you made a typo, a program gets stuck in an infinite loop, etc), you can generally interrupt it with Ctrl + C: 3.2.3.1.6 Q to exit When the output of a terminal command is too tall for a terminal tab to display at once, it paginates. Press Space to step through it one page at a time, or Q to quit and get back to the terminal prompt so that you can execute your next command. Mac OS, Windows: Q 3.2.3.2 Editor keyboard shortcuts 3.2.3.2.1 Command Palette The most important thing to memorize is how to open the Command Palette, which will allow you to fuzzy search within for all other commands. If the command has a keyboard shortcut mapped to it, the shortcut will be displayed to the right. This is the best way to learn the keyboard shortcuts for the commands that you use most frequently. Mac OS: Command + Shift + P Windows: Ctrl + Shift + P 3.2.3.2.2 Quick open file To quickly jump to a file: Mac OS: Command + P Windows: Ctrl + P And then fuzzily search for its name. For example, you could type “phco” to get to photos_controller.rb and the list would quickly narrow to bring that file to the top of the list. 3.2.3.2.3 Toggle Code Comment To quickly comment a line of code, put your cursor on that line and then: Mac OS: Command + / Windows: Ctrl + / You can also highlight multiple lines of code and comment/uncomment all of them at once. 3.2.3.2.4 Find (and replace) Mac OS: Command + F Windows: Ctrl + F 3.2.3.2.5 Find Next Selection Mac OS: Command + D Windows: Ctrl + D If you go too far by mistake, you can step backwards with Command + U or Ctrl + U. 3.2.3.2.6 Move line Mac OS: Option + ⬇ Windows: Alt + ⬇ 3.2.3.2.7 Duplicate line Mac OS: Shift + Option + ⬇ Windows: Shift + Alt + ⬇ 3.2.3.2.8 Add/Remove Tab spaces for multiple lines Mac OS: (Shift) + Tab Windows: (Shift) + Tab 3.2.3.2.9 Add More Cursors Mac OS: Option + Click Windows: Alt + Click 3.2.3.2.10 Embedded Ruby (ERB) Tag Toggle Mac OS, Windows: Ctrl + Shift + ` 3.2.3.2.11 Toggle Terminal Panel Mac OS: Command + J Windows: Ctrl + J 3.2.3.2.12 Open New Terminal Mac OS: Ctrl + ~ (i.e. Ctrl + Shift + `) Windows: Ctrl + ~ (i.e. Ctrl + Shift + `) A warehouse full of computers that people rent and connect to via the internet is called a “data center”. Some data centers have their own power plants, and some are even earthquake-proofed.↩︎ Gitpod will delete an inactive workspace after 14 days. If you want to save the changes you’ve made for longer, you can “pin” a workspace in Gitpod which will prevent it from being deleted. Even better, you can push your changes to Github.↩︎ A recent Gitpod update removed this keyboard shortcut for Windows, so you’ll need to configure it yourself.↩︎ "],["git.html", "3.3 Git", " 3.3 Git Notes: sections from using-git-to-experiement-and-save-work.md 3.3.1 What Git is Git is an extremely powerful version-control system created by Linus Torvalds in 2005 for development of the Linux kernel, which is one of the largest open-source software projects in existence. It makes it possible for large numbers of contributors to work on various features, all within a single codebase (which could be comprised of hundreds or thousands of files). Bitbucket, GitLab, and especially GitHub (all private companies) rode the rise of Git (the protocol) to become the center of the software development universe. All of these companies basically offer cloud-based storage for codebases using Git for version-control (we refer to these codebases as repositories), as well as a web-based interface for collaborating on them — following, commenting, etc. 3.3.2 Why we care In this course, we’re going to use one simple but effective Git-based workflow to save versions of our work. This will allow us to freely experiment with different approaches, while never having to throw away code. In all of our Rails apps, after you start the server, you can navigate to the address /git in your live application. If you’re using Gitpod, the URL will look like: https://[YOUR GITPOD WORKSPACE URL].gitpod.io/git That will open a page that looks like this: As soon as you make any changes to any of the code in the project, and refresh this page, the lines that you changed will appear: On the left, you see the code as it was previously; on the right, you see the new code. Lines added are highlighted in green, lines removed are highlighted in red. Below, there are two things you can do: commit your changes on the left, and switch to a new branch on the right. When you hear the word “commit”, think “snapshot”. When you hear the word “branch”, think “version”. A Git commit is a snapshot of all of the folders and files in your project at a particular time. Since our files of code are all interdependent, it doesn’t make sense to save versions of individual files — we need to know the entire state of the project for a version to be useful. Each branch (“version”) is a series of commits (“snapshots”). The most important thing for you to remember is simple: commit early and commit often. As long as you are taking snapshots of your work at various points, it will always be easy to get back to a previous state in case you want to start over and explore a different approach. To commit, enter a title for the snapshot (required), and, optionally, a longer description: After you commit, you will no longer have any pending changes: If you edit your code again, then you can make further commits. Fundamentally, that’s all you need to worry about: just make lots of commits as you work. The best time to commit is right after you just got something to work, before you start on your next experiment. Remember: ABC: Always Be Committing. 3.3.3 Jumping back in time In the History dialog at the bottom, you can see a list of all of the commits you’ve made. If you want to jump back in time to one of them, copy the 7 letter code (known as the “hash” of the commit; it is a unique identifier) in front of it into the “Branch off of” field above. Pick a name for a new version, and click “Create a new branch off of…”. It will snap all of the files in the project back to that point in time, and you can now make further commits along a new path — while still retaining all of your old commits on the old path. You can easily jump to any commit from any branch at any time — so feel free to experiment! Make a commit to save your current work, then jump back to a previous commit to try a different approach. 3.3.4 Switch to a Different Branch Have you gone back in time and decided your first attempt was better? Turn your attention to the “Existing Branches” panel on the right. This will list any branches your project has— master is the default starting branch. To switch to a different branch, click the blue double arrow button next to the name of the branch you want to switch to. If you’re ever unsure of what branch you’re on, the top of the page should list “On branch ___”. 3.3.5 Push to GitHub Gitpod workspaces are not permanent. Even if we make git commits, if the workspace is deleted so is all of our work! This is where GitHub comes in. We can push all of the commits we’ve made to our repository on GitHub where it will live forever. If our Gitpod workspace gets destroyed we can just re-create another one from the latest commit on GitHub! Before you can push to GitHub, you need to give Gitpod access. Head over to the Integrations under your account settings in Gitpod and make sure you check “public repos” and click “Update”. This should open a GitHub authorization dialogue. Make sure to click “Grant” next to the GitHub organization you created for class Now you should be all set to push your commits to GitHub! "],["rails-grade.html", "3.4 rails grade", " 3.4 rails grade Notes: sections from rails-grade.md, fixing-your-organization-permissions.md, and gitpod-snapshot.md kind of awkward placement, this video and text could go early in RPS HTML video manually checking work, rails grade, git commiting 3.4.1 Getting automated feedback with rails grade 3.4.1.1 Join GitHub If you haven’t already, sign up for a free GitHub account (or sign in to yours if you already have one): In this example screenshot, I chose a username of demolearner1 — remember yours. Also, don’t forget to check your email and verify the address you entered. For now, think of GitHub like Dropbox-for-programmers; it’s where we’re going to store all of our code. 3.4.1.2 Create GitHub organization To keep things organized, we’re going to create a separate GitHub organization account for you to store your AppDev projects under (to keep them separate from the personal projects that you’ll hopefully be building soon!). Click the + on the right side of the navbar and select “New organization”: Choose any name for the organization; most students choose [YOUR USERNAME]-appdev. In this example screenshot, I chose demolearner1-appdev: You can “Skip” or “Finish” the rest of the screens: 3.4.1.3 Login to Canvas Open up the Assignments tab and make sure they’re sorted by type. Scroll down to the assignment you want to start and click the link that says ‘Load [your assignment name] in a new window’ (the name of the project will vary). Before you click “Authorize”, make sure to click the “Grant” button next to the organization that you created earlier. Only then, click authorize to allow the firstdraft Grades application to access your account. Select the name of your GitHub organization and submit the form. The next screen will ask you to accept an invitation to a GitHub team. You can click the link on that screen to accept, or you’ll have an invitation in your email inbox as well. Once you’ve joined, you should see feedback that you’re now a member of appdev-projects: 3.4.1.4 Daily workflow The stuff above about setting up your organization and permissions was just a one-time thing. From now on, you’ll just head to Canvas and click “Load assignment in a new tab”. You should see something like the following (the name of the project will vary): We will automatically make a copy (a “fork”, in GitHub parlance) of the repository under your new GitHub organization. Then, you can choose to either “Create new workspace in Gitpod” or head to your “Gitpod Dashboard” to view existing workspaces. Either way, once you’re in the workspace, we can get the project loaded up and try out the feedback feature. After the bin/setup script is done running, start working on the project to do whatever the instructions tell you. When you’re ready for feedback, try a new command at a new Terminal prompt: rails grade You’ll be asked for your access token; copy-paste it carefully from the grades.firstdraft.com page that you loaded from Canvas. You should see output that looks like: Copy-paste the Results URL into a new tab, or click on it (but make sure it isn’t truncated). (Some projects aren’t graded; in that case there may only be one dummy test listed.) You can click on one of the tests to get more feedback on what might have gone wrong: In this case, the test expected to find an element with a class of word_count that contains the number 10, but instead it only found the content “Replace this string with your answer”. You can click the “Examine Test” button to read the actual Ruby of the automated test; it’s surprisingly readable. Ruby’s testing libraries use method names that are supposed to make tests readable even for non-technical managers and clients. You can see specifically what flow is being tested and what inputs are being used and what the expected output is, and try to reproduce the issue in your own app manually using the same inputs. You can run rails grade in your Terminal as many times as you want, and you will get a new updated build report each time. It will only report your highest score back to Canvas. Remember that your first job is always to make your app work as described and test it manually yourself. You should not rely exclusively on the automated tests; they are a terrible way to debug. 3.4.2 Fixing your organization permissions Once upon a time, we all created our own GitHub organizations to keep our classwork separate from our personal projects. Since then, whenever we gave permission to a third-party (like Gitpod or grades.firstdraft.com) to access our GitHub accounts, we were supposed to remember to grant access to our organization too. If you forgot to click “Grant” next to the organization that you created before you clicked “Authorize”, you’re going to run into problems. Let’s fix it. Go to GitHub and sign in. In this example, I am signed in as the user demolearner1. Click on the user icon in the top-right and find “Settings”: Next, click on “Organizations” in the left sidebar: Find the organization that you created. You likely picked a name like [YOUR USERNAME]-appdev: Next, go to the Settings of the organization: In the left sidebar, find “Third-party access”: If it says that you approved both, then you are good to go and you can go to the next section. If neither Cloud9 nor Grades appears in this list, click the “Remove restrictions” button instead and you can go to the next section. If it says that access is Denied next to Cloud9 or Grades, then proceed. Click on whichever one you denied and Grant Access: You should see a message confirming that access has been granted: Repeat for the other third-party app if necessary. 3.4.2.1 Make sure that you’ve accepted your team invitation Visit this page and make sure that you don’t have a banner across the top asking you to accept our team invitation. (This invitation was sent a while ago via email; if you’ve already accepted it, the banner won’t appear.) 3.4.2.2 Launch an assignment from within Canvas Head back to Canvas and click on whichever assignment you want to work on again (don’t just refresh it if you already had it up). You might be asked to enter your organization name — be sure to enter your organization name, the one you created; not appdev-projects. 3.4.2.3 Resetting OAuth permissions to square one If for some reason you need to make a single-sign-on provider (like GitHub, Twitter, or Facebook) “forget” that you ever authorized a third-party app, maybe because you don’t use it anymore or maybe because you want to change the permissions that you gave it, you need to delete or revoke the “access token” that you previously issued to it. In the case of GitHub, go to your personal settings: Find “Applications” in the left sidebar: Click the “Authorized OAuth Apps” tab and then click “Revoke” next to whichever one you want to “forget”: Then, return to the third-party app and “Sign in with…” again to start over from scratch. In our case, click on an assignment from within Canvas again to re-start the authorization process — and this time don’t forget to grant access to the organization that you created. 3.4.3 Sharing a Gitpod Snapshot It’s often helpful to share a snapshot of the state of your entire Gitpod workspace with someone else. 3.4.3.1 Take the snapshot From the hamburger menu in the top-left corner of your IDE, select Gitpod: Share Workspace Snapshot: 3.4.3.2 Copy the snapshot URL It will take a moment to create the snapshot. Then a dialog will pop up in the bottom-right corner that will give you the URL to copy and share: 3.4.3.2.1 The correct URL looks like this The URL that you share should look something like this: https://gitpod.io#snapshot/5a47e40d-e279-44e5-96bc-ae33cd48f151 Note the #snapshot fragment of the URL. That means you have the right one. 3.4.3.2.2 Not this The URL should not look something like this: https://ac1bde40-34e8-421d-a102-6425971fb9db.ws-eu38.gitpod.io/ That is the URL of your own IDE, which no one else can access. 3.4.3.2.3 Or this The URL should not look something like this: https://3000-ac1bde40-34e8-421d-a102-6425971fb9db.ws-eu38.gitpod.io Note the 3000- at the start. That is the URL of the live preview of your app. 3.4.3.3 Snapshots are completely independent When someone clicks on the snapshot URL, they will get their own private copy of your workspace in the state that it was in when you took the snapshot. Any changes they make to their copy will not affect your workspace. Similarly, any changes you make to your workspace won’t affect their snapshot. So you can keep trying to resolve the problem on your own, or work on the next task, without interfering with their snapshot. "],["rock-paper-scissors-html.html", "4 Rock, Paper, Scissors HTML", " 4 Rock, Paper, Scissors HTML Notes: The video is not yet transcribed and may change GitPod setup is contained in the video. This is an applied example and the Technical Setup chapter can be referred to as a how-to guide. Project (graded): https://github.com/appdev-projects/rps-html Target: https://rps-html.matchthetarget.com Useful chapters: html-reference.md html-cheatsheet.md "],["video-segment-1st-bite-size-chunk-of-rps-html.html", "4.1 Video Segment: 1st bite-size chunk of RPS HTML", " 4.1 Video Segment: 1st bite-size chunk of RPS HTML 4.1.1 Text Companion: 1st bite-size chunk of RPS HTML "],["video-segment-nth-bite-size-chunk-of-rps-html.html", "4.2 Video Segment: Nth bite-size chunk of RPS HTML", " 4.2 Video Segment: Nth bite-size chunk of RPS HTML Notes: The pattern repeats 4.2.1 Text Companion: Nth bite-size chunk of RPS HTML "],["finish-and-submit-rps-html.html", "4.3 Finish and Submit RPS HTML", " 4.3 Finish and Submit RPS HTML Notes: Refer students to rails grade, git, and Sharing a Gitpod Snapshot sections for how to get help "],["deploying-to-heroku.html", "5 Deploying to Heroku", " 5 Deploying to Heroku Notes: This could be a sub-section in Technical Setup The video is not yet transcribed and may change Project: N/A Target: N/A Useful chapters: deploying-to-heroku.md See Canvas "],["rock-paper-scissors-css.html", "6 Rock, Paper, Scissors CSS", " 6 Rock, Paper, Scissors CSS Notes: The video is not yet transcribed and may change Project (ungraded): https://github.com/appdev-projects/rps-css Target: https://rps-css.matchthetarget.com/rock Useful chapters: classbook.md#styling-with-css, but this is outdated? "],["video-segment-1st-bite-size-chunk-of-rps-css.html", "6.1 Video Segment: 1st bite-size chunk of RPS CSS", " 6.1 Video Segment: 1st bite-size chunk of RPS CSS 6.1.1 Text Companion: 1st bite-size chunk of RPS CSS "],["video-segment-nth-bite-size-chunk-of-rps-css.html", "6.2 Video Segment: Nth bite-size chunk of RPS CSS", " 6.2 Video Segment: Nth bite-size chunk of RPS CSS The pattern repeats 6.2.1 Text Companion: Nth bite-size chunk of RPS CSS "],["relationships.html", "7 Relationships", " 7 Relationships Notes: This was in-class work from the un-transcribed Day 2 recording Records and Relationships Slides 01: Get to know each other 02: Types of associations "],["practice-identifying-relationships.html", "7.1 Practice Identifying Relationships", " 7.1 Practice Identifying Relationships Notes: Records and Relationships Slides 03-25: Practice identifying relationship 26: ERD &amp; Ideas Slides (but this doesn’t actually come next) "],["html-css-stylesheets-and-design-recap.html", "8 HTML, CSS, Stylesheets, and Design Recap", " 8 HTML, CSS, Stylesheets, and Design Recap Notes: This was in-class work from the un-transcribed Day 2 recording Project (ungraded): Replits HTML and CSS Recap Slides "],["html-recap-and-replits.html", "8.1 HTML Recap and Replits", " 8.1 HTML Recap and Replits Notes: this could all just be in the technical reference for HTML, with Replit exercises following the review Useful chapters: html-reference.md html-cheatsheet.md HTML and CSS Recap Slides 01-05: HTML basics 05-07: HTML Replits "],["css-recap-and-replits.html", "8.2 CSS Recap and Replits", " 8.2 CSS Recap and Replits Notes: this could all just be in the technical reference for CSS, with Replit exercises following the review Useful chapters: classbook.md#styling-with-css, but this is outdated? HTML and CSS Recap Slides 09-13: CSS Fundamentals 14: CSS Fundamentals Replit 15: External style sheets 16: External style sheets Replit "],["stylesheets-recap-and-replits.html", "8.3 Stylesheets Recap and Replits", " 8.3 Stylesheets Recap and Replits Notes: HTML and CSS Recap Slides 20-23, 25-26: Borrowing style sheets 24: Google Fonts Replit 27: Font Awesome Replit 28: Bootstrap "],["design-resources.html", "8.4 Design Resources", " 8.4 Design Resources Notes: HTML and CSS Recap Slides 29: Readings 31-34: Basic rules (mixed in with some Replits) sections from design-resources.md As you go about designing and coding your application’s screens, here are a few things that you may find useful. 8.4.1 Readings I’ve placed them in rough order of my opinion of their value/length ratio. Butterick’s Typography In Ten Minutes 7 Rules for Creating Gorgeous UI - and part 2 Web Design in 4 minutes 8.4.2 Resources 8.4.2.1 Bootstrap Official Bootstrap documentation Everything in one place Bootstrap 5 cheatsheet — Since the official docs are really spread out, this cheatsheet can be easier to look through quickly. Bootswatch - Cheating! Great for quick styles while prototyping. The previews are also great for looking through quickly for useful components, almost like the Cheat Sheet above. Shoelace.io - A tool to help you create your Bootstrap grid layout. Premium Bootstrap themes Bootstrap.build Generate your own Bootswatch, essentially. If you don’t have your own brand identity created yet, you can practice by making a UChicago branded theme; see pages 38-41 of the Identity Guidelines. 8.4.2.2 Other design systems Bootstrap isn’t the only design framework in town. Here are a few more, just to give you an idea: Tailwind CSS — Imagine if Bootstrap only had utility classes, like the ones for spacing and shadows, but had a lot more than it does; and no components per se. That’s Tailwind — you’re expected to assemble your own cards, alerts, etc, out of the utility classes. Many people like it because it’s “lighter” than Bootstrap — it gives you the tools to build up your own, custom framework; but you’re still not starting from scratch. GOV.UK Design System and U.S. Web Design System — Government design systems, with accessibility and consistency as paramount concerns. Bulma and Foundation — More direct analogs to Bootstrap. 8.4.2.3 Fonts Font Awesome - Free, CSS-customizable, perfectly scalable icons for almost everything. Google Web Fonts - You’ll want this after reading Butterick’s. Google Web Font pairing inspiration: Typographic Project Beautiful Web Type FontPair Ultimate Google Web Font Pairings 8.4.2.4 Games to get good at CSS CSS Diner — Become a pro at CSS selectors. Useful if you plan to do a lot of web scraping. Flexbox Froggy — Get a better understanding of Flexbox, the reason that positioning things on the web is no longer a nightmare. 8.4.2.5 Stock images Unsplash Stock Up - A search engine for free stock photos. Subtle Patterns - A library of free, tileable, subtle background images. 8.4.2.6 HTML &amp; CSS references HTML validator The CSS Cascade — Learn how CSS specificity rules actually determine which one of competing rules gets applied to an element. HTML5 Element List - An excellent, categorized list of HTML elements. CSS Properties Reference 8.4.2.7 Generators CSS3 Generator - Generate CSS box shadows, text shadows, and gradients. Ultimate CSS Gradient Generator 8.4.2.8 Colors Defining colors in CSS Duo — Curated color pairings Adobe Color - Generate complementary colors. 8.4.3 Quick links to assets BootstrapCDN helpfully host bootstrap.css (and Bootswatches) on their own server. Ultimately, a quick and easy way to get all of Bootstrap and Font Awesome is to include the following in the &lt;head&gt; of your document: &lt;!-- Expand the number of characters we can use in the document beyond basic ASCII  --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- Make it responsive --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- Connect Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!-- Connect Bootstrap JavaScript and its dependencies --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;!-- Connect Font Awesome --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js&quot;&gt;&lt;/script&gt; You can use a Bootswatch or your own customized bootstrap.css instead as the href, if you like. Have fun! "],["linkinbio.html", "9 Linkinbio", " 9 Linkinbio Notes: No video for this, only chapter Project (graded, submit a link): https://github.com/appdev-projects/linkinbio Target: https://rag.hu/04-layout Useful chapters copied in below: linkinbio.md Some social media apps, in particular Instagram, do not allow you to include links to other pages in posts. The only place you can include a URL is in your bio, and you can only include one. This soon led to a trend of people promoting something with a post, but including “Link in bio!” in the caption. They would then update the solitary link in their bio to the latest thing they wanted to promote. Soon, a bunch of services cropped up that allow people to manage multiple links in a single, mobile-friendly page; and include a link to that page in their bio. The most popular of these is Linktree, but there are many others. Linktree has many users, from media companies to celebrities to, most likely, some of your friends — and maybe even you? Here are some examples: HBO’s Instagram bio: And HBO’s list of links: Katy Perry’s Instagram bio: And Katy Perry’s list of links: In this project, we’re going to build our own mobile-friendly list of links that we can include in our social media profiles or anywhere else that we like. Here’s mine: There are several benefits to writing our own rather than using a service like Linktree: We can use our own custom domain name for it; rather than linktree.com/raghubetina, notice that my URL is simply rag.hu. We don’t have to pay. Linktree has a free tier with limited design options, but if you want access to the fun themes, analytics, or to remove the Linktree branding, you have to subscribe to their $5/mo or $9/mo plan. We have all the power of CSS at our fingerprints to customize the design. Linktree, like all “no code” tools, limits you to a set of pre-defined constraints that you have to work within. Not so if you’re writing the code yourself. For example, if you click through to mine, you’ll notice a lot of touches that aren’t available options even on the paid Linktree plans: an animated background, a “frosted glass” effect on the links, etc. It’s just plain fun! Let’s get started. "],["getting-started.html", "9.1 Getting started", " 9.1 Getting started We’re going to start our projects a little differently this time. Rather than clicking the “Load [assignment] in a new window” button in Canvas, which usually will automatically create your copy of the repository on your organization, you will manually create your own blank Rails app (the same steps you can follow any time you want to build your own, non-assigned projects): Visit our appdev-projects/base-rails repository and click the “Use this template” button. Then select “Create new repository” from the dropdown. On the next screen, leave the “Owner” dropdown alone. For “Repository name”, enter “your-username.github.io”. Substitute your own, real username for your-username. So, for example, my repo name is “raghubetina.github.io”. Make sure to include the “.github.io” part in the repo name. E.g.: Click “Create new repository from template”. Create a new Gitpod workspace based on your brand new repository: In a new tab’s address bar, type “gitpod.io/#”. Then copy-paste the URL of your new repository after that. The URL should look something like gitpod.io/#https://github.com/your-username/your-username.github.io Press return to visit that URL and Gitpod will automatically start creating a new workspace for you. Once you’re in to your new workspace, bin/server at a terminal tab as usual to start up your web server. Open your app preview in a new tab. Create a file called index.html in the public/ folder. Add “hello, world” and make sure that it shows up when you refresh your app preview. "],["first-things-first-the-content.html", "9.2 First things first — the content", " 9.2 First things first — the content To start with, we need content. You’ll probably want to gather: A profile picture for the top of the page. This doesn’t have to be an image of you; it can be anything. Unsplash is a great resource for high quality stock images if you don’t want to use an image of yourself. The URLs of your social media profiles. I used my GitHub, LinkedIn, Instagram, and Twitter pages. A list of links you want to share. I used a handful of essays and short stories that I find myself sharing with people often. Here are some examples that you can peruse for inspiration. A thumbnail image for each link. I used a few strategies to find an image for each link: Search Google images and look for one hosted on wikimedia.org. Searched Unsplash for a relevant image. Generate an image with AI. I downloaded the image and then uploaded it to my Gitpod workspace by drag-and-dropping it into the public/ folder. If you want to, you can use fake placeholder images and links for everything, but I encourage you to gather real content. It’ll be more fun, you’ll end up with a page that you can actually use on your social media profiles, and you’ll have a good piece for your portfolio. "],["basic-html-structure.html", "9.3 Basic HTML Structure", " 9.3 Basic HTML Structure Let’s add our images, copy, and links. I wrapped each block of content in a &lt;div&gt; for now, to create some separation. I also gave each &lt;div&gt; a class=\"\" attribute; since we haven’t written any CSS yet, they don’t do anything, but they help me remember what each &lt;div&gt; represents. Something like this: &lt;div class=&quot;banner&quot;&gt; &lt;img src=&quot;profile-pic.jpg&quot; alt=&quot;Raghu Betina headshot&quot;&gt; &lt;/div&gt; &lt;div class=&quot;name&quot;&gt; Raghu Betina &lt;/div&gt; &lt;div class=&quot;social-icons&quot;&gt; &lt;a href=&quot;https://github.com/raghubetina&quot; target=&quot;_blank&quot;&gt; GitHub &lt;/a&gt; &lt;a href=&quot;https://www.linkedin.com/in/raghubetina/&quot; target=&quot;_blank&quot;&gt; LinkedIn &lt;/a&gt; &lt;a href=&quot;https://www.instagram.com/raghubetina/&quot; target=&quot;_blank&quot;&gt; Instagram &lt;/a&gt; &lt;a href=&quot;https://twitter.com/raghubetina&quot; target=&quot;_blank&quot;&gt; Twitter &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;https://www.ycombinator.com/assets/ycdc/yc-og-image-0cfa80cac837d64d9b4f0705950000b66906ac032791376bd721f246fafcc7b4.png&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://paulgraham.com/startupideas.html&quot;&gt;How to Get Startup Ideas — Paul Graham&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;/thumbnails/typography.jpg&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://practicaltypography.com/typography-in-ten-minutes.html&quot;&gt;Typography in ten minutes — Matthew Butterick&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;https://media.newyorker.com/photos/59096d451c7a8e33fb38e4ca/16:9/w_1280,c_limit/071210_r16884_p646.jpg&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://www.newyorker.com/magazine/2007/12/10/the-checklist/&quot;&gt;A Life-Saving Checklist — The New Yorker&lt;/a&gt; &lt;/div&gt; &lt;!-- Etc, for as many links as you want --&gt; Of course, I also have the standard HTML boilerplate (&lt;html&gt;, &lt;head&gt;, &lt;body, etc) in order to make it a valid document. Two things to notice: I’m using the target=\"_blank\" attribute on any links that I want to open in a new tab. For images that I am serving from my own public/ folder: I created a subfolder called thumbnails to help keep things organized, and moved the images there. When referencing the URL of the image in a src=\"\" attribute, I start with a leading slash — e.g.: &lt;img src=&quot;/thumbnails/typography.jpg&quot;&gt; I do not include /public in the URL. At this stage, your page technically serves its purpose — a collection of links people can click on — but it probably looks terrible, like this. "],["html-validator.html", "9.4 HTML Validator", " 9.4 HTML Validator If at any point your HTML breaks, or you suspect you e.g. forgot a closing tag but can’t find it, the W3C HTML Validator might come in handy. Paste in your entire HTML document and click “Check”, and it will give you a list of feedback. Some of them are yellow warnings and can be safely ignored for now, but any critical mistakes (like missing closing tags or quotation marks) will show up as red errors. For example, if you run your HTML through the validator right now (try it), it will display a bunch of errors because we don’t have alt=\"\" attributes on our &lt;img&gt;s. These are important to include for accessibility reasons, and just in case the image breaks for some reason (i.e. the URL changes). We should add descriptive alternative text for each image. "],["view-source.html", "9.5 View Source", " 9.5 View Source You should try to type out your page yourself — avoid copy-pasting. Making mistakes, fixing them, and developing your own muscle memory is important. That said, after you’ve attempted it yourself, you can View Source (Windows: Ctrl+U or Mac: Command+Option+U) on any of my example intermediate pages to see my code. "],["sizing-images.html", "9.6 Sizing images", " 9.6 Sizing images Now, let’s start to make the page look better. Let’s add a &lt;style&gt; element inside the &lt;head&gt; of the document so that we can begin applying CSS. We won’t use an external stylesheet for now, since we’re only planning to apply this CSS to a single page. Maybe we can start by giving the body some breathing room with top and bottom padding: &lt;style&gt; body { padding-top: 40px; padding-bottom: 40px; } &lt;/style&gt; Let’s start by sizing the profile picture. We need to give it a class so that we can apply CSS rules to it — let’s call it banner-image: &lt;div class=&quot;banner&quot;&gt; &lt;img src=&quot;profile-pic.jpg&quot; alt=&quot;Raghu Betina headshot&quot; class=&quot;banner-image&quot;&gt; &lt;/div&gt; Then, let’s make the banner image 128 pixels by 128 pixels: &lt;style&gt; .banner-image { width: 128px; height: 128px; } &lt;/style&gt; Unless your original image was exactly square, this probably will look squished when you check out the results. To solve this problem, we can use the object-fit property: .banner-image { width: 128px; height: 128px; object-fit: cover; } It’s quite common to see circular profile pictures. If you want to, set a large border-radius to achieve that: .banner-image { width: 128px; height: 128px; object-fit: cover; border-radius: 128px; } I didn’t use one on my profile picture, but you should feel free to get creative with borders, as well. Similarly, let’s size all of the thumbnail images as 48px by 48px: .thumbnail { width: 48px; height: 48px; border-radius: 48px; object-fit: cover; } Don’t forget to add the class to the relevant &lt;img&gt; elements. Now, your page should look something like this — much better. "],["basic-colors.html", "9.7 Basic colors", " 9.7 Basic colors Let’s add some color to make it easier to see how much space each element is occupying. We’ll, at a minimum, need a color for the background of the entire page and for each link. You can come up with your own palette, or you can use Happy Hues, a nice set of curated color palettes. I used this palette. I used the background color, headline color, button color, and button text color like this: body { background-color: #004643; } .name { color: #fffffe; } .social-icons a { color: #fffffe; text-decoration: none; } .link { background-color: #f9bc60; } .link a { color: #001e1d; text-decoration: none; } As you can see, I also removed the underlines from links with text-decoration: none. Notice that I used the descendant combinator: .link a { /* ... */ } This selector targets only &lt;a&gt; elements that are descendants of elements with class link. This is a handy alternative to adding a new class to all of the elements I’m interested in targeting.4 My page now looks like this. If you want to become a pro at writing CSS selectors, I recommend an interactive tutorial/game called CSS Diner. If you make it through all 32 levels, you’ll be better than most front-end developers at writing advanced CSS selectors. In addition to making it easier to style your own pages, knowing how to write advanced selectors will pay dividends if you’re interested in doing any web scraping.↩︎ "],["layout.html", "9.8 Layout", " 9.8 Layout Now, for the interesting part — laying out the elements where we want them on the page. 9.8.1 Overall page layout Since this is a relatively simple, single-column layout, we could stay in the normal flow mode and achieve most of the positioning that we want with margin and padding. But let’s use display: flex instead. It will make it much easier to do things like vertically center the text within each link’s box. First, I’ll wrap all of our content — the div.banner, the div.name, the div.social-icons, and all of the div.links — within a new parent &lt;div&gt; with a class called items. This will make it easier for me to position and size everything uniformly. Then I will switch the layout mode of the new div.items from the default normal flow to flex: .items { display: flex; } If you try that and refresh your page, you’ll see that all of the elements are now horizontally side-by-side. This is because the default flex-direction is row. Let’s switch the flex-direction to column to lay them out vertically again: .items { display: flex; flex-direction: column; } If you refresh, you’ll see the layout is vertical again. When we’re using display: flex mode, we can use the gap property to provide some breathing room between each child element, rather than having to add margin: .items { display: flex; flex-direction: column; gap: 30px; } On laptop screens, the buttons are running all the way to the edge of the screen, which isn’t very attractive. Let’s set a max-width of around 640px (you choose a value that looks good to you): .items { display: flex; flex-direction: column; gap: 30px; max-width: 640px; } 9.8.2 Layout for each link Within each link, it would be nice if: The thumbnail and text were vertically centered within the box. The text was horizontally centered in the space remaining next to the thumbnail. display: flex to the rescue! 9.8.2.1 Vertically centering with align-items We can vertically center child elements with the align-items property: .link { background-color: #f9bc60; display: flex; align-items: center; } If you refresh, the thumbnails should be lined up nicely with the link text. 9.8.2.2 flex-grow Next, let’s center the text of each link. I’m going to expand the existing rule that we have for .link a. Can we simply add text-align: center and call it a day? .link a { color: #001e1d; text-decoration: none; text-align: center; } If you refresh, you’ll see that didn’t work. Why? To make it easier to see things while I am working on layouts, I often use the following hack: * { border: thin red solid; } This puts a thin red border around every element. Your page should now look something like this: We can see that the &lt;a&gt; elements are only just wide enough to fit their content, so centering within them isn’t doing anything. Instead, we want the &lt;a&gt; element to occupy all of the available space to the right of the thumbnail. To achieve, this we can use the flex-grow property: .link a { color: #001e1d; text-decoration: none; text-align: center; flex-grow: 1; } Now the &lt;a&gt; element grows to fill any available space, while the &lt;img&gt; element stays the same size (it still has the default value for flex-grow, which is 0). And our text should be nicely centered since we already added the text-align. 9.8.2.3 justify-content Now let’s take care of centering the profile picture and name, as well as putting some breathing room between the social links. Flexbox has a wonderful property called justify-content that will help with all of these things: .name { color: #fffffe; display: flex; justify-content: center; } .banner { display: flex; justify-content: center; } .social-icons { display: flex; justify-content: space-around; } You could also use the same technique to center the div.items within the &lt;body&gt;: body { display: flex; justify-content: center; } But then we again need to tell the child elements to grow to take up all available space with flex-grow: .items { display: flex; flex-direction: column; gap: 30px; max-width: 640px; flex-grow: 1; } Our page layout should now look solid! Let’s add a little bit of padding inside our div.links: .link { background-color: #f9bc60; display: flex; align-items: center; padding: 5px; } It should now be safe to remove the * { border: thin red solid; } hack, unless you want to continue playing with layout, padding, etc. Our page now looks something like this. "],["deploy.html", "9.9 Deploy!", " 9.9 Deploy! We’ve made a lot of progress, and our list of links is functional and looking pretty solid! We can and will spend more time fine-tuning, but this seems like a great time to deploy our app to industrial-grade hosting so that we can actually link to it in our bios! Sadly, after over a decade, Heroku’s free tier was eliminated as of November 28th, 2022. There are some silver linings — they have launched a new discount through GitHub Student, and they created a couple of new, less expensive plans (Eco, Basic, Mini). For full-stack, dynamic, interactive, database-backed apps, I plan to still use Heroku. However, Heroku is no longer a good choice for hosting static HTML websites. There are several other free and fast options for that (e.g. Netlify and Vercel). Today, I want to show you GitHub’s offering for hosting static websites: GitHub Pages. We will deploy our Link In Bio via GitHub Pages. This will have several benefits: It’s free. It is tightly integrated with GitHub repositories (obviously), so all we need to do to deploy is what we do anyway — make a commit and push to GitHub . It doesn’t have any of Heroku’s old free tier’s restrictions. It will be up 24/7/365. It automatically includes SSL for custom domains (important if you’re using a top-level domain that requires https, like .dev). GitHub Pages sites are automatically assigned a subdomain under .github.io. This carries some developer cred. Or you can easily use your own domain. Here’s what to do to get your first GitHub Pages site going: Visit /git. Make a commit and then push the changes you’ve made so far to your GitHub repository. That’s it! In a few minutes, your site should be live at https://your-username.github.io! Eventually, consider adding some other pages to your site besides just index.html — a list of projects that you’ve built, for example. If you want to use a custom domain name like yourname.com rather than something like your-username.github.io, then you’ll first have to purchase a domain. I recommend Porkbun, or, for more exotic top-level domains, Gandi.net. Here is a guide to adding your own domain to your Pages site. Let me know if you get stuck. You can create as many GitHub Pages sites as you want — one per repo. Read more about GitHub Pages here. "],["this-is-the-end-of-the-required-portion.html", "9.10 This is the end of the required portion", " 9.10 This is the end of the required portion This is the end of the required portion of this assignment. In Canvas, submit the URL of your deployed app (something.github.io, not your GitPod preview). If you are willing to share your creation, please also include “Add me to the showcase” in the submission text area. "],["make-it-your-own.html", "9.11 Make it your own", " 9.11 Make it your own Now that we have the basics up and running, it’s time for you to get creative and make it your own! You can continue to make changes, commit, and push them to deploy. We aren’t grading for anything particular, so just have fun with it. Here are a bunch of resources for you to explore: 9.11.1 Fun design resources The following are a collection of neat tools that will help you create interesting backgrounds, generate gradients and shadows, find font pairings, etc. Glance at each one and pick one or two to integrate into your design. If you want to bounce ideas on things you can integrate, chat with an instructor. Once you’ve picked something to add, try to figure out how to integrate it on your own; ask lots of questions when you get stuck. 9.11.1.1 Icons To use Font Awesome icons (for example, for your LinkedIn/GitHub/Twitter/etc links), first include this in the &lt;head&gt; of your document: &lt;!-- Connect Font Awesome --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js&quot;&gt;&lt;/script&gt; Then peruse the icon list and copy-paste the code examples into your HTML. 9.11.1.2 Fonts The Ultimate Collection of Google Font Pairings (Displayed Beautifully with Classic Art) Reading: Typography in Ten Minutes 9.11.1.3 Images Unsplash: Search engine for free stock images. Dezgo: AI image generation. Image Optimizer: Reduce your images’ filesize in case they’re taking too long to load. Clippy: Create geometric masks for your images. 9.11.1.4 Color palettes Happy Hues 9.11.1.5 Shadow generators CSS Shadow Palette Generator 9.11.1.6 Gradient generators Vivid Gradient Generator Easing Gradients 9.11.1.7 Patterns CSS Background Patterns Repper Pocoloco 9.11.1.8 Generative art Silk Haikei Tabbied 9.11.1.9 Filters https://css-tricks.com/almanac/properties/b/backdrop-filter/ https://css-tricks.com/almanac/properties/f/filter/ 9.11.2 Always be committing Be sure to make lots of git commits along the way as you work! Have fun ☺️ "],["intro-to-ruby.html", "10 Intro to Ruby", " 10 Intro to Ruby Notes: These are all the pre-class Ruby homework assignments consisting of a reading with Replits, potentially followed by a GitPod exercise. The chapter and project repository is listed in each sub-section. The README from the project repository needs to be integrated here. There is an un-transcribed video associated with String that serves as review of the Technical Setup. Useful chapters: the-one-reference.md "],["nouns-verbs-and-grammar.html", "10.1 Nouns, Verbs, and Grammar", " 10.1 Nouns, Verbs, and Grammar Notes: nouns-verbs-and-grammar.md "],["program-notes.html", "10.2 Program Notes", " 10.2 Program Notes Notes: program-notes.md "],["string.html", "10.3 String", " 10.3 String Notes: string.md setup video Project: https://github.com/appdev-projects/string-chapter "],["integer.html", "10.4 Integer", " 10.4 Integer Notes: integer.md Project: https://github.com/appdev-projects/integer-chapter "],["float.html", "10.5 Float", " 10.5 Float Notes: float.md Project: https://github.com/appdev-projects/float-chapter more-on-floats.md "],["date.html", "10.6 Date", " 10.6 Date Notes: date.md Project: https://github.com/appdev-projects/date-chapter "],["array.html", "10.7 Array", " 10.7 Array Notes: array.md Project: https://github.com/appdev-projects/array-chapter "],["conditionals.html", "10.8 Conditionals", " 10.8 Conditionals Notes: conditionals.md Project: https://github.com/appdev-projects/if-statements-chapter "],["loops.html", "10.9 Loops", " 10.9 Loops Notes: loops.md Project: https://github.com/appdev-projects/loops-chapter "],["each.html", "10.10 Each", " 10.10 Each Notes: each.md Project: https://github.com/appdev-projects/each-chapter "],["hash.html", "10.11 Hash", " 10.11 Hash Notes: hash.md Project: https://github.com/appdev-projects/hash-chapter "],["our-own-classes.html", "10.12 Our own classes", " 10.12 Our own classes Notes: our-own-classes.md Project: https://github.com/appdev-projects/our-own-classes-chapter "],["ruby-gym.html", "11 Ruby Gym", " 11 Ruby Gym Notes: Un-transcribed Day 3 recording contains the following Ruby Foundations Slides: 01-06: Basic recap Here is the Google-Fu Note Ruby Foundations Slides: 07-08: We Are Inventors, Google-Fu Project (graded): https://checkins.firstdraft.com/exercises/1/student Useful chapters: the-one-reference.md "],["optional-ruby-practice.html", "11.1 Optional Ruby Practice", " 11.1 Optional Ruby Practice Notes: See Canvas, links to Treehouse and CodeCademy "],["rock-paper-scissors-rcav.html", "12 Rock, Paper, Scissors RCAV", " 12 Rock, Paper, Scissors RCAV Notes: Original video transcription is in adding-routes-RPS-RCAV.md Project (graded): https://github.com/appdev-projects/rps-rcav Target: https://rps-rcav.matchthetarget.com Useful chapters: adding-routes.md rcav-flowchart.md, not actually zipped in here yet Routing - RCAV Slides "],["video-segment-dynamic-web-applications-and-urls.html", "12.1 Video Segment: Dynamic Web Applications and URLs", " 12.1 Video Segment: Dynamic Web Applications and URLs Notes: time stamp 00:00:00 to 00:03:30 request lifecycle of Route, Controller, Action, View web interface and URLs actions render and redirect We have worked hard and learned HTML, CSS, and Ruby. We’re now especially proficient in writing Ruby programs, especially with the aid of gems and APIs. BENP: have we discussed gems and APIs up to this point though? However, if we (the developers) are the only ones that can run these programs (from the command line through the ruby interpreter), then they aren’t much use. It’s time to start adding a web interface on top of our Ruby programs so that external users can interact with and benefit from them. We already have all the tools to build our first dynamic web application. BENP: need to clearly define RCAV early in any video or document now so we aren’t left wondering, added next sentence. Before we begin building, we need to understand the URL request lifecycle of Route, Controller, Action, View (RCAV). Let’s recall that Software as a Service (SaaS) has eaten the world. What does this mean? For an application that runs on a server and transmits information across the internet, the interface consists of a set of URLs that a user can visit. People can type in a URL, click a link, or submit a form, and then get back some information relevant and valuable to them. Each URL will either display a page with some information (“get” in HTTP terminology) trigger the storing of some information (“post” in HTTP terminology) trigger the deleting of some information (“delete” in HTTP terminology) trigger the updating of some information (“patch” in HTTP terminology) forward to another URL or some combination of the above Our goal was to demistify what happens between the user action and the return of information. Now we have the vocabulary to talk about this. The world turns around the humble Uniform Resource Locator, or URL. Most obviously, the user might be visiting the URLs in their browser by typing into the address bar or clicking on links. Or, more and more commonly, users might be visiting from native iPhone or Android apps without even knowing that, behind the scenes, they are visiting URLs to store and retrieve the information they need. When somebody puts that URL into the address bar, and something happens between the URL and the page being rendered, we now can say what that is. When a user visits a URL, they are actually triggering a specific Ruby method. But make no mistake: if there is information being stored in a central database, then there’s a web server running somewhere and URLs are being visited with each action a user takes. In the background somewhere, there is an object and method and somebody is saying Something.something, and that method is actually going to do the work of drawing the correct page of information with exactly the right information for that user and outputting it in the right format (almost alway HTML). So our job is to write those Ruby methods (called “actions”) and allow users to trigger those methods when they visit each URL. So we can write any Ruby we want in those action methods. We can generate random numbers, read from APIs, calculate things, send text messages, and more. But every action must do one of two things: Render a response, by sending back some HTML and displaying a new page Redirect, or forward the user onward to another URL. And that’s everything that happens between the user visiting a URL and getting a response, and it is now a complete Route + Controller + Action + Response request lifecycle. We map every URL to one Ruby method that we write in advance and then we wire everything together so that Rails will listen for user visits and when someone visits a particular URL, then Rails will call the method we prepared that will handle getting the database information and wrapping it in bootstrapped markup and sending the HTML to the user’s browser. You can fully specify a web application by listing out the URLs that users can visit, and what happens when each URL is visited. For example, let’s say we wanted to build an interactive game of Rock, Paper, Scissors. The complete specifications (or specs, for short) for this app might look like this: http://[OUR APP DOMAIN]/rock — Should display “You played rock.”, a random move by the computer, and the outcome. http://[OUR APP DOMAIN]/paper — Should display “You played paper.”, a random move by the computer, and the outcome. http://[OUR APP DOMAIN]/scissors — Should display “You played scissors.”, a random move by the computer, and the outcome . http://[OUR APP DOMAIN]/ — A welcome page that displays “Happy Monday!” (or whatever day it is). The rules of the game. For example, Happy Tuesday! Rock beats Scissors, Paper beats Rock, Scissors beats Paper. Point your browser at /rock, /paper, or /scissors to play the game. Now — how do we get our web server to perform the above tasks when users visit the above URLs? 12.1.1 Potential Quiz Question First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option This is not correct because of xyz reason {: .choose_best #bin points=“30” answer=“3” } 12.1.2 Text Companion: Dynamic Web Applications and URLs "],["video-segment-route.html", "12.2 Video Segment: Route", " 12.2 Video Segment: Route Notes: time stamp 00:03:30 to 00:07:10 all about routing and config/routes.rb get() The key thing is routes. Routes are how to connect a URL to an action. The very important file config/routes.rb contains all of our routes. This is a list of everything our application can do. We’re moving out of our public/ and tasks/ folder, and using more of our Rails application, by working in the app/ folder, where most of our code goes, and with this one file routes.rb that is in the config/ folder. The super important config/routes.rb file included in every Rails app says all the URLs (routes) that a user can visit and when someone visits the URL we say which class and which method Rails should execute to handle the request. Here is an example of a route: # config/routes.rb self.get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) The method here is get5 and there are parentheses for its two arguments: - The first argument to get is a String: the path that we want users to be able to visit (the path is the portion of the URL that comes after the domain name). Here it is \"/rock\" - The second argument to get is a Hash: this is where we tell Rails which method to call when a user visits the path in the first argument. (We’ll have to actually write this method in the next step, after we write the route.) The `Hash` must have two key/value pairs: - `:controller`: The value for this key is what we&#39;re going to name the _class_ that contains the method we want Rails to call when the user visits the path. For now we&#39;re going to default this value to `&quot;application&quot;` — you&#39;ll see why in a minute. - `:action`: The value for this key is the what we&#39;re going to name the method itself. &quot;Action&quot; is the term used to refer to Ruby methods that are triggered by users visiting URLs. - The `Hash` is saying: &quot;Use a `Class` (controller) called `application_controller`, and in that `Class` use a `method` (action) called `play_rock` to generate a response for the user.&quot; Don’t be confused by the key names :controller and :action, these are equivalent to a Ruby Class and method. They just have special names in the lingo of web applications. The get method is inherited, we don’t need to build this method ourselves, which saves us a lot of time. We get the plumbing for free and we just need to tell Rails how we want each request to be handled by declaring our routes. 12.2.1 Text Companion: Route Later we’ll use other methods, post(), etc, if we want to support requests using the other HTTP verbs.↩︎ "],["video-segment-controller-action-view.html", "12.3 Video Segment: Controller, Action, View", " 12.3 Video Segment: Controller, Action, View Notes: time stamp 00:07:10 to 00:08:30 all about app/controllers/ ApplicationController inheritance All of our controller classes will be in the app/controllers/ folder. There’s already one controller that comes with every Rails app out-of-the-box: ApplicationController, found in app/controllers/application_controller.rb. This is the controller that the above route is referring to. We will just use this controller for now. Later we will make separate controllers to keep our code organized. An example of an action looks like this: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def play_rock self.redirect_to(&quot;https://www.wikipedia.org&quot;) end end We get the first line class definition for “free”: class ApplicationController &lt; ActionController::Base It comes with Rails. It inherits &lt; from the Base class which is inside the Rails gem, so we would need to go into the Rails gem on GitHub to actually look at it. BENP: gem has maybe not be defined or discussed yet. possible footnote here. Also this is our first time talking about inheritence, so may need some expansion Then we define a method: def play_rock And inside of that we could write whatever steps we want (like calls to GoogleMaps or weather services from DarkSky BENP: I don’t think either of these have been presented at this point in the class). At the end of the day, the job of an action is to send back a response to the user. A response can be either: Rendering some data, in any one of many formats: Plain text. JSON for an application to consume — we’ve seen JSON before (in APIs), and consumed it ourselves with our Ruby scripts. HTML for their browser to draw — we’ll learn this soon. Less commonly, any other format: CSV, PDF, XML, etc. Or, the action can forward the user to another URL. This is known as redirecting. We get a method for each of these two: render for the first, and redirect_to for the second. In this case, we redirect to another URL: self.redirect_to(&quot;https://www.wikipedia.org&quot;) As you can see, the argument to redirect_to is a String which contains some URL that you want the user to simply be forwarded to. This will come in handy later when, for example, we want to send the user directly back to a list of all photos after they’ve deleted a photo. 12.3.1 Text Companion: Controller, Action, View "],["video-segment-dropping-self..html", "12.4 Video Segment: Dropping self.", " 12.4 Video Segment: Dropping self. Notes: time stamp 00:08:30 to 00:11:00 why we drop self. Just to get something out of the way: Usually we always call object.method, and we are using the self keyword above because we are calling these methods on the instance of the class (ApplicationController) that we are defining the method (play_rock) for. Kind of like when we learned about the Person class and there is first_name and last_name, and if we wanted a full_name method we called self.first_name + self.last_name. In this case we’re defining play_rock and we want use the method redirect which already exists on ApplicationController, since it’s inherited via &lt; ActionController::Base. The point is, we are using a method that already exists to build our new method, hence self.redirect_to. In Ruby, when you’re calling a method on self, you can drop the self., and Ruby will figure it out, so we can rewrite the route, controller, action steps to: # config/routes.rb get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) {: mark_lines=“3” } and # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def play_rock redirect_to(&quot;https://www.wikipedia.org&quot;) end end {: mark_lines=“5” } 12.4.1 Text Companion: Dropping .self "],["video-segment-starting-our-gitpod-workspace.html", "12.5 Video Segment: Starting Our GitPod Workspace", " 12.5 Video Segment: Starting Our GitPod Workspace Notes: time stamp 00:11:00 to 00:13:30 these are common steps that should be done first in any project maybe link to Technical Setup Let’s spin up a workspace and open the RPS-RCAV GitPod so we can visualize the steps and see some results. We’ll finally make our Rock Paper Scissors game work, by having the computer opponent randomly choose a move rather than always playing paper. We will then be able to compute outcomes based on the computer’s move. Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project here, looks similar to what we have produced, but the key is that the computer plays different moves, and the application is finally dynamic. So how do we get here? 12.5.1 Text Companion: Starting Our GitPod Workspace "],["video-segment-our-first-rcav.html", "12.6 Video Segment: Our First RCAV", " 12.6 Video Segment: Our First RCAV Notes: time stamp 00:13:30 to 00:18:40 debugging an RCAV for /rock RTEM ends with redirect_to Our workflow for a dynamic web application is always the same: Route, Controller, Action, View (RCAV). Remember, the world is ruled by URLs. So we will always start with what URL we want to build and get it to work. If we begin by navigating to the route /rock in our Rails browser: http://[YOUR APP DOMAIN]/rock, then we get an error message: No route matches [GET] “/rock”. We need to Read The Error Message (RTEM) and define the first route that will allow us to support a request of the form for our users. Let’s open the file config/routes.rb and define the route by adding the following code: # config/routes.rb Rails.application.routes.draw do get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) end {: mark_lines=“5” } (All of our routes must be contained within the block following Rails.application.routes.draw. A new Rails app will already come with this code pre-written in routes.rb.) Again, we have our route \"/rock\" and our key/value pairs for the :controller (or Class) and :action (or method). We need to choose values for the :controller that Rails will use and the :action within the controller that will be called. For now we are just using the app/controllers/application_controller.rb for the controller, and we will define our action play_rock in there. We now need to open app/controllers/application_controller.rb to add some code. Note that Rails is smart and will add _controller.rb to our :controller argument in get, and within that controller file you will see the class has the underscores removed and is capitalized as ApplicationController. These are helpful conventions, and are best followed. BENP: is that last thing a fair statment? In this file we will add the following: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock end end {: mark_lines=“9-10”} We need our action to exactly match what we wrote in the config/routes.rb file, here play_rock. Between the def play_rock and end that we added, we could put whatever and however much code we would like to execute in that action for the user. In the end we will need to either render some HTML back to the user or redirect the user to another place. Let’s begin by just redirecting to some other URL: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here redirect_to(&quot;https://www.wikipedia.org&quot;) end end {: mark_lines=“10-12”} And we just created a full RCAV request lifecycle. If we go back to the browser and refresh the URL: http://[YOUR APP DOMAIN]/rock, then we will end up on Wikipedia. If I go back to GitPod and look in my server log (use Cmd + J to open and close the log, Cmd + K to clear the log), then I will see something like: We can see exactly what happened. Someone tried to GET \"/rock\" from a given IP address at a given time, we found a route with instructions to use ApplicationController#play_rock (where the Something#something is Ruby shorthand for Class.method, with the . exchanged for a #), calling this controller-action pair resulted in a redirect to the given URL (https://www.wikipedia.org), and the entire request lifecycle completed in the stated time with no errors. 12.6.1 Text Companion: Our First RCAV "],["video-segment-render-html.html", "12.7 Video Segment: Render HTML", " 12.7 Video Segment: Render HTML Notes: time stamp 00:18:40 to 00:26:38 from render({ :plain =&gt; \"Hello, world!\" }) to render({ :template =&gt; \"game_templates/user_rock.html.erb\" }) .html vs. .html.erb app/views/ view templates rather than public/ We’ve written our first functional action, which just forwards someone to a new page. Now let’s try to render some of our own HTML, rather than redirecting to Wikipedia. We can change the previous code in app/controllers/application_controller.rb to: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :plain =&gt; &quot;Hello, world!&quot; }) end end {: mark_lines=“12-14”} Rather than using redirect_to(), which we inherited &lt; from the Rails Base class, we’ll use another inherited method to complete the request lifecycle: render(). This method, takes a Hash as an argument with a key/value pair. The key has many options, here we will use :plain, which will just send back plain text. A boring response, but good to start with. Now if I pretend I’m a user and visit http://[YOUR APP DOMAIN]/rock, then I get a page with my \"Hello, world!\" rendered. Congratulations! You’ve wired up a route; prepare to do it a million more times, because all developers do all day is pick the next spec , wire up the route for the URL so that a user can visit it, and then implement the logic to send back the correct information. Remember, we did not create and send a file, we are using Ruby to generate this reponse, opening a world of possibilities. For instance, what if we instead rendered a random number: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :plain =&gt; rand(100) }) end end {: mark_lines=“14”} Now everytime we refresh http://[YOUR APP DOMAIN]/rock, we get a different random number, generated automatically by Ruby. This is a dynamic response, not just a static page that we placed in the public folder. This is a simple example, but fundamentally that’s it. We connected a URL to a method that can do anything. It can call APIs, parse CSVs, compute whatever you want, run machine learning models. With this we can do anything. Of course, there is a lot more to learn, but fundamentally this is it. Now let’s send back some actual HTML: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) end end {: mark_lines=“14”} The :html key to render() allows us to place whatever HTML we want in a string that will be shown on the page. We need the .html_safe on the end of the string, which is a bit of Rails security to make sure that one user can’t inject malicious HTML into another user’s browser, in case we were getting the given HTML string from another user (e.g., from a &lt;form&gt;). Don’t worry about this, we will see a better way of doing this in a moment. If we refresh http://[YOUR APP DOMAIN]/rock, then we will see our HTML. We could go crazy and put our entire HTML document in that string. But a much, much better way to to write what’s called an embedded Ruby template. # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end end {: mark_lines=“16”} The :template key to render() allows us to assign a template to render. We specify the name of a folder game_templates/ and file user_rock.html.erb that will contain all of our HTML. This is an .erb for embedded Ruby template file, rather than a plain old .html file. We create this file in the existing app/views/ folder, which is a way better place than public/, because users do not have access to all of its contents. We will keep things organized and put different templates in different sub-folders. Do not put the .html.erb file in the app/views/layouts/ folder that already exists, first make a new folder in app/views/ called game_templates/ then make the new file in this folder called user_rock.html.erb. BENP: insert image(s) (gifs? would be better here; cf. video 00:25:20) of new folder and new file steps in GitPod You can call the game_templates/user_rock.html.erb folder and file whatever you want. The user will not see the folder or the file, they will only see \"/rock\", the specified route. Now you can enter in your new user_rock.html.erb file some HTML to render: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; Don’t forget to save the file changes if you haven’t done so. And now when we refresh http://[YOUR APP DOMAIN]/rock, we get the text from our file rendered in HTML. So after all of that we have an HTML page that basically does what we could have done quickly if we made a file called rock.html in the public/ folder. 12.7.1 Text Companion: Render HTML "],["video-segment-embedded-ruby-tags.html", "12.8 Video Segment: Embedded Ruby Tags", " 12.8 Video Segment: Embedded Ruby Tags Notes: time stamp 00:26:38 to 00:31:37 all about &lt;% %&gt; and &lt;%= %&gt; in a view template But we can do something way better with this new system. Let’s add the following to our embedded Ruby file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;h2&gt; They played &lt;%= %&gt;! &lt;/h2&gt; {: mark_lines=“5-7”} Now we created a new tag that looks like HTML, but contains a doorway to Ruby: &lt;%= %&gt;. We can write any Ruby we want in that embedded Ruby tag, and this is what makes the whole effort of RCAV worthwhile. For instance we can write: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;h2&gt; They played &lt;%= 6 * 7 %&gt;! &lt;/h2&gt; {: mark_lines=“6”} And we will see the result of this computation when we refresh http://[YOUR APP DOMAIN]/rock. But if we go to view source in the browser, we won’t see the Ruby code. We only see the result 42. The browser only understands HTML and has no idea of the code that allows us to make the web application dynamic. So rails is processing all of the embedded Ruby tags and injecting them in the document before it sends the plain HTML file to the browser. We could also do something like &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= 6 * 7 %&gt;! &lt;/h2&gt; {: mark_lines=“5”} Here, we used a slightly different embedded Ruby tag: &lt;% %&gt;. We left off the = sign, which means the output of this Ruby code will be hidden in the final HTML. But, the variable comp_move (which is the result of randomly sampling an array of three possble string values) is still available and we can render it by changing the file again: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; {: mark_lines=“8”} Such that our calculated variable comp_move is now rendered in the final HTML output, because it is in a &lt;%= %&gt; tag, with the = sign. And we will see the result of this computation when we refresh http://[YOUR APP DOMAIN]/rock. View the source code here and you won’t see any sign of the comp_move variable computation from the &lt;% %&gt; tag. BENP: Now could be time for a screenshot or better GIF of refreshing /rock a couple of times to see the output and showing the source code. Alright, we are now finally building dynamic web applications. We are able to render a template, we are able to write some HTML, and we able use embedded Ruby tags: &lt;% %&gt; for hidden content, and &lt;%= %&gt; for rendered content that the user will see. 12.8.1 Text Companion: Embedded Ruby Tags "],["video-segment-control-flow-with-embedded-ruby.html", "12.9 Video Segment: Control Flow with Embedded Ruby", " 12.9 Video Segment: Control Flow with Embedded Ruby Notes: time stamp 00:31:37 to 00:37:10 conditionals all about &lt;% if ... %&gt; Now we can actually compute who won or lost our Rock Paper Scissors match. Let’s add this long if-else Ruby code to our game_templates/ file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;% if comp_move == &quot;rock&quot; %&gt; &lt;h2&gt;We tied!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We lost!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We won!&lt;/h2&gt; &lt;% end %&gt; {: mark_lines=“11-17”} Above, we used hidden &lt;% %&gt; embedded Ruby tags in our control flow on each line we wanted to hide, so none of this will be rendered to the user. Only the result of this control flow &lt;h2&gt;We tied!&lt;/h2&gt;, &lt;h2&gt;We lost!&lt;/h2&gt;, &lt;h2&gt;We won!&lt;/h2&gt; will be rendered, depending on the randomly sampled comp_move variable. Refresh http://[YOUR APP DOMAIN]/rock to see. And now would be a good time to run rails grade at the GitPod console to check our progress. And remember to Always Be Committing, by making a /git commit. We have a lot done, but we still have a lot to do. 12.9.1 Text Companion: Control Flow with Embedded Ruby "],["video-segment-homepage.html", "12.10 Video Segment: Homepage", " 12.10 Video Segment: Homepage Notes: time stamp 00:37:10 to 00:40:18 RCAV with render for / The target has a homepage at the root URL, /. In the old days, we would create a file in public/ called index.html, but now we are pretty much done with public/ except maybe for static assets like images or css files, but we won’t put any more user-facing URL pages there. Those will be connected up with routes from here on. Let’s go to our config/routes.rb and add a homepage route: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) end {: mark_lines=“5” } We are adding the \"/\" homepage route, we are using the application_controller.rb file, and we are using the action (or the method within the ApplicationController) that we call homepage. Now if I refresh the http://[YOUR APP DOMAIN]/ page, I get an error message that the homepage action cannot be found in ApplicationController: The action &#39;play_rock&#39; could not be found for ApplicationController This is good! That means we defined the route correctly. If you still see a “No route matches” error, then double-check your route syntax and get that error to go away before you proceed further. The error occurs because we did not yet define the action. So we need to go to our app/controllers/application_controller.rb file and add: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end end {: mark_lines=“9-11”} And now we can create that new file game_templates/rules.html.erb, and add to it: &lt;!-- app/views/game_templates/rules.html.erb --&gt; &lt;h1&gt;Welcome to RPS&lt;/h1&gt; Now when we refresh http://[YOUR APP DOMAIN]/, there is no error and our HTML template is rendered. And we did not put any HTML in the public folder! You will almost always want some kind of dynamic behavior on every page. So our new workflow is always RCAV: Define a route, assign a controller, create an action in that controller, and view the result. 12.10.1 Text Companion: Homepage "],["video-segment-reinforce-rcav-with-paper.html", "12.11 Video Segment: Reinforce RCAV with /paper", " 12.11 Video Segment: Reinforce RCAV with /paper Notes: time stamp 00:40:18 to 00:44:27 RCAV with render for /paper Let’s start with the /paper route, for when we play paper. First we define the route in config/routes.rb with a controller: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) get(&quot;/paper&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_paper&quot; }) end {: mark_lines=“9” } Again, we use the application_controller.rb. If we pretend we are a user now and go to http://[YOUR APP DOMAIN]/paper, we again get the “action not found” error. The helpful error message (RTEM!) tells us we need to define another method for the action in our controller called play_paper. We are in our Route, Controller, Action, View sequence that makes Rails so useful! It’s the same flow, over and over again. All we need to do is keep visiting the route and RTEM to find the next step. Ok, let’s define the action in our app/controllers/application_controller.rb: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23-26”} Now we can pretend we are a user and again refresh http://[YOUR APP DOMAIN]/paper. And we’ll get a new error message that tells us we are missing the view template: If you cannot figure out what your typo is and why an error message keeps coming up, then delete what you wrote and try to type it again from scratch (or talk to your rubber duck). We RTEM above and that tells us to go and make the new game_templates/user_paper.html.erb file that will be rendered to the user: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; And now our view at http://[YOUR APP DOMAIN]/paper renders content with no error message. A successful RCAV! 12.11.1 Text Companion: Reinforce RCAV with /paper "],["video-segment-embedded-ruby-in-the-controller-with-instance-variables.html", "12.12 Video Segment: Embedded Ruby in the Controller with Instance Variables", " 12.12 Video Segment: Embedded Ruby in the Controller with Instance Variables Notes: time stamp 00:44:27 to 00:54:20 moving conditional control flow &lt;% if ... %&gt; from /rock into the ApplicationController action play_rock local variables vs. instance variables with @-notation Now that we are RCAV pros, let me show you another (perhaps better, depending on your taste) way of writing our embedded Ruby code. Let’s return to the game_templates/user_rock.html.erb file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;% if comp_move == &quot;rock&quot; %&gt; &lt;h2&gt;We tied!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We lost!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We won!&lt;/h2&gt; &lt;% end %&gt; {: mark_lines=“5”} The highlighted code &lt;% comp_move = [\"rock\", \"paper\", \"scissors\"].sample %&gt; is okay, but you could imagine that in a real application there may be dozens of lines of code to prepare the information that we actually want to show the user. Our example is trivial. In reality we may lookup data from a database, doing math on it, finding API data, and more. Think of our “take your umbrella” example BENP: insert link to this DarkSky API example; but wait, has it even been presented up to this point?, which took around 30 lines of Ruby code to produce. We want somewhere other than the HTML template to put this code. We can in fact do that! Let’s go back to the game_templates/user_paper.html.erb file, since we didn’t get as far there and see how we can make this modification. We would like our file to look like this: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= outcome %&gt;! &lt;/h2&gt; {: mark_lines=“7-13”} We wish we could just do this and avoid all the lines of embedded Ruby that are in the previous user_rock.html.erb view template. The responsibility for these computations really don’t belong here, the view templates should be given some data and then the job should just be to format and present it beautifuly and usably to the user. In the backend the responsibility should be marshalling the correct data and sending it to the view template. We can return to our app/controllers/application_controller.rb controller file and do the following: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample if comp_move == &quot;rock&quot; outcome = &quot;won&quot; elsif comp_move == &quot;paper&quot; outcome = &quot;tied&quot; elsif comp_move == &quot;scissors&quot; outcome = &quot;lost&quot; end render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23-31”} In the above highlighted code we have removed all of the embedded Ruby tags (&lt;% %&gt; and &lt;%= %&gt;) from the code we had in the .html.erb view template. Now when a user visits the route http://[YOUR APP DOMAIN]/paper, the action play_paper in the controller ApplicationController will be triggered, and the code will be run before the template is rendered. So let’s try to visit http://[YOUR APP DOMAIN]/paper again. Oops, we get this error: In our game_templates/user_paper.html.erb view template, when we get to the first embedded Ruby tag: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= outcome %&gt;! &lt;/h2&gt; {: mark_lines=“8”} That local variable comp_move is undefined! A local variable only exists in the scope it was defined. If I create a local variable in a loop, it will only exist in that loop. If I want some variable available outside the loop, then I would need to create it outside the loop and modify it in the loop. So there’s a scope to local variables and I can’t just use it in my template if I created it in the play_paper method (action). The variable is effectively “dead” after play_paper executes. So how do we make the controller variables available in the view template? Let’s modify our app/controllers/application_controller.rb: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper @comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample if @comp_move == &quot;rock&quot; @outcome = &quot;won&quot; elsif @comp_move == &quot;paper&quot; @outcome = &quot;tied&quot; elsif @comp_move == &quot;scissors&quot; @outcome = &quot;lost&quot; end render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23 25-30”} All we did was place an @ symbol before any variable that we want access to in our view template. This is a new kind of variable called an instance variable. This type of variable will survive as long as the instance the object in which its created survives BENP: last sentence a bit confusing. In this case when someone visits /paper, Rails is going to create an instance of the ApplicationController class and then run the play_paper method. So as long as the ApplicationController instance is alive (Rails keeps it until the response is sent to the user), the variables produced by play_paper will exist. When someone visits /paper, we now have @comp_move and @outcome available for our template. We just need to make sure those instance variables are also properly referenced in game_templates/user_paper.html.erb: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= @comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= @outcome %&gt;! &lt;/h2&gt; {: mark_lines=“8 12”} Again, we just use the leading @ symbols on our variables to tie them to the instance variables in the controller. And if we visit the /paper URL, it works! And we have a much improved organization. Most computation work like this should go in the controller as we have done it here. We will have cases where embedded Ruby goes in the template (e.g., rendering database records with each loops, if statements to check if a user is allowed to see something, other conditional statements). If it can happen in the controller, it should happen there. Time for a rails grade and a /git commit! 12.12.1 Text Companion: Embedded Ruby in the Controller with Instance Variables "],["video-segment-linking-pages-with-layouts.html", "12.13 Video Segment: Linking Pages with Layouts", " 12.13 Video Segment: Linking Pages with Layouts Notes: time stamp 00:54:20 to 01:00:49 all about app/views/layouts/wrapper.html.erb to get some headers, footers, and navigation links layout(\"wrapper.html.erb\") in ApplicationController :layout argument for render() It would now be nice to add some links so we don’t need to type in the URL addresses, like in our target. Let’s start with our game_templates/user_paper.html.erb: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;div&gt; &lt;a href=&quot;/rock&quot;&gt;Play Rock&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/paper&quot;&gt;Play Paper&lt;/a&gt; &lt;/div&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= @comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= @outcome %&gt;! &lt;/h2&gt; {: mark_lines=“3-8”} And now if we visit our /paper URL, then we have the links. But if we click on “Play Rock” here, and we are taken to the /rock URL, then the links are not there, because we only put them in the game_templates/user_paper.html.erb file, and not in the game_templates/user_rock.html.erb file, which is what visiting the /rock URL will render. BENP: In the below example, we use the app/views/layouts/wrapper.html.erb file that we create, but in all other class work we use app/views/layouts/application.html.erb to place our headers and footers. Maybe we change the below section to just do it with that, which also I think allows us to omit the layout(\"wrapper.html.erb)\" call? How can we avoid repeating these HTML navigation links in all of our view templates? Well, here is one of the great benefits of working in Rails instead of HTML. We are dynamically generating responses rather than hard-coding into a bunch of files. If there is common stuff we want on every page, like a nav-bar or footer, then we can make a special file in app/views/layouts/ and call it whatever we like. Let’s create a file in that folder called wrapper.html.erb and let’s fill our new app/views/layouts/wrapper.html.erb file with: &lt;!-- app/view/layouts/wrapper.html.erb --&gt; &lt;div&gt; &lt;a href=&quot;/rock&quot;&gt;Play Rock&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/paper&quot;&gt;Play Paper&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/scissors&quot;&gt;Play Scissors&lt;/a&gt; &lt;/div&gt; &lt;%= yield %&gt; &lt;div&gt; &lt;a href=&quot;/&quot;&gt;Rules&lt;/a&gt; &lt;/div&gt; Copyright, Appdev 2022. All rights reserved. {: mark_lines=“13”} Now every page that we visit will have all of its contents placed where the above highlighted code says &lt;%= yield %&gt;. We just need to also change our application_controller.rb file to note this and have it take effect: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(&quot;wrapper.html.erb&quot;) {: mark_lines=“4”} This layout method takes one argument and it already knows to look in the folder app/views/layouts/ for the file that we created. After this change, try visiting your pages using the links on every page. It should work (except for /scissors because we haven’t done the RCAV for that page yet). If we only wanted the layout to apply on a per-page basis we could also leave layout(false) in the previous code, and we could in the play_rock method (action) change our render statement to: render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot;, :layout =&gt; &quot;wrapper.html.erb&quot; }) This additional :layout argument would then only put the nav-bar and footer in wrapper.html.erb on the /rock route. Time for a rails grade and a /git commit! The rest of the project is up to you to finish. Visit the specs and wire them all up. You have all the tools now. 12.13.1 Text Companion: Linking Pages with Layouts "],["finish-and-submit-rps-rcav.html", "12.14 Finish and Submit RPS RCAV", " 12.14 Finish and Submit RPS RCAV Notes: Refer students to rails grade, git, and Sharing a Gitpod Snapshot sections for how to get help "],["rcav-addendums.html", "12.15 RCAV Addendums", " 12.15 RCAV Addendums Notes: Stuff that I did not zip in from the chapter adding-routes.md: 12.15.1 Addendum: Rendering JSON Imagine that we wanted to build a native iPhone app that asked our server for some information; in this simple example, for a random computer move and an outcome, but in the real-world things like the local weather given a latitude and a longitude. Rather than rendering a pre-defined message in plain text, it’s usually more helpful to the iPhone developer to render the data in JSON format, so that they can parse it, easily fetch whichever values they need, and assemble their own interface. Here is some JSON that would be convenient for an external application to parse: { &quot;player_move&quot;:&quot;rock&quot;, &quot;comp_move&quot;:&quot;paper&quot;, &quot;outcome&quot;:&quot;lost&quot; } Notice that JSON uses strings as keys — this is because JavaScript doesn’t have the equivalent of Ruby’s Symbol class. Also, there are no hash rockets; JSON just uses colons to separate keys and values. Fortunately, just as it was easy for us to convert a String containing JSON into Ruby Arrays/Hashes using the JSON.parse method, it is also easy for us to go in the other direction: both Array and Hash have methods called .to_json. Let’s create a Ruby Hash that resembles the JSON above: response_hash = { :player_move =&gt; &quot;rock&quot;, :comp_move =&gt; &quot;paper&quot;, :outcome =&gt; &quot;lost&quot; } We can then convert this into a String in JSON format with .to_json: response_hash.to_json returns: &quot;{\\&quot;player_move\\&quot;:\\&quot;rock\\&quot;,\\&quot;comp_move\\&quot;:\\&quot;paper\\&quot;,\\&quot;outcome\\&quot;:\\&quot;lost\\&quot;}&quot; The \\\" represents double-quotes; we need the backslash, known as an “escape”, because we’re already within a double-quoted string and don’t want to terminate it. You can puts the string to see it formatted: puts response_hash.to_json displays: {&quot;player_move&quot;:&quot;rock&quot;,&quot;comp_move&quot;:&quot;paper&quot;,&quot;outcome&quot;:&quot;lost&quot;} Great! That means we can update our action if we want to send back JSON instead: class ApplicationController &lt; ActionController::Base def play_rock moves = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;] comp_move = moves.sample if comp_move == &quot;rock&quot; outcome = &quot;tied&quot; elsif comp_move == &quot;paper&quot; outcome = &quot;lost&quot; elsif comp_move == &quot;scissors&quot; outcome = &quot;won&quot; end response_hash = { :player_move =&gt; &quot;rock&quot;, :comp_move =&gt; &quot;paper&quot;, :outcome =&gt; &quot;lost&quot; } render({ :plain =&gt; response_hash.to_json }) end end Congratulations — you just built your first API endpoint!  12.15.2 Addendum: Custom Controller Files We don’t have to put all of our actions within the default ApplicationController file that comes included with any Rails app; we can add our own controllers, if we want to organize things a bit more. With an app of any non-trivial size, you’ll end up with hundreds of actions, and it can get unwieldy to put them all in one gigantic application_controller.rb. Instead, we can change our route for /rock to this: get(&quot;/rock&quot;, { :controller =&gt; &quot;game&quot;, :action =&gt; &quot;play_rock&quot; }) Now when a user visits /rock, they will see an error uninitialized constant GameController. As we know, when Ruby says “uninitialized constant” it means “I can’t find that class”. So, what’s going on here? When we said :controller =&gt; \"game\" in the route, we told Rails to look for a class called GameController when someone visits /rock. All of the controller class names will end in ...Controller, and they will begin with whatever value we provided for the key :controller in the route. Like all Ruby classes, the name must be CamelCase (not snake_case or Some_Hybrid). So in this case, it will be GameController. The class must be defined in a Ruby file that is the snake_cased version of its name. Rails will itself use the .underscore method to figure out the name; we can try it ourselves in rails console: [2] pry(main)&gt; &quot;GameController&quot;.underscore =&gt; &quot;game_controller&quot; The Ruby file must be placed within the app/controllers/ folder. So, in this case, we create a file called app/controllers/game_controller.rb (don’t forget the .rb file extension). Finally, within this file, we define the class: class GameController &lt; ApplicationController end We inherit from ApplicationController, which in turn inherits from ActionController::Base; much like our models inherited from ActiveRecord::Base via ApplicationRecord. Our models inherited .save, .where, and a bunch of other awesome database-related methods from ActiveRecord::Base; whereas our controllers are going to inherit a bunch of methods like render, redirect_to, and a bunch of other awesome interface-related methods from ActionController::Base. Don’t forget the end that goes with the class; type it before you forget it. Move your play_rock action over from application_controller.rb into this new class. Now, when a user visits the path /rock, the “uninitialized constant” error should go away and you should see a response as before. If you still see the “unitialized constant” error, then: You named your class wrong; it must exactly match the value in routes.rb, followed by Controller (singular), and CamelCase. You named the file wrong. Try doing .underscore on a string containing the class name in rails console to figure out the correct filename. You put the file in the wrong folder. It has to be within app/controllers/. Not within, for example, app/ or app/controllers/concerns/. You forgot the .rb file extension. If you can’t find which of the above it is, try deleting what you did and paving over your work again from scratch. Sometimes you just can’t spot your own typos, and paving over is the best approach. You can make as many controllers as you like; in general, a rule of thumb is to have one controller per database table. "],["omnicalc-1-forms-and-query-strings.html", "13 Omnicalc 1 (Forms and Query Strings)", " 13 Omnicalc 1 (Forms and Query Strings) Notes: Forms and Query Strings Original video transcription is in forms-query-strings-and-params-Omnicalc-Part1.md Project (graded): https://github.com/appdev-projects/omnicalc-1 Target: https://omnicalc-1.matchthetarget.com/ Useful chapters: forms-query-strings-and-params.md not BENP: Would be useful here to show the “layouts” folder that is providing the wrapper with the table of buttons. But I am confused because now the wrapper is not pointed out in the application_controller.rb file as in RPS RCAV. In any case, the layouts/application.html.erb is finally brought up in relation to the nav bar in the Day 4 video @ 28’30\" for the fortune teller app. Probably good to bring this up earlier. Also because this is where all the html header stuff went that is missing from our .html.erb view templates. "],["video-segment-intro-to-forms-and-exploring-the-target.html", "13.1 Video Segment: Intro to Forms and Exploring the Target", " 13.1 Video Segment: Intro to Forms and Exploring the Target Notes: time stamp 00:00:00 to 00:02:26 we want forms to get information what is a query string open gitpod explore the target Our users don’t want to type input into the address bar; they want to type into forms! Let’s practice building forms. Forms are incredibly important to us. That is the primary way in which users give us information that we will eventually be storing in our databases, the heart of our applications as we have talked about since day 1. For now we don’t have a database, but we will be doing some calculations, sending text messages, even doing some pretty cool API work with that information. Geocoding it, machine learning, all kinds of stuff. Next week we will have databases to store that information as well. We have a project called Omnicalc Part 1 to work on this, so we’ll create a GitPod workspace for it. BENP: Starting Our GitPod Workspace, 00:00:44 to 00:01:05 BENP: this setup is also occurring some more around 4 minutes in the midst of the first RCAV Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project is here. BENP: Exploring the Target, 00:01:05 to 00:02:26 This is a very simple application we will build today, to get our feet wet with forms. There are four forms that users can type into. This first one at the URL path /square/new there is a very simple single input form, where I can type in a number where I can type in a number like “42”, click the button and it gives me the square. The second URL /square_root/new let’s me enter a number, again “42”, and then I end up at the URL /square_root/results?user_number=42. There’s a query string starting at the ? there: ?user_number=42. There is also the URL path /payment/new with three inputs, and finally there is /random/new with two inputs. So let’s make these four links (URL paths) work. In doing so, we’ll see the fundamental pieces in making all forms work, and that is fundamentally how we get all of our user input. 13.1.1 Text Companion: Intro to Forms and Exploring the Target "],["video-segment-squarenew-rcav.html", "13.2 Video Segment: /square/new RCAV", " 13.2 Video Segment: /square/new RCAV Notes: time stamp 00:02:26 to 00:11:25 RCAV with RTEM for /square/new debugging Okay, so here is how this is gonna go. First and foremost, as always, it’s going to be a question of RCAV: Route, Controller, Action, View. That comes first, before anything. We need to identify the URLs users can visit, make up a route, and then first of all just make the page say something (anything) just to make sure we connected the RCAV dots correctly. Then we can figure out what do we actually need to show them, what, if any, Ruby do we need to write to make the page dynamic and all that other stuff. So let us first begin with let’s say the form at /square/new. We need to define this URL and then make it display a form to match the target. Pretty simple, there is nothing dynamic going on here, it’s just a static HTML page. Actually we could probably achieve this in the /public folder, but from now on we won’t do anything in there, we will always do RCAV, just to give us the flexibility of later embedding Ruby if we want to. My workflow is: pretend I’m a user, navigate to a URL I want to start supporting, and start debugging it one step at a time. Let’s begin by navigating (typing into the address bar) in our new Rails app http://[YOUR APP DOMAIN]/square/new. And in my staring point I will see: Routing Error No route matches [GET] &quot;/square/new&quot; BENP: in RPS-RCAV I added screenshots for error messages, probably fine to just do as here with code blocks So step one is opening config/routes.rb in our GitPod workspace, and add some code to it: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) end {: mark_lines=“5” } BENP: in the video at 00:05:14, the routes.rb file has some additional content not on the GitHub starting point. devise_for blah blah blah. We can maybe leave this code out from above? The first argument is the String defining the path that the user can visit, and the second argument defines the class (:controller) and method (:action) that are activated when someone visits the path. We decided on a method name called \"blank_square_form\", since the job of it is just to show a form for the user to type into when the user wants to calculate the square of a number. We decided we will put this method in the controller that comes with Rails out of the box: \"application\", which is found in the app/controllers/application_controller.rb file and has the class name ApplicationController when we open that file: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base end In our config/routes.rb, we tell Rails to look in this controller for our method whenever someone visits the route /square/new. Later when we have larger applications, and we begin having more actions, we’ll break it into multiple controllers. Now if pretend to be users in our running application and try to visit that route we get a new error: The action &#39;blank_square_form&#39; could not be found for ApplicationController The routing error is gone, which tells me I put the route in the right place, and didn’t have any typos. The new error message is saying that it found the route and controller, but the method (action) is missing. We still need to add our method to the app/controllers/application_controller.rb controller file: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end end {: mark_lines=“4-7” } I made up a name for a folder to but the templates in to keep things organized and I named the file. So we now need to go into our app/views/ folder, create a new folder called calculation_templates (do not create this folder or file in the layouts/ subfolder!) and then create a new file in that folder called square_form.html.erb. We can right away add something to that file, just to make sure that it works: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; Now we can go back to our Rails app browser tab and refresh the /square/new URL. When we refresh, we see “howdy” and know that our RCAV is complete. Note that I don’t try to type everything at once, work in very small steps and give yourself feedback (view) as early as you possibly can to make sure the code that you typed is doing what you think it is. If you see an error message up to this point then go back and be sure to RTEM! Let the error message help you. If it says “No route matches”, you might have typed in the URL in the address bar wrong (try to visit /squarre/new and see that happen), or you might have a typo in your config/routes.rb file in the get() call. Use the error messages and debug. It is very deterministic and will do exactly what you tell it to do. Rails is looking at this in a clear order. You visit a route, then it looks for the controller in the app/controllers/ folder and if that file is found, then it looks inside the file and looks for a class with the same name as the file (but capitalized and with underscores removed), then it looks for the action (method) in that class called whatever we defined it as in get(), then it will run that method. At every step, if something isn’t found, you will get a clear error message pointing out where the problem occurred and it is up to you to go back and correct. If you can’t spot the problem often the easiest thing to do is comment out your code and start from scratch typing everything. It’s quicker sometimes to pave over the typo, when they are hard to spot. 13.2.1 Text Companion: /square/new RCAV "],["video-segment-squarenew-form.html", "13.3 Video Segment: /square/new Form", " 13.3 Video Segment: /square/new Form Notes: time stamp 00:11:25 to 00:14:12 building a form in the /square/new view template &lt;form&gt;&lt;/form&gt;, &lt;label&gt;&lt;/label&gt;, &lt;input&gt;, &lt;button&gt;&lt;/button&gt; valid forms with for=\"\" and id=\"\" Now that we have the /square/new form saying something, we need to think about what it should actually do. It needs to have a form with a label and one text input and a button. Alright, if we refresh our memories and go back to the slides from the essential HTML review, there is a slide about forms, which we looked at in class. BENP: link here? Probably not necessary. I could not find this slide. Better to just link form chapter content. We can go into our view template for the current form and do the following: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label&gt;&lt;/label&gt; &lt;input&gt; &lt;button&gt;&lt;/button&gt; &lt;/form&gt; {: mark_lines=“5-10”} We have an opening and closing tag (&lt;form&gt;&lt;/form&gt;) to bracket the form, then a label tag (&lt;label&gt;&lt;/label&gt;), then an input tag (&lt;input&gt;, no closing necessary), then a button tag (&lt;button&gt;&lt;/button&gt;). These are the essential form elements. Now what about the copy? Let’s have a look at our target URL so we can get the copy right, because rails grade will be looking for it – you have to build to the spec that you’ve been “hired” to build. You can just make up your own copy willy nilly. Once we have the copy, we go back to our view template and add some more: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label&gt;Enter a number&lt;/label&gt; &lt;input&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“6 9”} Now that we have the copy, we need to make this form proper by adding the following: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“6-7”} We always need to associate inputs and labels with an id and a for. Every form control must always have an id and be labelled with a unique string. It doesn’t matter what the value is, it just needs to match for accessibility and for machines to understand the form. We just picked something random. It doesn’t matter so we just used \"giraffe\" for both. BENP: this use of random id and for is a little confusing because it’s not how we would do it later in the course or in reality. I’m in favor of using realistic form associations from this point already In addition, we added the type as \"text\" for the input, which is the default and would be used anyway even if we left it out. We also added a placeholder to add the gray text from our target: \"What number do you want to square?\". We can return to our Rails app and refresh /square/new to see our form. Great! 13.3.1 Text Companion: /square/new Form "],["video-segment-query-string-and-parameters-hash.html", "13.4 Video Segment: Query String and Parameters Hash", " 13.4 Video Segment: Query String and Parameters Hash Notes: time stamp 00:14:12 to 00:16:36 everything after ? from /square/new form and the Parameters Hash If I type in “42” and hit calculate, my form is terrible, it doesn’t really do anything. At least when I click the label “Enter a number” it puts the focus on the input box, so my association is wired up correctly. But when I click the button it doesn’t take me anywhere. Forms are like links, when you click on them they are supposed to take you to another URL, not keep you on the same page. The form is also supposed to put whatever I typed into the address bar after the ? symbol. One of the key problems I have is not naming my input, so let’s do that in our form: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot; name=&quot;elephant&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“7”} Just to be silly BENP: again, maybe use realistic for, id, name from this point already we named the input \"elephant\". And now when I refresh (the back arrow won’t change anything) the form at /square/new, and enter in 42 again then hit the calculate button, I will see a new URL string: /square/new?elephant=42. Now even though the form isn’t taking me to another place, at least the value I typed is getting preserved in the query string in the URL. And because of the way that Rails work, that value, if it’s in a query string, Rails is going to parse it and put it in a very special Hash. We can view that Hash in our GitPod terminal (Cmd + J to open or close it): This Hash with the name Parameters is now available in our entire app: in the view template, the action, we can use it anywhere. That is the crux of how we get information out of forms. All we need to do is name an input in the form, and that will capture the variable in our query string and Rails will put it in a hash that we can access. After all the API work that we’ve done BENP: wait, did we do API work up to this point? we are pros at capturing things out of hashes. Time for a /git commit (perhaps with the title message “Square form looking pretty good, doesn’t work yet” or something along those lines), and maybe even a rails grade to see what’s left to do. 13.4.1 Text Companion: Query String and Parameters Hash "],["video-segment-squareresults-rcav.html", "13.5 Video Segment: /square/results RCAV", " 13.5 Video Segment: /square/results RCAV Notes: time stamp 00:16:36 to 00:23:48 building the /square/results RCAV and form more on query strings If we look at how the target works, when we enter a number (why not…“42”?) to square and click calculate, then we end up at another URL /square/results?number=42. I started at /square/new and when I click, it takes me to /square/results, a page with different markup and different content from the starting point. Let’s send the user there in our app. We will need to start by going through our RCAV steps. Remember to work in small steps and refresh the view often. Keep Reading the Error Message and slowly debugging. Get used to this process, we will be doing it over and over again! Route, Controller, Action, View! First, the route. Go to your app’s browser and manually navigate to /square/new. RTEM. Time to add a route: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) get(&quot;/square/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_square&quot; }) end {: mark_lines=“7” } Since this is when the user is actually calculating (as opposed to requesting a blank form with \"blank_square_form\"), we call the action \"calculate_square\". Now refresh the browser again and RTEM. The route should be set, and it’s time to add an action (method) in our controller (class): # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“9-12” } We keep using the same calculation_templates/ folder. Now if we refresh again and RTEM, we see the action was found, but now we need to make a new file in app/views/calculation_templates/ called square_results.html.erb. Once we create that file and enter some quick copy to view (why not…&lt;h1&gt;hi&lt;/h1&gt;?), we refresh once more to see our completed, error-free RCAV cylce (assuming you don’t have any typos). Now let’s get the result page doing what we actually want. We begin by adding some formatting and HTML to our view template in app/views/calculation_templates/square_results.html.erb: &lt;!-- app/views/calculation_templates/square_results.html.erb --&gt; &lt;h1&gt;Square Results&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Number&lt;/dt&gt; &lt;dd&gt;something&lt;/dd&gt; &lt;dt&gt;Square&lt;/dt&gt; &lt;dd&gt;something squared&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“3-11”} We use a description list (&lt;dl&gt;) containing description terms (&lt;dt&gt;) and data (&lt;dd&gt;), as per the copy (remember to right click and “View Source”) in the target. Refresh out app, and everything should look okay on this page. But we just put in some placeholders for the result. Let’s actually make it dynamic. We need to put the original number in the first something and calculate the square to put the result in something squared. If I add a query string on the end of any URL in Rails (e.g., I can go to my app and add /square/results?user_number=42), and then I hit return, it doesn’t change anything. For the purposes of routing anything after the ? in a query string is ignored, but in the server log (GitPod terminal where we ran bin/server), we saw previously that everything after the ? is added as key/value pairs in the Parameters Hash: Parameters: {&quot;user_number&quot; =&gt; &quot;42&quot;} We could add a bunch of variables to our query string with &amp; and all of them would be separated in the Parameters. If we typed into our address bar /square/results?user_number=42&amp;zebra=12&amp;giraffe=82, hit enter, and return to our server log on GitPod, we would find: Parameters: {&quot;user_number&quot; =&gt; &quot;42&quot;, &quot;zebra&quot; =&gt; &quot;12&quot;, &quot;giraffe&quot; =&gt; &quot;82&quot;} So the query string is just a Hash! 13.5.1 Text Companion: /square/results RCAV "],["video-segment-form-action-and-params.html", "13.6 Video Segment: Form Action and params", " 13.6 Video Segment: Form Action and params Notes: time stamp 00:23:48 to 00:31:46 adding action=\"/square/results\" to the /square/new form using params Hash in the /square/results action to fetch from query string, calculate, and display Now if we go back to our form in our app at /square/new, enter “42”, and hit calculate, then it puts the query string together, but stays in the same place: /square/new?elephant=42. Remember we defined the name of the variable in our view template form as elephant. A bit silly, but we can roll with it. BENP: See what I mean? If we eliminate elephant above then we save on the awkward name here So this means we need to add a redirect action to our form, pull out the query string data, and do a calculation. So here’s the magic. Let’s open the view template at app/views/calculation_templates/square_form.html.erb: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form action=&quot;/square/results&quot;&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot; name=&quot;elephant&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“5”} The action attribute to the &lt;form&gt; is equivalent to the href in a link like &lt;a href=\"https://www.wikipedia.org\"&gt;Go to wikipedia&lt;/a&gt;. Putting \"https://www.wikipedia.org\" after action= would cause the form to redirect to WikiPedia after we click the button, you can try it yourself. Be sure to refresh the page, back buttons will not reload the code and the action will not work. Instead of redirecting away from our app though, we want our button click to send the user to /square/results, and that is what we specified above, and where the form will now go. Refresh /square/new, enter a number, click the button, and see for yourself. Again, if you tried the WikiPedia example, remember to refresh the page or your new action will not take effect. What happened? We entered “42”, we hit calculate, the form routed us to /square/results, Rails called the get() for this route, which used the controller and action to render our view template for this page, and on the end of our URL we have our input preserved: /square/results?elephant=42. And this input is also preserved in our Parameters Hash. Let’s pull out this data from the hash and use it in our action (contained in our controller) that was triggered when we were routed to the URL /square/results by our form: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;) @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“10-13” } From our server log, we copy-pasted in our hash and put this in a comment with the assigned variable params. This is for our own reference (it is in a comment #), but the variable params exists in every Rails app to store this hash. Hence we use it in the subsequent lines with our familiar Hash method .fetch() to pull out the key/value pair of interest. In this case we pull the user input (which we named elephant in our form) to an instance variable @num (because an instance variable will be accessible in our rendered view template \"calculation_templates/square_results.html.erb\"), and we calculate another instance variable @square_of_num to store our result for rendering. Let’s put these instance variables into that view template with embedded Ruby tags: &lt;!-- app/views/calculation_templates/square_results.html.erb --&gt; &lt;h1&gt;Square Results&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Number&lt;/dt&gt; &lt;dd&gt;&lt;%= @num %&gt;&lt;/dd&gt; &lt;dt&gt;Square&lt;/dt&gt; &lt;dd&gt;&lt;%= @square_of_num %&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;a href=&quot;/square/new&quot;&gt;Calculate another square&lt;/a&gt; {: mark_lines=“7 10 13”} Note that we also added a link at the bottom (as per the target app) to return to the form and make another calculation. Now we can refresh the /square/new, enter data, and submit again… but wait! Another error message: undefined method `**&#39; for &quot;42&quot;:String Oops, the query string puts the data into the params Hash as a String object, but we need it as a float or integer to do math on it. Let’s return to our controller action and: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“12” } We use a .to_f, since we want a float so the user can enter a decimal number (like “42.01”) and get the exact (not integer rounded) result. Now we can try once more, and everything should be up and running. Time for a /git commit (perhaps with the title message “Square form and calculation done” or something along those lines), and a rails grade to see what’s left to do. Do not use rails grade to debug, always test your app manually before running rails grade as the last check. 13.6.1 Text Companion: Form Action and params "],["video-segment-independence-of-routes.html", "13.7 Video Segment: Independence of Routes", " 13.7 Video Segment: Independence of Routes Notes: time stamp 00:31:46 to 00:43:13 use /random/results RCAV developed before /random/new to highlight independence of routes You will complete most of the rest of the assignment on your own, but let’s talk about one more thing using the /random/new URL path. We can have a look at the target and see that when we type in the “Minimum” using “1.5” and “Maximum” using “4.5” and click the button, we are routed to /random/results?user_min=1.5&amp;user_max=4.5. So this is the route we want to work. I want to point out here that in theory the /random/new page with the form and the /random/results page with the result are entirely independent. I could just build /random/results without /random/new, but then the user would need to manually type into the address bar their inputs after a query string: ?user_min=1.5&amp;user_max=4.5. Try and just change the URL to /random/results?user_min=0&amp;user_max=2. The page will change when you hit enter and we never used the form page. The point is, every RCAV is independent of every other RCAV. Clicking the button on our previous form for /square/new triggered a new and independent RCAV. We need to think of these things as independent, we are just cleverly arranging things such that there is a cause and effect, but this does not exist without our clever arrangement. So you can choose whatever names you want for inputs, parameters, or anything else. You just need to make sure whatever names you choose, that everything matches up so that at the end of the day you can retrieve the information you need. Don’t expect Rails to guess your intention, you need to instruct Rails what you want to do and it will follow your instructions to the letter. Let’s start the task of getting /random/new and /random/results to actually work. But let’s begin the other way around from before, by getting /random/results going first. So first step is to manually in my app enter the URL /random/results, get my familiar “No route matches” error and begin the RCAV cycle. First we add the route: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) get(&quot;/square/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_square&quot; }) get(&quot;/random/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_random&quot; }) end {: mark_lines=“9” } Now we refresh our browser, RTEM, and add the action that we named in our controller: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end def calculate_random render({ :template =&gt; &quot;calculation_templates/random_results.html.erb&quot; }) end end {: mark_lines=“18-21” } Now we refresh our browser, RTEM, and add the new view template that we named and put some copy in it: &lt;!-- app/views/calculation_templates/random_results.html.erb --&gt; &lt;h1&gt;howdy&lt;/h1&gt; And if we refresh and get no error message, our RCAV is complete and now we just need to get the view template to actually render what we want. Try to manually navigate the URL to /random/results?user_min=1.5&amp;user_max=4.5. Now go to the GitPod server terminal (as usual Cmd + J to open or close it, and Cmd + K to clear the log for a better view) and you will see the query string transcribed in the Parameters Hash, which we know is accessible anywhere in our Rails app by params = { key =&gt; value}, or, in this case: params = { \"user_min\" =&gt; \"1.5\", \"user_max\" =&gt; \"4.5\" }. Okay so let’s get this out in our action: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end def calculate_random # params = {&quot;user_min&quot;=&gt;&quot;1.5&quot;, &quot;user_max&quot;=&gt;&quot;4.5&quot;} @lower = params.fetch(&quot;user_min&quot;).to_f @upper = params.fetch(&quot;user_max&quot;).to_f render({ :template =&gt; &quot;calculation_templates/random_results.html.erb&quot; }) end end {: mark_lines=“19-22” } And then add these instance variables in the rendered view template: &lt;!-- app/views/calculation_templates/random_results.html.erb --&gt; &lt;h1&gt;howdy&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Minimum&lt;/dt&gt; &lt;dd&gt;&lt;%= @lower %&gt;&lt;/dd&gt; &lt;dt&gt;Maximum&lt;/dt&gt; &lt;dd&gt;&lt;%= @upper %&gt;&lt;/dd&gt; &lt;dt&gt;Random Number&lt;/dt&gt; &lt;dd&gt;Something&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“5-14” } Something above is just a placeholder. I leave that to you to calculate in the action and place in the view template. But let’s refresh our new /random/results?user_min=1.5&amp;user_max=4.5 page. We see that indeed the URL query string has been parsed and turned into the instance variables which were then embedded in my view template. Try and just manually change the URL to /random/results?user_min=0&amp;user_max=2. The page will change when you hit enter and we never used the form page. So the two routes are independent. In theory, the savvy user could manually change the URL to get new results, but this isn’t so nice and we can’t expect our users to know how to do this. That’s why we use forms and wire things together. But remember: during the lifecycle of a given RCAV, only that route, action, and view template exist. Time for a /git commit, and a rails grade to see what’s left for you to do. 13.7.1 Text Companion: Independence of Routes "],["finish-and-submit-omnicalc-1.html", "13.8 Finish and Submit Omnicalc 1", " 13.8 Finish and Submit Omnicalc 1 Notes: Below are relevant notes for the rest of the project taken from the README 13.8.1 The Target The way the assignment should work is: If I visit the ROUTE /square/new, I should see a form with a label and an input to enter a number. If I submit that form, I should see the square of the number that I entered. If I visit the ROUTE /square_root/new, I should see a form with a label and an input to enter a number. If I submit that form, I should see the square root of the number that I entered. If I visit the ROUTE /payment/new, I should see a form with labels and inputs to enter three values: The APR (annual percentage rate). The number of years remaining. The present value. If I submit that form, I should see the monthly payment due given the values that I entered. Mind your units! Use this formula: Payment formula Hint 1: The number of periods, n, that we receive from the user is in years. Since we’re calculating monthly payment we multiply it by 12. Hint 2: apr comes in as a string. We should turn it into a float and divide the number by 100 to get the percentage. Hint 3: r in the formula is a percentage per period. One period is equal to one month. The apr we receive from the user is yearly. Hint 4: Create a variable for the numerator and another one for the denominator. If they are instance variables, you can view them within your view page. If your output does not match the target, having done this will make debugging much more manageable. If I visit the ROUTE /random/new, I should see a form with labels and inputs to enter two numbers, a minimum and a maximum. If I submit that form, I should see a random number that falls between the numbers that I entered. You can compare your app against the target, including doing “View Source” to look at some of the static HTML. 13.8.2 Valid, Accessible Forms In order for your tests to pass, you must build valid forms (your Chrome browser may tolerate invalid forms while you are manually testing, but automated test suites reject invalid forms): Each &lt;input&gt; in the form must have a unique id=\"\" attribute. The &lt;label&gt; associated with the &lt;input&gt; should have a for=\"\" attribute that matches the value of the &lt;input&gt;’s id. The copy within the &lt;label&gt; must exactly match the target — spelling, capitalization, and punctuation matter for labels. The same goes for the copy on the button to submit the form. Any invalid HTML within a form will cause the test to fail, e.g. an orphaned closing &lt;/div&gt; tag. Keep your code neatly indented to help avoid this. An example of a valid form; in particular, notice the id=\"\" and for=\"\" attributes: &lt;form action=&quot;/random/results&quot;&gt; &lt;div&gt; &lt;label for=&quot;min_input&quot;&gt; Minimum &lt;/label&gt; &lt;input id=&quot;min_input&quot; type=&quot;text&quot; name=&quot;user_min&quot; placeholder=&quot;E.g. 1.5&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;max_input&quot;&gt; Maximum &lt;/label&gt; &lt;input id=&quot;max_input&quot; type=&quot;text&quot; name=&quot;user_max&quot; placeholder=&quot;E.g. 4.5&quot;&gt; &lt;/div&gt; &lt;button&gt; Pick random number &lt;/button&gt; &lt;/form&gt; 13.8.3 Additional Hints The to_s method can format Floats in more specific ways that help us easily display data in a variety of ways. In particular these two: .to_s(:currency) .to_s(:percentage) could be useful when formating the output of the payment form. "],["fortune-teller.html", "14 Fortune Teller", " 14 Fortune Teller Notes: Original video transcription is in fortune-teller.md Project (graded): https://github.com/appdev-projects/fortune-teller Target: https://fortune-teller.matchthetarget.com/ Useful chapters: adding-routes.md rcav-flowchart.md Routing - RCAV Slides "],["video-segment-routes-and-controllers-in-fortune-teller.html", "14.1 Video Segment: Routes and Controllers in Fortune Teller", " 14.1 Video Segment: Routes and Controllers in Fortune Teller Notes: time stamp 00:03:28 to 00:10:50 practice routing stepping away from app/controllers/application_controller.rb, and using app/controllers/numbers_controller.rb inheritance: NumbersController &lt; ApplicationController &lt; ActionController::Base Our plan for today is to practice the very important thing for this week which is routing. How do you connect a particular visit to a URL to a Ruby method, and then generate some dynamic HTML and send it back. So that will be the day today. Practicing that over and over. BENP: insert references to previous RCAV material here, like adding-routes.md and RCAV-flowchart.md This fortune teller project will be the first in a series of debugging projects. So rather than building up an app from scratch, we’ll start with a completed app that we have planted pernicious bugs in. You have to go through and figure out how to Read The Error Messages, RTEM. Again, RTEM is the most important skill to develop, not being able to just scan the code and spot what’s wrong. Let the error messages help you. If navigate to your app in the browser, you should be on the homepage /lottery/lucky which shows you five lucky numbers in a bulleted list. Each time we refresh, the numbers are changing. So this is a dynamic page and not a static page in the /public folder on GitPod. Let’s see what we are starting out with by going to our application on the GitPod workspace and opening our file config/routes.rb: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end BENP: not sure about the ... notation above to indicate code In many senses, this is the most important file. This is the list of all of the URLs that users are allowed to visit in our app, so it’s also a great place for us to start when we’re trying to get to know a new codebase. If we look at this we can see there are two routes users can currently visit /lottery/lucky and /. We can return to our browser and test those two URLs. They will bring us to the same lucky numbers page. But if I try to visit anything else, like if I click on any of the navbar links, all other URLs don’t work right now. One thing we notice right away is that both paths in our config/routes.rb are using the same controller and action: { :controller =&gt; \"numbers\", :action =&gt; \"winners\" }. And also, this controller called \"numbers\", is different from \"application\". The app/controllers/application_controller.rb is the file we have always used up to this point, as this is the ApplicationController that comes with every Rails application out-of-the-box. But, we can create our own controllers to keep things more organized. If you specify something after :controller =&gt; besides \"application\", like \"numbers\", then you need to create the file yourself in the app/controllers/ folder. If we navigate to that folder, we see we have six controllers now. application_controller.rb is in there, but if we open it we see it’s empty: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base end because we haven’t used it in our app. Instead if we open the \"numbers\" controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController ... end end We see that we’ve inherited (&lt;) from ApplicationController, so we get all the power – all the methods – that our ApplicationController inherited from the Rails ActionController::Base. ApplicationController is a “child” of ActionController::Base and ApplicationController is a “parent” of NumbersController. Written out that would look like NumbersController &lt; ApplicationController &lt; ActionController::Base. BENP: added that last two sentences based off some student questions in video This is a better way of organizing our controllers because in any standard app you are going to have dozens or hundreds of actions and ApplicationController would get cluttered if we put them all in the same file. We may ask, with multiple controllers, can we share data (e.g., instance variables with the @-notation) across the controllers? The answer is, not really. Because when someone visits a particular URL in our app, at that moment Rails goes and looks up a single controller action and runs it. At any given moment, only one route is every being used by a user. So it doesn’t matter if I have ten thousand actions in ApplicationController or spread across multiple child controllers, but they don’t need to every communicate with each other. The action is run, we send the HTML back, and the request is done until the user visits another route. 14.1.1 Text Companion: Routes and Controllers in Fortune Teller "],["video-segment-.each-loop-on-instance-variable.html", "14.2 Video Segment: .each Loop on @ Instance Variable", " 14.2 Video Segment: .each Loop on @ Instance Variable Notes: time stamp 00:10:50 to 00:17:37 from @zebra instance variable array to .each loop in the view template for /lottery/lucky embedded Ruby tags &lt;%= %&gt; vs. &lt;% %&gt; Okay, so as we saw in our config/routes.rb, the action triggered when visiting /lottery/lucky or / is called winners in our controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“4-14”} We chose to write this by first creating a new array (@zebra = Array.new), then we used the times method to generate a random number in a variable called giraffe and push the number into the @zebra array five times. There are other ways to do this, like creating five separate variables and putting a random number in each, that would have worked, but in this case I’m rendering the template \"lottery_stuff/woohoo.html.erb\", with only one instance variable, the array @zebra. Let’s look at that template in app/views/lottery_stuff: &lt;!-- app/views/lottery_stuff/woohoo.html.erb --&gt; &lt;h1&gt;Lucky numbers&lt;/h1&gt; &lt;p&gt;Your lucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;% @zebra.each do |elephant| %&gt; &lt;li&gt; &lt;%= elephant %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8-12”} BENP: Again, notes about using elephant, zebra, giraffe. I wonder if it’s better to use thoughtful variable names from the beginning and avoid this. The crucial part is highlighted. In our .erb template, we are using .each on our instance variable array @zebra. Inside of the looping block, we write HTML to display the variable using the &lt;%= %&gt; embedded Ruby tag. We could name the block variable elephant whatever we want (as long as we change the name in the loop as well as between the pipes ||). It only exists in our loop and is not from the controller action. This instance variable loop-and-display technique is something we are going to be doing a lot. This is a main reason we spent all that time learning about .each. Very often we have records from a database table and we need to format and display those records with this technique. We could change the above code and see what happens. Let’s do this: &lt;!-- app/views/lottery_stuff/woohoo.html.erb --&gt; &lt;h1&gt;Lucky numbers&lt;/h1&gt; &lt;p&gt;Your lucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;%= @zebra.each do |elephant| %&gt; &lt;li&gt; &lt;%= elephant %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8”} We added an = sign to the first embedded Ruby tag. Now if we refresh the app in our browser on the /lottery/lucky page, we will see the full array printed below our list, because we have made this previously invisible line (this tag: &lt;% %&gt;) visible (this tag: &lt;%= %&gt;). When done looping, .each returns the array itself when it is called. We don’t typically want or need to view this though. You can remove that added = sign from the HTML view template after you do this, because this line is not meant to be displayed, but rather to control the flow of our embedded Ruby. We already saw this with if statements for our Rock Paper Scissors RCAV project. 14.2.1 Text Companion: .each Loop on @ Instance Variable "],["video-segment-rcav-lotteryunlucky.html", "14.3 Video Segment: RCAV /lottery/unlucky", " 14.3 Video Segment: RCAV /lottery/unlucky Notes: time stamp 00:17:37 to 00:27:18 RCAV practice. re-do the /lottery/lucky but with different copy. try to type everything, avoid copy-paste Our first task in the README, was to study /lottery/lucky, and we’ve done that. Now let’s take a moment to build /lottery/unlucky. This is basically the same page, just with some different copy. Follow the usual RCAV. If you want a reference sheet you can have a look here. BENP: do we want that chapter linked still? We click the navbar or manually enter the URL to get to /lottery/unlucky, and we see the “No route matches” error. So we go into config/routes.rb and add that: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/lottery/unlucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;losers&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end {: mark_lines=“10”} Now we can refresh the browser and see we need to add the losers action to our controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def losers end def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“4-6”} Now it is up to you to complete the action code and render the result in a view template that will be very similar (though not identical) to app/views/lottery_stuff/woohoo.html.erb. Try to type everything out by yourself and avoid any copy-pasting. This is good practice! BENP: Break here where the students worked on this from 00:19:30 to 00:25:00 Let’s look at the completed action code: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def losers @numbers = Array.new 5.times do a_number = rand(1...100) @numbers.push(a_number) end render({ :template =&gt; &quot;lottery_stuff/ohno.html.erb&quot;}) end def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“5-13”} Note that we used some different variable names, and these are up to us to choose: @numbers for the array of random numbers and we call each individual number a_number. And we also can create the specified view template and filled it in. We start with this: &lt;!-- app/views/lottery_stuff/ohno.html.erb --&gt; &lt;h1&gt;Unluck numbers&lt;/h1&gt; &lt;p&gt;Your unlucky numbers for today are:&lt;/p&gt; &lt;%= @numbers %&gt; Now refreshing /lottery/unlucky should display our copy and our array of numbers with no formatting. Nice, almost there. Let’s add a loop and put our numbers into the proper format: &lt;!-- app/views/lottery_stuff/ohno.html.erb --&gt; &lt;h1&gt;Unluck numbers&lt;/h1&gt; &lt;p&gt;Your unlucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;%= @numbers.each do |num| %&gt; &lt;li&gt; &lt;%= num %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“7-12”} And now /lottery/unlucky should match the target. Test it manually to see, and when you’ve done that… Time for a /git commit, and maybe even a rails grade to see what’s left to do. 14.3.1 Text Companion: RCAV /lottery/unlucky "],["video-segment-navbar-and-zodiac-debugging.html", "14.4 Video Segment: Navbar and Zodiac Debugging", " 14.4 Video Segment: Navbar and Zodiac Debugging Notes: time stamp 00:27:18 to 00:36:30 aside to app/views/layouts/application.html.erb to show debug /zodiacs/aries together RTEM In the target, there are three navbar sections. We already did the top lottery section. There are twelve links in the horoscopes section. If you click the link you will see that each displays some text and then lucky numbers again. Below the horoscipes there is a section for dice, which simulates rolling a certain number of dice with a certain number of sides. For instance, “5d6” means roll five six-sided dice. In our app (not the target), none of the horoscope or dice links work. Here’s your task. First, the required part of this homework is debugging the 12 zodiacs. There are already links and routes. BENP: An aside starts below, could be moved elsehwere By the way, where does all the navbar HTML come from? In the templates we made (e.g., app/views/lottery_stuff/woohoo.html.erb), we did not include any header information in the HTML code. That’s because all of this is in the wrapper file, specifically app/views/layouts/application.html.erb: &lt;!-- app/views/layouts/application.html.erb --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Fortune Teller&lt;/title&gt; &lt;%= csrf_meta_tags %&gt; &lt;!-- Expand the number of characters we can use in the document beyond basic ASCII  --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- Make it responsive to small screens --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;%= csp_meta_tag %&gt; &lt;%= stylesheet_link_tag &#39;application&#39;, media: &#39;all&#39; %&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; Where we have the ..., you should see all of the navbar links in an HTML table, which is applied as a header to all of our pages. The pages are placed where we see the &lt;%= yield %&gt; tag. This app/views/layouts/application.html.erb file that comes with every Rails app is where you would place anything that you want on all of your pages. Okay, back to the zodiac debugging. If we go to our routes, we will see: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/lottery/unlucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;losers&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end {: mark_lines=“22-24”} And we can just begin uncommenting (remove the leading # from the line) each route and debugging them one at a time. Uncomment each route ONE AT A TIME and debug it ONE AT A TIME. Don’t uncomment multiple at once, or you’ll have multiple syntax errors at once and the error messages can’t help you. Let’s begin by uncommenting get(\"/zodiacs/aries\", { :controller =&gt; fire, action =&gt; \"ram\" }) and then in our app try to visit the given path: /zodiacs/aries. Now RTEM: There&#39;s a problem with your routes.rb file. unrecognized `fire&#39; . So let’s look at our routes file, and what do we see? Oops, where is says :controller =&gt; fire, it should say :controller =&gt; \"fire\", with string quotation marks. Without the quotations, Ruby thinks fire is a local variable because it begins with a lowercase letter. But we never defined a variable called fire, that is the name we assigned to our controller and we have a controller file called app/controllers/fire_controller.rb, which is what we want Rails to look for. Okay, we made this change and now we refresh our browser on /zodiacs/aries, and we get a new error: There&#39;s a problem with your routes.rb file. unrecognized `aciton&#39; . Did you mean? action_path Because in our route we have action =&gt; \"ram\", which should be :action =&gt; \"ram\", adding a colon to make action into a symbol in the hash. And refresh /zodiacs/aries again, and another error to deal with: ActionController::RoutingError at /zodiacs/aries uninitialized constant FireController Did you mean? FiresController AirController Hmm. This means we have not defined the class FireController. So let’s look in our app/controllers/ directory and we see a controller called fires_controller.rb. There is an extra s on fires, whereas we wrote in our route: :controller =&gt; \"fire\". So rename the controller to fire_controller.rb and refresh again /zodiacs/aries, and we succeeded! One thing to note. If you think you did everything correctly but are still getting error messages, then go to GitPod, shut down your server in the terminal by using Ctrl + C, and restart with bin/server. This sometimes happens with filename or foldername changes. Time for a /git commit, and maybe even a rails grade to see what’s left to do. And now you can proceed on your own with the config/routes.rb file as we’ve done above. Uncomment, RTEM, and proceed. 14.4.1 Text Companion: Navbar and Zodiac Debugging "],["finish-and-submit-fortune-teller.html", "14.5 Finish and Submit Fortune Teller", " 14.5 Finish and Submit Fortune Teller Notes: Below are relevant notes for the rest of the project taken from the README 14.5.1 Debugging checklist READ the error message. Extract as much useful information from it as possible. If there’s no error message, find another way to give yourself feedback; make the invisible visible. Use the server log. Print things; in this new world, that means use embedded Ruby tags (&lt;%= %&gt;) in the view templates. We can’t use the p method anymore since we aren’t writing command line programs anymore. If all else fails — the error message isn’t helpful, or there isn’t one and you can’t spot the issue visually — delete the offending code (or comment it out), and re-type the R→C→A→V from scratch. Hopefully you’ve been making lots of git commits, so there’s no fear in doing so. 14.5.2 More RCAV Practice In the nav, there are links to 18 pages that simulate rolling dice in various combinations that are useful for board games (six-sided dice, from one die up to six dice) and other, more exotic dice combinations that are useful for e.g. Dungeons &amp; Dragons. Right now, none of those URLs work; and the routes don’t even exist. Implement them, one at a time. Try to type them out rather than copy-pasting; the point is to build muscle memory and encounter error messages in a controlled setting. There are no automated tests for Part 3; this is just extra reps for practice. 14.5.3 Reflections Of the error messages that you encountered during debugging, which ones were most helpful? Which ones were least helpful? In this project, the subfolders within app/views/ that we store our ERB templates in had various different suffixes: app/views/lottery_stuff/ app/views/flame_interface/ app/views/nature_templates/ app/views/wind_html/ app/views/aqua/ (no suffix) If you had to pick one style for us to use consistently in the future, which do you prefer? Or can you think of a different subfolder naming convention that you would prefer more? You now know how to respond to visits to URLs with dynamically generated HTML. This is, fundamentally, how Twitter, GitHub, Basecamp, NYTimes, Airbnb, and every other web application works. But, of course, we have a lot more to learn before we could build, for example, a social network. What are we still missing? What are you most curious to learn next? "],["omnicalc-2-forms-params-apis.html", "15 Omnicalc 2 (Forms, Params, APIs)", " 15 Omnicalc 2 (Forms, Params, APIs) Notes: Original video transcription is in Omnicalc-Part2.md Project (graded): https://github.com/appdev-projects/omnicalc-2 Target: https://omnicalc-2.matchthetarget.com/ username: appdev password: fullstack Useful chapters: forms-query-strings-and-params.md omnicalc-api.md meteorologist-intro-to-apis.md storing-credentials-securely.md google-translate.md sending-emails-and-texts.md Right now a bunch of this found much later in the Day 5 material on Canvas. See my notes below, APIs might need devoted video (maybe one for each API). "],["video-segment-exploring-the-target.html", "15.1 Video Segment: Exploring the Target", " 15.1 Video Segment: Exploring the Target Notes: time stamp 00:38:36 to 00:42:54 doing math, intro to APIs Street to Coordinates Translate with SMS Forms are incredibley important to us. The first layer of building a dynamic application is connecting the Route, Controller, Action, View. Having some variables displayed on the page so it is dynamic and not static HTML. The second thing we need to do is accept information from our users because just generating random stuff on a page is boring, so we’ll be building tons and tons of forms for the rest of the quarter. Omnicalc 2 is very similar to Omnicalc 1, where you began to learn forms in that homework. In this case, if I have a look at config/routes.rb, the file is empty: # config/routes.rb Rails.application.routes.draw do # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end So will need to build up the target step-by-step. When you open this app, you need to enter a username (appdev) and password (fullstack). The reason for this, is because, if we have time, we’re going to do some more fun things than we’ve done so far. Instead of just getting numbers and doing some math, we’ll be doing some more fun things. For example if we look in the target, there’s a “Street to Coordinates” calculator. If you type in and address here, like “5807 S Woodlawn Ave” and click “Lookup Coordinates”, then it displays latitude and longitude. So all the form entry steps are the same as what you’ve already done, but the application does much more here. How did we get from a street address to these coordinates? What’s the Ruby for that? Well, we’re going to learn how to do that. Even more cool, there’s a link in the target called “Translate”. Ff we fill out this form, maybe with “Ruby is the best!” in the first box, and then select a language from the second drop down menu (e.g., Chinese (simplified)), and put in a phone number in the last box with the country code (e.g., +1 for USA), and finally hit translate, then the text gets translated and the number we entered gets a text message with that translation! It’s still all about entering in forms, but the way we achieve these responses is very empowering. This is known as Application Programming Interface, or API, programming. This means that other companies, like Google, will allow us to Create, Read, Update, and Delete information in their databases, and they will send back information that they have. We don’t need to create their data, we can use their resources. Both the street to coordinates and translation service above is provided by Google (actually the text messaging part is another company called Twilio). We also have link to “Street to Weather” or “Coordinates to Weather”. These use two APIs, one for Google to get the location, and the second is the DarkSky API to get back a detailed weather forecast. 15.1.1 Text Companion: Exploring the Target "],["video-segment-reviewing-query-strings.html", "15.2 Video Segment: Reviewing Query Strings", " 15.2 Video Segment: Reviewing Query Strings Notes: time stamp 00:42:54 to 00:50:45 examine target /wizard_add and implement using query string and params All that said, the important goal of this project (and the required part) is building forms, so let’s do one of the four forms together now: Add, Subtract, Multiply, Divide. We will focus on the “Add” form. Let’s visit /add in our Rails app browser. As expected we get a “No route matches” error. So we will need to build this up step-by-step. But first, observe the target app. In each calculator there are two actions. There is one action that just displays the form. Then when I fill out the form and press the button, it takes me to a different URL. If we fill out “Add” with “4” in the first number and “10” in the second, then press the button, the resulting URL on the “Addition” page looks like /wizard_add?first_num=4&amp;second_num=10. Any of the other forms on our target works this same way: the information we put in the form is placed as variables in the URL query string preceded by the ? character. If I know how this form works, I can just type directly into the URL with new variable values, and I will get a new result. I never even need to visit the form page. I want to emphasize here, the form and second action that does the work are two totally separate independent actions. We use forms because we want a nice interface for our users. It is polite to add a form for our users, who are not developers like us. We’ll implement /add now, but we will go backwards. First, I’m going to implement the second step /wizard_add: # config/routes.rb Rails.application.routes.draw do get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“5”} My selection for the :controller and :action names above, mean I’ll need to create these in out app. So in the app/controllers/ folder we need to make a new file math_controller.rb and fill it in with our inherited ApplicationController functionality and our new action: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_results render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end And our selection to just render some HTML, means that we also need to create the view template. So in the app/views/ folder we need to first make a new folder math_templates/ and then a new file in that folder called add_results.html.erb. And in this file we can put some placeholder text to render: &lt;!-- app/views/math_templates/add_results.html.erb --&gt; hi Now if we didn’t make any typos and visit or refresh /wizard_add, we will see our rendered HTML. You will also already see a navbar, that we included in the app, and this, as you have already seen, is in the app/views/layout/application.html.erb file that is applied to every page. Now if a user includes a query string in the URL, like /wizard_add?zebra=bob, there is no effect on the routing when we press enter. But if we look into our server log in the GitPod terminal tab running your server (Cmd-K or Ctrl-K to clear it out), we can find: ... HTML Parameters: {&quot;zebra&quot;=&gt;&quot;bob&quot;} Rendering math_templates/add_results.html.erb Rendered math_templates/add_results.html.erb within layouts/application ... Our query string that is automatically split, parsed, and added to params. All before I have built the form. Let’s use the expected query string: /wizard_add?first_num=4&amp;second_num=10. And observe now in the server log: ... HTML Parameters: {&quot;first_num&quot;=&gt;&quot;4&quot;, &quot;second_num&quot;=&gt;&quot;10&quot;} Rendering math_templates/add_results.html.erb Rendered math_templates/add_results.html.erb within layouts/application ... {: mark_lines=“3”} We can now pull out this information in our action: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_result @first = params.fetch(&quot;first_num&quot;) @second = params.fetch(&quot;second_num&quot;) @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“5-9”} And display the instance variables on our view template: &lt;!-- app/views/math_templates/add_results.html.erb --&gt; &lt;%= @result %&gt; {: mark_lines=“3”} And if we now refresh /wizard_add?first_num=4&amp;second_num=10, we see the result displayed as “410”. Why? Because we are adding two strings in our action! We need to remember to convert them to floats or integers to do math on them: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_results @first = params.fetch(&quot;first_num&quot;).to_f @second = params.fetch(&quot;second_num&quot;).to_f @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“5 7”} And now we should get “14.0” on our page. We won’t flesh out all the copy and formatting to get our HTML view template to match the target page, but this should be straightforward. 15.2.1 Text Companion: Reviewing Query Strings "],["video-segment-reviewing-forms.html", "15.3 Video Segment: Reviewing Forms", " 15.3 Video Segment: Reviewing Forms Notes: time stamp 00:50:45 to 00:58:00 examine target /add and implement using forms Our results page works, but it’s a pain for our users to type in the URL query string. If they make any mistake like typing “first_number” instead of “first_num”, like /wizard_add?first_number=4&amp;second_num=10, they would get the error: param is missing or the value is empty: first_num because in our add_result action in our MathController, we have @first = params.fetch(\"first_num\").to_f. But \"first_num\" does not exist in our params variable, because the user accidentally named it first_number in the URL. Hence, we need a form for the user to type into. So the usual RCAV here: # config/routes.rb Rails.application.routes.draw do get(&quot;/add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_form&quot; }) get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“5”} Then: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_form render({ :template =&gt; &quot;math_templates/add_form.html.erb&quot; }) end def add_results @first = params.fetch(&quot;first_num&quot;).to_f @second = params.fetch(&quot;second_num&quot;).to_f @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“4-6”} Put some copy in the new view template we create: &lt;!-- app/views/math_templates/add_form.html.erb --&gt; hi And when we see our URL /add loads with no error, we can put together our form in the view template to finish things off: &lt;!-- app/views/math_templates/add_form.html.erb --&gt; &lt;form action=&quot;/wizard_add&quot;&gt; &lt;input name=&quot;first_num&quot;&gt; &lt;input name=&quot;second_num&quot;&gt; &lt;button&gt; Add &lt;/button&gt; &lt;/form&gt; {: mark_lines=“3-11”} The all important action=\"/wizard_add\" attribute in the opening &lt;form&gt; tag, tells the form that when we click the &lt;button&gt;, then route to /wizard_add, which activates the first RCAV we built to do the computation. This is the most basic, working version of the form, but you will need to add a lot more like the input labels. Of course, we want a valid form, so you will need to include the matching for=\"\" and id=\"\" attributes for each &lt;label&gt; and associated &lt;input&gt;, and make sure everything matches the target. BENP: could link to forms-query-strings-and-params.md chapter or whatever that content becomes Complete the rest of the assignment on your own and make sure to be /git committing anytime you get something working with rails grade. You will need to wire up all RCAVs and the associated forms for “Add”, “Subtract”, “Divide”, and “Mulitply”. BENP: From below, I think a new chapter /recording / chapter is in order. 15.3.1 Text Companion: Reviewing Forms "],["video-segment-intro-to-apis-with-street-to-coordinates.html", "15.4 Video Segment: Intro to APIs with Street to Coordinates", " 15.4 Video Segment: Intro to APIs with Street to Coordinates Notes: time stamp 01:00:00 to 01:21:00 there is a bunch of explanation here about APIs implementing /experiment for “Street to Coordinates” API keys JSON Google Maps API JSON to Hash with JSON.parse(open(@url).read) Let’s begin to experiment with APIs in our app. One of the homework videos for next week includes some API work, but we will get a taste here. First we will add a route to experiment with: # config/routes.rb Rails.application.routes.draw do get(&quot;/add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_form&quot; }) get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) get(&quot;/experiment&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;experiment&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“9”} We are just going to use the application_controller.rb file as our controller and add an action there experiment. # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“3-6”} We just put the new template again in the app/views/math_templates/ folder, just to experiment.html.erb. And here is a bunch of handy links (BENP: originally from README, can we remove some links? yes definitely) with information on APIs: JSONView Chrome extension Dark Sky forecast at the Merchandise Mart for humans Dark Sky forecast at the Merchandise Mart for machines: https://api.darksky.net/forecast/REPLACE_THIS_PATH_SEGMENT_WITH_YOUR_API_TOKEN/41.8887,-87.6355 Dark Sky API docs Map of Merchandise Mart for humans Map of Merchandise Mart for machines: https://maps.googleapis.com/maps/api/geocode/json?address=Merchandise%20Mart%20Chicago&amp;key=REPLACE_THIS_QUERY_STRING_PARAMETER_WITH_YOUR_API_TOKEN Google Geocoding API docs How to store secrets securely on Gitpod If we look at the target and navigate to “Street to Coordinates”, BENP: video cuts out … the reason for that is, it costs money. Each time we’re making an API call, they are tracking our use and charging us if we are above some limit. GoogleMaps has a very high limit of API calls before charging begins, but the text messaging in the “Translate” page costs money for every message. That is why we have password secured the target in this case. So this is something to keep in mind: if you start to play around with APIs and sign up for an account with a credit card, then be careful with your API credentials! In this project any necessary API credentials are made available to you BENP: these are from Canvas and probably should not be / or should be changed in the final material. ALL API KEYS LABELLED AS TODO: TWILIO_ACCOUNT_SID : TODO TWILIO_AUTH_TOKEN : TODO TWILIO_SENDING_PHONE_NUMBER : TODO MAILGUN_API_KEY : TODO MAILGUN_SENDING_DOMAIN : TODO GMAPS_KEY : TODO DARK_SKY_KEY : TODO TRANSLATE_PROJECT : omnicalc TRANSLATE_CREDENTIALS : { TODO } So you can feel free to play around. But with your own credentials, be careful and protect them. BENP: could link to storing-credentials-securely.md content here How do I begin to think about tackling “Street to Coordinates”? I have an address and I want the latitude and longitude. I don’t want to use my company resources to building up a huge database of this information that I can lookup in. So let’s use Google’s Geocoding API. The first step of any API work is doing some homework. Search around on the internet for different options and read through some of the documentation. If we look around in the Google documentation, we would find a URL: https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY What do we see? We have an address: https://maps.googleapis.com/maps/api/geocode/json and a query string: ?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY. And we can see the query string includes an address= variable, and a key= variable. If we try to visit the URL as it is, we would see a page like: // 20221217132605 // https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY { &quot;error_message&quot;: &quot;The provided API key is invalid. &quot;, &quot;results&quot;: [ ], &quot;status&quot;: &quot;REQUEST_DENIED&quot; } We see an error message. Because we need to replace YOUR_API_KEY, with our API key! So we can go into a new tab and try to do that with our GMAPS_KEY BENP: this key is expired and needs to be changed everywhere above and below: https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=TODO And when we enter this address in the tab, we should see a very long JSON file displayed in our browser, something like: // 20221217131844 // https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=TODO { &quot;results&quot;: [ { &quot;address_components&quot;: ... } ... ] } There may be several hundred lines displayed and it may not be broken into readable lines if you don’t have a third party extension like JSON Viewer for Chrome. If you examine the page, you will see lots of information about the address we entered. JSON, or Javascript Object Notation, is not the same format as HTML. JSON is somewhat similar to CSV, and there is another format called XML that many APIs use. These are all just different data formats that are much easier to parse programmatically compared to HTML. If I change the query string in my URL to whatever I want (even with spaces): https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO Then the JSON information will change to give me information on that address 5807 S Woodlawn Ave. If I look carefully and scroll down, I could even find the following: ... &quot;location&quot;: { &quot;lat&quot;: 41.7891387, &quot;lng&quot;: -87.5954555 }, ... Ahh, just what we needed to display on our “Street to Coordinates” result page! Wow, APIs seem intimidating, but in reality it’s just a URL that we provide and we get back information from a database owned by some company. Once we get to the stage of entering a URL with some form data and receiving a response, then it’s actually pretty simple to finish our app. Now it’s time to actually get our form and results working. We’ll start by just copying our working URL into the experiment action in our GitPod app: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“5”} (You may see %20 characters in the place of the URL spaces we put in, like 5807%20S%20Woodlawn%20Ave. You can copy those in too, they just mean “space”.) And now we can use some cool methods for opening (open built into Ruby): # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url) render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“7”} Now if we open our view template and inject this instance variable in: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; &lt;%= @raw %&gt; {: mark_lines=“3”} then load the URL /experiment in our app browser, we will see “#” or something similar. This is an object of class String, which contains that page. We can call another method on this in the view template: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; &lt;%= @raw.read %&gt; {: mark_lines=“3”} which will get the body of the page and return is as a string when we refresh the browser. This will be the entire (long) JSON string. We can put all this into the action: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url).read render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“7”} We could now remove the .read from our HTML view template. We can go into our action and change address=5807 S Woodlawn Ave in the URL to whatever we want (e.g., address=Miami FL), and if we refresh /experiment then we will see the JSON changing. The page now dynamically reacts using information from the Google API. Now, we can also parse the JSON (which is currently just a long String variable) to get just the information we want. We don’t want to directly parse the string (e.g., with .split()). There is a much better way: we can convert it into a Hash using the built in class JSON and one of its methods, parse(), to convert it to a Hash. Then we can take our Hash, bury through the key/value pairs (there are Hashes within the Hash!), and figure out where the latitude and longitude values are to then pull out (.fetch()) as instance variables and put on our webpage. Alltogether that looks like: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url).read @parsed = JSON.parse(@raw) # parsed is now a Hash class # and we bury down into the hash with the key/value pairs # to get what we want @results = @parsed.fetch(&quot;results&quot;) @geom = @results.fetch(&quot;geometry&quot;) @loc = @geom.fetch(&quot;location&quot;) @lat = @loc.fetch(&quot;lat&quot;) @lng = @loc.fetch(&quot;lng&quot;) render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“9-17”} And display that in our experiment template: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; Latitude &lt;%= @lat %&gt;, Longitude &lt;%= @lng %&gt; {: mark_lines=“3”} Now, we hard-coded an address 5807 S Woodlawn Ave into our experiment action in the @url variable, so we would need this to come from an associated input form so the user could change this string. That is not required, but is good practice if you implement it. 15.4.1 Text Companion: Intro to APIs with Street to Coordinates "],["finish-and-submit-omnicalc-2.html", "15.5 Finish and Submit Omnicalc 2", " 15.5 Finish and Submit Omnicalc 2 Notes: Below are relevant notes for the rest of the project taken from the README API stretch goal should maybe go in a separate place? BENP: I think all of this additional API stuff needs to go in a separate document with links to google-translate.md and sending-emails-and-texts.md documents that right now are just linked as optional exercises on the Day 5 material on Canvas 15.5.1 Your tasks Street to Coordinates: Figure out how to turn an arbitrary street address (find a place that is sort of rainy right now to test with) into a latitude/longitude using the Geocoding API. Coordinates to weather: Figure out how to turn a latitude/longitude pair into a weather forecast using the Dark Sky API Show the information displayed in the target: Current Temperature Current summaray Outlooks for next sixy minutes, several hours, several days Street to Weather: Put the above two together — given an arbitrary street address, display the forecast. 15.5.2 Stretch goal Stretch goal: check whether there is a &gt;50% chance of precipitation at any point during the next 12 hours. If so, we will print “You should take an umbrella!” Explore the API documentation to see what information is available to help you check this. Something that might or might not be useful: the Time.at method. (Humans have many, many different ways of representing dates. For the purposes of different pieces of software being able to agree on dates and times, most systems when talking to each other use Epoch time notation, or the number of seconds that have passed since midnight UTC on January 1st (minus leap seconds). Dark Sky, for example, includes times in this format. You can use Time.at() to convert to something more familiar, if you want to.) Put all of the pieces together; given an arbitrary address: print the current temperature print outlook for the next hour print whether a person should carry an umbrella. 15.5.3 Using gems to interact with APIs Notes: from https://github.com/appdev-targets/omnicalc-2-api-starting-point#using-gems-to-interact-with-apis Interacting with APIs can be easier if someone has written a Ruby library (or “gem”) with methods that already know the URLs, parse the JSON, and return exactly the values we want. 15.5.3.1 Twilio In your Gemfile, add: gem &quot;twilio-ruby&quot; Then, at a Terminal prompt: bundle install You will then have access to the Twilio::REST::Client class. It is used like this: # Retrieve your credentials from secure storage twilio_sid = ENV.fetch(&quot;TWILIO_ACCOUNT_SID&quot;) twilio_token = ENV.fetch(&quot;TWILIO_AUTH_TOKEN&quot;) twilio_sending_number = ENV.fetch(&quot;TWILIO_SENDING_PHONE_NUMBER&quot;) # Create an instance of the Twilio Client and authenticate with your API key twilio_client = Twilio::REST::Client.new(twilio_sid, twilio_token) # Craft your SMS as a Hash with three keys sms_parameters = { :from =&gt; twilio_sending_number, :to =&gt; &quot;+19876543210&quot;, # Put your own phone number here if you want to see it in action :body =&gt; &quot;It&#39;s going to rain today — take an umbrella!&quot; } # Send your SMS! twilio_client.api.account.messages.create(sms_parameters) Sign up for your own Twilio account — if use this referral link you’ll $10 in credit, and so will our class account. Twilio Ruby Quickstarts 15.5.3.2 Google Cloud Translate Google Cloud Translation Here’s the crux of using the official Google Translate gem. Add the gem to your Gemfile: # /Gemfile gem &quot;google-cloud-translate&quot;, &quot;2.3.0&quot; Then bundle install and restart your web server. You now have access to the Google::Cloud::Translate class. To use it: require &quot;google/cloud/translate&quot; gt_client = Google::Cloud::Translate.new({ :version =&gt; :v2 }) translation = gt_client.translate(&quot;Hello, world!&quot;, { :to =&gt; &quot;es&quot; }) Amazing! (If that didn’t work, ensure that you’ve added my API credentials as environment variables on Gitpod. You can find them in Canvas.) To list all available languages, languages = gt_client.languages(&quot;en&quot;) # The argument determines what language to list the other language names in languages.size #=&gt; 104 languages[0].code #=&gt; &quot;af&quot; languages[0].name #=&gt; &quot;Afrikaans&quot; Stretch goal: Make your app behave like the target Read more at the gem docs: Ruby gem documentation "],["refactoring-fortune-teller-with-dynamic-routes.html", "16 Refactoring Fortune Teller with Dynamic Routes", " 16 Refactoring Fortune Teller with Dynamic Routes Notes: There is no video yet, everything is in the chapter refactoring-fortune-teller-with-dynamic-routes.md, copied in below Project (graded): https://github.com/appdev-projects/refactoring-fortune-teller Target: https://refactoring-fortune-teller.matchthetarget.com Useful chapters: refactoring-fortune-teller-with-dynamic-routes.md rcav-flowchart.md This chapter is the companion to the refactoring-fortune-teller project, which is the sequel to the the fortune-teller project. "],["part-1-dice.html", "16.1 Part 1: Dice", " 16.1 Part 1: Dice Notes: dynamic route segments Copied from refactoring-fortune-teller-with-dynamic-routes.md chapter section get(\"/roll/:number_of_dice/:how_many_sides\", { :controller =&gt; \"dice\", :action =&gt; \"infinity_and_beyond\" }) params.fetch(\"number_of_dice\") and params.fetch(\"how_many_sides\") Our starting point code for refactoring-fortune-teller is the target code for fortune-teller. So, in the code you’re starting with, the horoscopes from Part 2 of fortune-teller have already been debugged, and the dice from Part 3 of fortune-teller have already been built out. In refactoring-fortune-teller, our goal is to keep everything working exactly the same way that it is; we’re not going to add much. But we’re going to get rid of 90% of the lines of code, while keeping the functionality the same. How? With dynamic route segments. Consider our new target: https://refactoring-fortune-teller.matchthetarget.com/roll/2/6 Seems like the same thing that we had before, right? Well, try this URL instead: https://refactoring-fortune-teller.matchthetarget.com/roll/42/1337 That’s a lot of 1337-sided dice. Try any combination of two numbers you want in the second and third segments of the path. You’ll see that they all work! Obviously, I didn’t just happen to add routes for the exact pairs of numbers you chose. Instead, there’s only one route handling all of the dice rolls; it matches URLs that starts with /roll/ and have two more segments, but allows any values to appear in the last two segments. In the action, Rails allows us to examine what values were in those spots, and customize the response accordingly. How do we get access to the values? Through our old friend, the params hash! Let’s see how: First, in your own app, try visiting a URL like this: /roll/2/6 It should work. First, follow the R→C→A→V through and familiarize yourself with the code. Now, try visiting a URL like this: /roll/42/513 You will get a “no route matches” error. Let’s first make it so that users can visit any URL of the form /roll/X/Y and it will not throw an error, no matter what X and Y are: If we set up a route like this (for now let’s send it to the existing two_six action): BENP: Why not :dice and :sides in place of :zebra and :giraffe? I see this is done later, but maybe just do it right away to compress the section a bit further. This follows my notes in Fortune Teller Part1. get(&quot;/roll/:zebra/:giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) and then try visiting /roll/42/513 again, the route does match, and you get sent to the old action for two six-sided dice. What happens if you change the route to: get(&quot;/roll/zebra/giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) (removing the colons before zebra and giraffe) and visit /roll/42/513 again? “No route matches.” Ok, put the colons back: get(&quot;/roll/:zebra/:giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) So, by beginning a segment of a path with a colon, we’re making it dynamic. Rails will, for the purpose of routing, allow anything there; it’s like a wildcard. Now, watch your server log while visiting the URL: Parameters: { &quot;zebra&quot; =&gt; &quot;42&quot;, &quot;giraffe&quot; =&gt; &quot;513&quot; } It’s just like when we got inputs from the query string! Except, in this case, the keys in the hash were determined by us in advance, in the route; rather than being tacked on to the end of the URL itself by the visitor (or a form). Try visiting the following URL paths in your browser: /roll/alice/bob /roll/42/513/alice /42/513 Which ones throw a “no route matches” error and which ones don’t? What appears in the params hash in your server log?6 Okay, from here, we .fetch the data from the params hash, just as we did before when learning about query strings. Let’s make up a new action, instead of messing with two_six; and let’s use more meaningful labels for the dynamic segments than :zebra and :giraffe: BENP: see previous zebra note. Could remove above text and below code get(&quot;/roll/:number_of_dice/:how_many_sides&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;infinity_and_beyond&quot; }) Now, when we visit /roll/42/513, we get a “missing action” error, as expected. Let’s define the infinity_and_beyond action and make it say “hi” as usual: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... BENP: Above: I have used ... rather than # ... in other code blocks. Will need to be changed. &lt;%# app/views/dice_templates/infinity.html.erb %&gt; &lt;h1&gt;hi&lt;/h1&gt; BENP: Above and throughout, we have a specific erb code style? I have just been using html in previous transcription docs. These may need to be changed here or in my notes. Test it out and make sure you wired up your R→C→A→V correctly; if not, read the error messages, RTEM, and debug. Now, let’s .fetch the information from the params hash that we need to make this response intelligent: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond @num_dice = params.fetch(&quot;number_of_dice&quot;) @num_faces = params.fetch(&quot;how_many_sides&quot;) render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... {: mark_lines=“5-6”} I made the variables instances variables instead of local variables, by starting them with @, under the assumption that I will want to use them in the view template. And we can use logic similar to the logic in all the other actions to actually create an array of “dice rolls”: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond @num_dice = params.fetch(&quot;number_of_dice&quot;) @num_faces = params.fetch(&quot;how_many_sides&quot;) @array_of_rolls = Array.new @num_dice.to_i.times do @array_of_rolls.push(rand(@num_faces.to_i) + 1) end render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... {: mark_lines=“8 10-12”} and then draw them in the template: &lt;%# app/views/dice_templates/infinity.html.erb %&gt; &lt;h1&gt; &lt;%= @num_dice %&gt;d&lt;%= @num_faces %&gt; &lt;/h1&gt; &lt;ul&gt; &lt;% @array_of_rolls.each do |a_roll| %&gt; &lt;li&gt; &lt;%= a_roll %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“3-14”} And, voilà, it should work — and it should work for any combination of dice and faces! Including the 18 combinations that we had before. Comment out all the old routes and click on all the links in the nav — they still work! Gleefully, delete all the old routes, actions, and view templates — we love deleting code. That’s less costly code to maintain. But wait! Are you sure you didn’t forget and break some old functionality that we had before? How can we be sure? A question to ponder. Did you actually go visit those URLs? Why not? Do or do not; there is no read.↩︎ "],["part-2-horoscopes.html", "16.2 Part 2: Horoscopes", " 16.2 Part 2: Horoscopes Notes: dynamic route segments, our own classes Copied from refactoring-fortune-teller-with-dynamic-routes.md chapter section Zodiac class in app/models/ get(\"/zodiacs/:the_sign\", { :controller =&gt; \"fortunes\", :action =&gt; \"horoscopes\" }) String#to_sym regressions and refactoring, importance of automated tests Let’s try to do something similar for the zodiacs; that is, let’s see if we can use a dynamic route segment to reduce the amount of code. It won’t be quite as straightforward as with the dice, because there’s actual data (the horoscopes) that isn’t the same on each page; it’s not as formulaic as generating random numbers based on the ones that are in the URL. But, if we had a way to look up the horoscope given the astrological sign that’s in the URL, then the rest of every action would be the same. Generate lucky numbers, and populate a template that’s the same for every action. Imagine you had a hash of hashes that had all of the signs and horoscopes within it, something like an API response — then could you make a single RCAV that supported all 12 zodiacs? If you had a hash like this available to you: { :aries =&gt; { :name =&gt; &quot;Aries&quot;, :horoscope =&gt; &quot;As your professional dreams unfold, Aries, you may worry about the downside. First, there are new responsibilities that you might doubt your ability to fulfill. Second, you might be catapulted into an uncomfortable new realm of office politics. Don&#39;t let these matters put a damper on your enthusiasm. You have what it takes to fulfill the first concern and the wisdom to avoid the second. Onward and upward.&quot; }, :leo =&gt; { :name =&gt; &quot;Leo&quot;, :horoscope =&gt; &quot;Success on all levels is filling your life and making you feel absolutely wonderful, Leo. The downside of this is that you might be a little too conscientious. Are you putting in a lot of extra hours? Be discriminating about this and don&#39;t work harder than necessary. You could get stressed to the point of taxing your strength too much, and that won&#39;t help you. Pace yourself.&quot; }, # etc } Fortunately, you do. I’ve created a class called Zodiac, and I gave it class-level method called list which returns that exact hash above7. Give the Zodiac class a try. For example, in the FireController#ram action, you can replace: @horoscope = &quot;As your professional dreams unfold, Aries, you may worry about the downside. First, there are new responsibilities that you might doubt your ability to fulfill. Second, you might be catapulted into an uncomfortable new realm of office politics. Don&#39;t let these matters put a damper on your enthusiasm. You have what it takes to fulfill the first concern and the wisdom to avoid the second. Onward and upward.&quot; With: all_zodiacs = Zodiac.list this_zodiac = all_zodiacs.fetch(:aries) @horoscope = this_zodiac.fetch(:horoscope) Verify that your /zodiacs/aries action still works just like before. If you’re curious, the Zodiac class is in the app/models/ folder — you can go have a look at it, if you like. When we want to define a new Ruby class within a Rails app, we create a file for it in the app/models/ folder. The filename is important — it should exactly match the class name, but lowercased BENP: snake_cased instead of lowercased?, just like when we create controller classes (e.g., fire_controller.rb containing FireController). In this case, I created a file called zodiac.rb within app/models/, and boom — everywhere within the Rails application (all controllers, all views, even within other models), we have access to the Zodiac class; and we can call Zodiac.list. We’ll talk a lot more about models in the coming weeks, but for now you can just use the Zodiac.list method I provided; just know that it returns a hash of hashes with the keys as shown above. You know how to work with hashes. Now, your task is: with what you’ve learned about dynamic route segments, and with the ability to look up a horoscope given a sign, can you replace all 12 of the R→C→A→Vs for zodiacs with just one R→C→A→V? get(&quot;/zodiacs/:the_sign&quot;, { :controller =&gt; &quot;fortunes&quot;, :action =&gt; &quot;horoscopes&quot; }) You can pick whatever controller and action name you like, but when you’re done the application should function exactly the same as before. 16.2.1 String#to_sym If we try to access an element in a Hash that looks like this: zodiacs = { :aries =&gt; &quot;stuff&quot;, :leo =&gt; &quot;more stuff&quot;, } with a String key \"leo\": zodiacs.fetch(&quot;leo&quot;) we’ll get the familiar error message: KeyError (key not found: &quot;leo&quot;) because the String, \"leo\", is not the same as the Symbol, :leo. Remember that all values in the params hash come to us as Strings. Just as we had to convert these Strings to Floats with .to_f before doing math on them in Omnicalc, we’ll have to convert them to Symbols if we want to use them to key into the Hash returned by Zodiac.list. Fortunately, there’s a handy method .to_sym that will do just that: &quot;hello&quot;.to_sym # =&gt; :hello With the .to_sym method in hand, you should be able to use params and Zodiac.list to replace all 12 actions with 1! Can you define a class and a class-level method like this? You ought to be able to, with what you’ve learned about Our own classes and Hashes.↩︎ "],["regressions.html", "16.3 Regressions", " 16.3 Regressions How can you be sure that it functions exactly the same as before? Well, in this case, since we had automated tests for Part 2, you can run rails grade! Isn’t it a nice, safe feeling to be able to run the tests to know that you didn’t introduce any regressions? "],["refactoring.html", "16.4 Refactoring", " 16.4 Refactoring What we just did is called refactoring: In computer programming and software design, code refactoring is the process of restructuring existing computer code — changing the factoring — without changing its external behavior. Refactoring is intended to improve the design, structure, and/or implementation of the software (its non-functional attributes), while preserving its functionality. Potential advantages of refactoring may include improved code readability and reduced complexity; these can improve the source code’s maintainability and create a simpler, cleaner, or more expressive internal architecture or object model to improve extensibility. Wikipedia, “Code refactoring” Refactoring is a crucial part of the software development process. First, we write messy, clunky, repetitive, but easy to understand and most importantly functional code; then, only after having wrapped our heads around the problem by solving it, we sit back and take a moment to think about whether there might be a more readable or less complex or more performant solution. However, once we have a working solution, it’s often very tempting to just leave it alone; why mess with a good thing and risk introducing bugs? Especially if you’re dealing with a large, old, complicated system that you didn’t build entirely yourself; it can be irresponsible to refactor willy nilly if you don’t fully understand what you’re changing (see Chesterton’s fence). And yet, we do need to make changes to our codebase over time; even if we’re satisfied to never refactor, we at some point have to add new features or make security patches. How do we make sure we don’t inadvertently break anything or introduce bugs? No matter how good our quality assurance team is, it’s not realistic to expect them to manually examine every user path through the app and verify that it still works, with every combination of possible inputs, every single time any developer makes any change. The answer: automated tests. This is why developers invest so much time and effort in writing automated test suites (this is what you’ve been running every time you do a rails grade). Automated tests are nothing more than a separate Ruby script that, essentially, web scrapes our own app, clicks every link, fills out every form, with every possible combination of inputs, and makes sure that the app is doing the right thing under all scenarios. As you might imagine, this self-web-scraping script takes a long time to write; often, longer than a feature itself. But, if you plan to maintain a codebase over the long term (not always true for e.g. a throwaway prototype), it is well worth the investment. "],["finish-and-submit-refactoring-fortune-teller.html", "16.5 Finish and Submit Refactoring Fortune Teller", " 16.5 Finish and Submit Refactoring Fortune Teller 16.5.1 Optional extra challenge Can you refactor RPS RCAV to use only one action instead of three for the URLs /rock, /paper, and /scissors? "],["dashboards-dynamic-route-segments.html", "17 Dashboards (Dynamic Route Segments)", " 17 Dashboards (Dynamic Route Segments) Notes: Original video transcription is in dashboards.md Project (graded): https://github.com/appdev-projects/dashboards And here is a snapshot of the Omnicalc 2 workspace, which may be useful as reference. Target: http://dashboards.matchthetarget.com/ Useful chapters: refactoring-fortune-teller-with-dynamic-routes.md "],["video-segment-urls-and-dynamic-routes.html", "17.1 Video Segment: URLs and Dynamic Routes", " 17.1 Video Segment: URLs and Dynamic Routes Notes: time stamp 00:00:00 to 00:02:00 dynamic route segments in params. sometimes we call these flexible routes. using /chapters/841 as example wildcards The modern world revolves around the humble URL. And now I hope you’re staring to notice these and understand them a little bit better. For example the refactoring Fortune Teller chapter: https://chapters.firstdraft.com/chapters/841 You’ve got a path /chapters/841 with two segments, chapters and 841, just like in our dice rolls from refactoring: https://refactoring-fortune-teller.matchthetarget.com/roll/42/1337. We know how to connect a visit to the full path to a Ruby method that can generate dynamic content rather than just having static pages in the public/ folder. After your experience refactoring, you now also know that you can have parts of the path that are dynamic. So we don’t need to write a route for every single URL that we want to support. We can allow pieces of the path to be wildcards (like 841 in our chapter example), and in doing so we can support an infinite number of URLs because anything that matches a certain pattern will be recognized and routed to a single action that knows how to handle all requests of that variety. So this is a second form of user input. The first form was query stings in the URL, and these are the dynamic route segments, which is how users tell us which resource they want. And that’s it for user input! Both of them end up in our params hash, which we can .fetch() from. 17.1.1 Text Companion: URLs and Dynamic Routes "],["video-segment-exchange-rate-api-intro.html", "17.2 Video Segment: Exchange Rate API Intro", " 17.2 Video Segment: Exchange Rate API Intro Notes: time stamp 00:02:10 to 00:03:56 explore https://api.exchangerate.host/symbols discuss JSON format using /symbols and /convert In this next project, let’s finally use some more realistic data. Enough with random numbers and rock, paper, scissors. Let’s get some actual data from APIs like we did with the umbrella project. BENP: did they do this project? The first API that we’re going to use is called https://api.exchangerate.host/symbols. It gives us back JSON that looks like this: // 20221219122429 // https://api.exchangerate.host/symbols { &quot;motd&quot;: { &quot;msg&quot;: &quot;If you or your company use this project or like what we doing, please consider backing us so we can continue maintaining and evolving this project.&quot;, &quot;url&quot;: &quot;https://exchangerate.host/#/donate&quot; }, &quot;success&quot;: true, &quot;symbols&quot;: { &quot;AED&quot;: { &quot;description&quot;: &quot;United Arab Emirates Dirham&quot;, &quot;code&quot;: &quot;AED&quot; }, &quot;AFN&quot;: { &quot;description&quot;: &quot;Afghan Afghani&quot;, &quot;code&quot;: &quot;AFN&quot; }, // ... Where we can see many currencies (even crypto!). This is a free API. If you put in any of their supported symbols, it will instantaneously and for free give you back the current exchange rate. For example if we use the URL to go from USD to Euros: https://api.exchangerate.host/convert?from=USD&amp;to=EUR Then we get back: // 20221219123153 // https://api.exchangerate.host/convert?from=USD&amp;to=EUR { &quot;motd&quot;: { &quot;msg&quot;: &quot;If you or your company use this project or like what we doing, please consider backing us so we can continue maintaining and evolving this project.&quot;, &quot;url&quot;: &quot;https://exchangerate.host/#/donate&quot; }, &quot;success&quot;: true, &quot;query&quot;: { &quot;from&quot;: &quot;USD&quot;, &quot;to&quot;: &quot;EUR&quot;, &quot;amount&quot;: 1 }, &quot;info&quot;: { &quot;rate&quot;: 0.942959 }, &quot;historical&quot;: false, &quot;date&quot;: &quot;2022-12-19&quot;, &quot;result&quot;: 0.942959 } This is great for us to practice our dynamic routes and APIs. We’ll use the two api.exchangerate.host endpoints for listing symbols /symbols and converting currencies /convert to build our target. Full documentation for the API can be found here 17.2.1 Text Companion: Exchange Rate API Intro "],["video-segment-building-forex.html", "17.3 Video Segment: Building /forex", " 17.3 Video Segment: Building /forex Notes: time stamp 00:03:56 to 00:22:39 RCAV /forex URL that lists all available currency symbols from JSON keys at https://api.exchangerate.host/symbols The first thing we’re going to build and the required part of this homework is a route that looks like /forex (https://dashboards.matchthetarget.com/forex in our target). This URL should list all of the available symbols, and if I click on one of the links it should take me to a page with the path: /forex/EUR, where the second segment is the currency I clicked. And on that page it should give me all of the symbols, including the current symbol itself. Clicking on a given link there (like “Convert 1 EUR to USD…”), will take me to the URL: /forex/EUR/USD, where I will see the conversion rate. Of course I could type in manually, like: /forex/EUR/MWK if I know the what these URLs look like and how what symbol corresponds to what currency. So you’re job is to build all of that. It should be doable with what you know about dynamic route segments and reading APIs BENP link to dynamic route and reading API content. If you feel up to the challenge, pause the video now and try to build the routes yourself! BENP: suggested pause point at 00:06:00 I’m going to do my usual thing. Start up GitPod, start the server, type in the URL I want to build as a user in the browser, and just start debugging the error messages. Let’s visit config/routes.rb, and we will see it is a completely blank Rails app that we are dealing with. We will start by building /forex. So let’s add the route: # config/routes.rb Rails.application.routes.draw do get(&quot;/forex&quot;, { :controller =&gt; &quot;currencies&quot;, :action =&gt; &quot;first_currency&quot; }) end {: mark_lines=“5”} From now on, we are not putting our actions in ApplicationController, so I made up a name called \"currencies\" for the controller and an action within that called \"first_currency\" (because this action will list the first currency in the exchange rate calculation). (As usual, between every step I refresh my browser /forex path, and RTEM.) So now in app/controllers/, I can make a new controller file called currencies_controller.rb, and fill that in with my inheritence from ApplicationController and my action: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end end We made up names for our view templates folder (\"currency_templates/\") and file (\"step_one.html.erb\"), so we need to create both of these in app/views/, and fill in some dummy copy: &lt;!-- app/views/currency_templates/step_one.html.erb --&gt; hi Now everything should be wired up correctly and we can think about the actual work to be done. It can be helpful to start by just mocking up the document with some static HTML to form an outline. We can right-click and “View Source” on the target to help us with the proper HTML tags. We can just copy-paste in the first lines of the body in this case and clean it up a bit. &lt;!-- app/views/currency_templates/step_one.html.erb --&gt; &lt;h1&gt;Currency pairs&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;/forex/AED&quot;&gt; Convert 1 AED to... &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; {: mark_lines=“3-13”} So now we have a starting point. What we need is to get a list of all the symbols like AED above from the API, and print them out in an unordered list of links. We don’t want to hard code the list, we want to get it fresh everytime in case the list of symbols (currencies) changes. From our API endpoint https://api.exchangerate.host/symbols, we just need the currency symbols from the JSON. It might be nice to show the currency name (description): ... - AED: { description: &quot;United Arab Emirates Dirham&quot;, code: &quot;AED&quot; } ... but the target doesn’t do that, so we really just need the keys from the sub-hash. Let’s return to our view template and write in some pseudo-code for what we wish that we had: &lt;!-- app/views/currency_templates/step_one.html.erb --&gt; &lt;h1&gt;Currency pairs&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;% @array_of_symbols.each do |a_symbol| &gt; &lt;li&gt; &lt;a href=&quot;/forex/AED&quot;&gt; Convert 1 AED to... &lt;/a&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8 14”} If we had an @array_of_symbols containing all of our currency symbols, we could loop over it with .each, take each a_symbol variable, and replace AED with that symbol, thus building up a long unordered list. Okay, we need to create our desired instance variable in the controller action now: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end end {: mark_lines=“6”} We need the URL that has the data (https://api.exchangerate.host/symbols), then we need to use the method open() on that string, and finally we need to call the read method on the opened file, which will return the file as a long string. (Normally, we would need a line require \"open-uri\" to allow Ruby to read files across the internet, but we don’t have to do that in Rails, because Rails has already done that for its own operation.) Once we have the file opened as a string with read in the @raw_data variable, we can convert it to a hash using JSON.parse(): # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end end {: mark_lines=“7”} Now if we view the @parsed_data in our view template (by adding &lt;%= @parsed_data %&gt;), we will see our full hash. And at this point it’s just a matter of peeling off each layer of the onion, and burying into the hash to pull out the symbols: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end end {: mark_lines=“8-9”} We used the handy .keys method on our sub-hash (that we .fetch()ed from the full hash), because the list of symbols is actually contained in the key names. No need to use a second .fetch() in this case. Now we should be good to go in our template, by replacing the AED (in the copy and href link!) with our embedded Ruby tags for each symbol in the array: &lt;!-- app/views/currency_templates/step_one.html.erb --&gt; &lt;h1&gt;Currency pairs&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;% @array_of_symbols.each do |a_symbol| %&gt; &lt;li&gt; &lt;a href=&quot;/forex/&lt;%= a_symbol %&gt;&quot;&gt; Convert 1 &lt;%= a_symbol %&gt; to... &lt;/a&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“10-11”} In the above, we included embedded Ruby in our HTML tag attribute (href=\"\"). This is very common! We often need to include dynamic responses in the attributes to HTML to get our pages to behave correctly. And now the page /forex should behave like the target. Time for a rails grade and /git commit. Try to tackle the next route /forex/SYMBOL, and maybe even /forex/SYMBOL/SYMBOL, on your own. How can you build a dynamic route to support every possibility here, so you don’t need to hard-code hundreds of individual routes? 17.3.1 Text Companion: Building /forex "],["video-segment-building-forexsymbolsymbol.html", "17.4 Video Segment: Building /forex/SYMBOL/SYMBOL", " 17.4 Video Segment: Building /forex/SYMBOL/SYMBOL Notes: time stamp 00:22:39 to 00:33:01 RCAV /forex/SYMBOL/SYMBOL URL with dynamic route segments that lists all available currency exchange rates from JSON at https://api.exchangerate.host/convert with query strings like ?from=USD&amp;to=EUR Let’s start with the next step, where a user can select a currrency on /forex, which brings them to /forex/SYMBOL, where they can select a second currency bringing them to the exchange rate on /forex/SYMBOL/SYMBOL. We begin by simulating what we want to work by navigating our browser to /forex/AWG, RTEM, and starting the RCAV: # config/routes.rb Rails.application.routes.draw do get(&quot;/forex&quot;, { :controller =&gt; &quot;currencies&quot;, :action =&gt; &quot;first_currency&quot; }) get(&quot;/forex/...&quot;, { :controller =&gt; &quot;currencies&quot;, :action =&gt; &quot;second_currency&quot; }) end {: mark_lines=“7”} Where we have /... above, we want a dynamic route wildcard that can be pulled out in the params, otherwise, we have the usual controller (same as our previous) and a new action we will make in that controller (\"second_currency\"). We don’t want to type /AWG, because that is just one of our many currencies. But, if we remember our dynamic routes BENP: link to dice here, we know we can use a symbol to make it flexible, like so: # config/routes.rb Rails.application.routes.draw do get(&quot;/forex&quot;, { :controller =&gt; &quot;currencies&quot;, :action =&gt; &quot;first_currency&quot; }) get(&quot;/forex/:from_currency&quot;, { :controller =&gt; &quot;currencies&quot;, :action =&gt; &quot;second_currency&quot; }) end {: mark_lines=“7”} Now our routing error in the browser should be gone and we can move on to making the action in our controller: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end def second_currency render({ :template =&gt; &quot;currency_templates/step_two.html.erb&quot; }) end end {: mark_lines=“14-17”} And we will right away add some static markup from the target (“View Source”) into our view template: &lt;!-- app/views/currency_templates/step_two.html.erb --&gt; &lt;h1&gt;Convert AWG&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/forex&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;/forex/AWG/INR&quot;&gt; Convert 1 AWG to INR... &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;/AWG/EUR&quot;&gt; Convert 1 AWG to EUR... &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; This pattern of list items would need to be repeated over and over. So let’s make the static mockup dynamic by looping over the symbols array: &lt;!-- app/views/currency_templates/step_two.html.erb --&gt; &lt;h1&gt;Convert AWG&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/forex&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;% @array_of_symbols.each do |a_symbol| %&gt; &lt;li&gt; &lt;a href=&quot;/forex/AWG/&lt;%= a_symbol %&gt;&quot;&gt; Convert 1 AWG to &lt;%= a_symbol %&gt;... &lt;/a&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8-14”} And now back into our controller, just copy and pasting from our previous action: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end def second_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys render({ :template =&gt; &quot;currency_templates/step_two.html.erb&quot; }) end end {: mark_lines=“16-19”} Okay, it looks close. But we need to get the information out of our dynamic route /forex/SYMBOL to make our page change with each currency. Well everytime we visit a given route (by typing or clicking a link) like /forex/AWG, or /forex/INR, or /forex/EUR, because I defined my route dynamically in config/routes.rb as \"/forex/:from_currency\", if we view our server log in the GitPod terminal window when we visit the page, then we will see: Parameters: {&quot;from_currency&quot;=&gt;&quot;EUR&quot;} So we have the currency symbol in the hash, and we can pull it out and use it in our controller: # app/controllers/currencies_controller.rb class CurrenciesController &lt; ApplicationController def first_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys render({ :template =&gt; &quot;currency_templates/step_one.html.erb&quot; }) end def second_currency @raw_data = open(&quot;https://api.exchangerate.host/symbols&quot;).read @parsed_data = JSON.parse(@raw_data) @symbols_hash = @parsed_data.fetch(&quot;symbols&quot;) @array_of_symbols = @symbols.keys # params are # Parameters: {&quot;from_currency&quot;=&gt;&quot;EUR&quot;} @from_symbol = params.fetch(&quot;from_currency&quot;) render({ :template =&gt; &quot;currency_templates/step_two.html.erb&quot; }) end end {: mark_lines=“16-19”} And back on our template we embed the new instance variable in our previous AWG static mockup (it’s as easy as replacing every instance with &lt;%= @from_symbol %&gt;): &lt;!-- app/views/currency_templates/step_two.html.erb --&gt; &lt;h1&gt;Convert &lt;%= @from_symbol %&gt;&lt;/h1&gt; &lt;p&gt;Go &lt;a href=&quot;/forex&quot;&gt;back&lt;a&gt;.&lt;/p&gt; &lt;ul&gt; &lt;% @array_of_symbols.each do |a_symbol| %&gt; &lt;li&gt; &lt;a href=&quot;/forex/&lt;%= @from_symbol %&gt;/&lt;%= a_symbol %&gt;&quot;&gt; Convert 1 &lt;%= @from_symbol %&gt; to &lt;%= a_symbol %&gt;... &lt;/a&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“3 10-11”} And we have a dynamic route setup for the list of currency conversions! Test it manually, do a rails grade, and be sure to /git commit if everything looks good. The last step is to build the second currency symbol route, like /forex/AWG/USD. So you need to get two pieces of data out. You need to write a route that can accept two dynamic segments, fetch both of those segments from the params hash, and then use that to call the API: https://api.exchangerate.host/convert?from=AWG&amp;to=EUR, and finally extract the exchange rate from the JSON returned. 17.4.1 Text Companion: Building /forex/SYMBOL/SYMBOL "],["finish-and-submit-dashboards.html", "17.5 Finish and Submit Dashboards", " 17.5 Finish and Submit Dashboards Notes: covid tracking text at bottom of dashboards.md (from README) 17.5.1 The COVID Tracking Project API endpoint for a single state (Illinois): https://api.covidtracking.com/v1/states/ca/current.json Full documentation "],["classroom-domain-modeling.html", "18 Classroom Domain Modeling", " 18 Classroom Domain Modeling Notes: This was largely a Day 5 recording classroom exercise and is partially written up in day-5-domain-modeling.md Each ERD and Ideas Slides section could be a separate sub-section: 01-09: review MSM tables 10-11: Yap model 12-15: Photogram model 16-17: Very Best model 18: entity relationship diagrams 19-23: model Booth Ride Share, MyFitness, Chew, Mock Interviewer "],["review-msm-tables.html", "18.1 Review MSM Tables", " 18.1 Review MSM Tables "],["yap-model.html", "18.2 Yap Model", " 18.2 Yap Model "],["photogram-model.html", "18.3 Photogram Model", " 18.3 Photogram Model "],["very-best-model.html", "18.4 Very Best Model", " 18.4 Very Best Model "],["erds.html", "18.5 ERDs", " 18.5 ERDs "],["additional-models.html", "18.6 Additional Models", " 18.6 Additional Models slides 19-23: model Booth Ride Share, MyFitness, Chew, Mock Interviewer "],["omnicalc-debug.html", "19 Omnicalc Debug", " 19 Omnicalc Debug Notes: Optional un-graded assignment, but there are tests built in Project (ungraded): https://github.com/appdev-projects/omnicalc-debug Useful chapters: refactoring-fortune-teller-with-dynamic-routes.md README text at https://github.com/appdev-projects/omnicalc-debug#readme Reading: Rubber Duck Debugging "],["omnicalc-debug-readme.html", "19.1 Omnicalc Debug README", " 19.1 Omnicalc Debug README Here is your target The starting point of this app has four different forms which take input from users, some of which run through the Google Maps API and the DarkSky API, be sure to update your enviroment credientals. YOUR JOB: Debug all 4 forms. It might be helpful to keep the Forms chapter open while working. Debugging checklist: READ the error message. Extract as much useful information from it as possible. If there’s no error message, find another way to give yourself feedback; make the invisible visible. Use the server log. Print things; in this new world, that means use embedded Ruby tags (&lt;%= %&gt;) in the view templates. We can’t use the p method anymore since we aren’t writing command line programs anymore. If all else fails — the error message isn’t helpful, or there isn’t one and you can’t spot the issue visually — delete the offending code (or comment it out), and re-type the R→C→A→V from scratch. Hopefully you’ve been making lots of git commits, so there’s no fear in doing so. "],["apis-demo.html", "20 APIs Demo", " 20 APIs Demo Notes: Google Translate and SMS with Twilio, Optional No video, just the chapters below Project: Start: https://github.com/appdev-targets/omnicalc-2-api-starting-point Solution: https://github.com/appdev-targets/omnicalc-2-api-starting-point/tree/translate-solution Target: https://omnicalc-2.matchthetarget.com/ Useful chapters: storing-credentials-securely.md google-translate.md sending-emails-and-texts.md "],["apis-demo-readme.html", "20.1 APIs Demo README", " 20.1 APIs Demo README Notes: see Omnicalc 2 lesson section Using gems to interact with APIs "],["must-see-movies-queries-intro-to-databases.html", "21 Must See Movies Queries (Intro to Databases)", " 21 Must See Movies Queries (Intro to Databases) Notes: Original video transcription is in MSM-queries.md Project (graded): https://github.com/appdev-projects/msm-queries Target: https://msm-queries.matchthetarget.com/ Useful chapters: active-record.md our-own-classes.md BENP: MSM should be written out when possible (similar to RPS) "],["video-segment-recordkeeping-review-exploring-the-target.html", "21.1 Video Segment: Recordkeeping Review, Exploring the Target", " 21.1 Video Segment: Recordkeeping Review, Exploring the Target -Notes: time stamp 00:00:00 to 00:04:30 showing Bird’s Eye View Slides 72-73 database backed web appplication explore /directors/youngest and /directors/eldest explore index (tables) and show (details) pages BENP: Video starts with review of some Day 1 slides 01. Bird’s Eye View. Just Slide 71 and 72. This is a very big day. Remember eons ago, back on Day 1, when I claimed the killer application of computing is just recordkeeping? And we spend a lot of time and effort learning how to architect database tables, and figure out what information applications have to keep track of on behalf of their users, and how to design database tables to be capable of keeping track of that information in a way that allows a database to grow in the right direction. Now finally after all this time, we know enough HTML, we know enough Ruby, we know about routing, we know about params, and we’ve been populating our embedded Ruby templates with information from forms (data from our users), and we’ve even gotten information from external APIs and populated our embedded Ruby templates with useful info from someone else’s database. Finally it’s time for us to store the information that users are typing into forms in our own databases and then populate our Ruby templates with information from those database tables. Thus, we come back around on our original goal of building a database backed web application. In other words, we’re going to build Software as a Service. So let’s get started. BENP: Starting our GitPod Workspace, 00:01:45 to 00:01:54 Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project is here. If we take a look at the target homepage at the path /, we will see the familiar movies, directors, and actors database content that we have been diagramming. We will build a simple web application that displays this data in a very straightforward manner. There’s a list of all directors and a details page for each director. About as simple as you can imagine for our first contact with a database driven web application. We also have a page that shows just the youngest director (/directors/youngest) and just the eldest (/directors/eldest). This will give us practice on how to narrow and query our data for just specific pieces of information. If we were to go and delete the eldest director by clicking on their name and then the “delete” link, and then come back and look at /directors/eldest, the page would change. So this is a live page, not just static HTML. Also if I have /movies, and similarly /actors, what’s important on a given movie page, I have the name of the director. That’s not just a string in the movie table. If I were to edit that director’s name, that would update on the movie page. So that is a foreign key being stored and we are connecting up these entities using their keys and then doing lookups to populate the pages. Finally, if I go to the details page of a given director, at the bottom there is a “Filmography” with all the films that that person has directed. This is also being drawn dynamically. It doesn’t look like much, but our target has all of the elements of IMDB. It isn’t styled well, but we could throw some bootstrap in and make it look nice. Right now there are one-to-many and many-to-many connections, and if we throw some cookies in here for authentification sign-in and sign-out, then we would have a full application. Moving away from the target, let’s get going now in our Rails app on GitPod. We have a lot of work to do in our application. 21.1.1 Text Companion: Recordkeeping Review, Exploring the Target "],["video-segment-exploring-railsdb.html", "21.2 Video Segment: Exploring /rails/db", " 21.2 Video Segment: Exploring /rails/db -Notes: time stamp 00:04:30 to 00:08:21 clicking around in /rails/db looking at tables development database SQLite How do we create a database table? How do we put data into the table? How do we get it back out? How do we get that data into controller action? How do we get it into a view template? Here’s a couple things that are going to make our job easier, the README and a chapter active-record.md. BENP: these two items need to be zipped in to this doc There’s also a couple of tools included in this (and every other) GitPod Rails project: http://[YOUR APP DOMAIN]/rails/info: shows all visitable routes in the applications http://[YOUR APP DOMAIN]/rails/db: shows a visual interface for the database These are kind of like /git, which we’ve already used. They are URL paths that are only available in development mode for our apps, but once the app is deployed to users in production mode, they won’t be visible. If we open our app browser, we can see that we do have a homepage / with the links for directors, movies, etc., but if we try any of the links, then we get a “no route matches” error. Before we do anything, navigate to /rails/db in the browser. You will see a really cool gem. This is not included in Rails by default, it’s rather a third party gem from the community. It’s a visual interface to your database: Rails includes a database out-of-the-box. This is unlike other frameworks, where you need to pick one, connect to it, etc. If you’re lucky you can easily connect to it, but you still have to set it up. Rails includes a development database called SQLite (often pronounced as Sequel Light). /rails/db gives you a visual way of looking at your database. You can see on the left the four tables that I’ve already created for this project: actors, characters, directors, and movies BENP: here and elsewhere below I put table names in code font, and added the columns we are familiar with. If you click on actors, you will be brought to the URL /rails/db/tables/actors/data, and you will see a blank table with columns Name, Dob, Bio, Image, Created at, and Updated at. These were already put together for you. In the next project you will create your own tables. Creating your own tables is also covered in the active-record.md chapter. BENP: probably zip this part of the chapter into the next project when it is actually relevant. At 00:07:51 in this video, there is a teaser of the commands, but this should be left out at this point. 21.2.1 Text Companion: Exploring /rails/db "],["video-segment-sql-and-activerecord-intro.html", "21.3 Video Segment: SQL and ActiveRecord Intro", " 21.3 Video Segment: SQL and ActiveRecord Intro -Notes: time stamp 00:08:21 to 00:12:03 adding a record with SQL command in directors table at /rails/db/sql in the SQL Editor Ruby to performant SQL with ActiveRecord object relational mapper database transactions Another cool thing about /rails/db, is that, if you happen to know Structured Query Language (SQL), then you can click “SQL Editor”, which will bring you to /rails/db/sql, where you can actually execute SQL commands. SQL (often pronounced as Sequel BENP: is that right?), is the actual language that relational databases use. For example, an BENP: an or a, depends on pronounciation SQL statement for adding a director to the directors table looks like: INSERT INTO &quot;directors&quot; (&quot;name&quot;, &quot;dob&quot;, &quot;bio&quot;, &quot;image&quot;, &quot;created_at&quot;, &quot;updated_at&quot;) VALUES (&quot;Greta Gerwig&quot;, &quot;1983-08-04&quot;, &quot;Greta Celeste Gerwig /ˈɡɜːrwɪɡ/; born August 4, 1983) is an American actress and filmmaker. She first garnered attention after working on and appearing in several mumblecore films. Between 2006 and 2009, she appeared in a number of films by Joe Swanberg, some of which she co-wrote or co-directed, including Hannah Takes the Stairs 2007) and Nights and Weekends 2008).&quot;, &quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Greta_Gerwig_Berlinale_2018.jpg/330px-Greta_Gerwig_Berlinale_2018.jpg&quot;, &quot;2020-05-19 17:47:04.103354&quot;, &quot;2020-05-19 17:47:04.103354&quot;) SQL is a create language, though it is hard to just type out by hand. But it is very powerful. For application development, you don’t really need to do it by hand anymore. I haven’t actually written raw SQL for quite some time now. The Ruby library we use called ActiveRecord basically translates Ruby into such good SQL that it’s probably better than what you would write by hand. If you are doing very advanced data analysis and generating reports, then you probably want to learn SQL. If we copy, past, and “execute” (click the button) those two lines of SQL code in our “SQL Editor” on /rails/db/sql, then navigate to our directors table by clicking the link on the left side of the browser, we will see a new row (a new record) has been added to our previously empty table. So the SQL statement issued a transaction with the database! Now this data is saved forever in my actual database on my server, which is in some sense a much more secure and safe storage space than storing cookies on my users’ browser. You only get a tiny amount of storage space for cookies and the users can clear this whenever they want. Cookies are useful for uniquely identifying users (and is the only way to do that), so they are important for certain things. But for actually storing information for the long run, you need to store it yourself in a database (storage space) that you control. BENP: this cookies aside can be dropped I think Fundamentally all we do to store data is issue SQL statements to the database. Now, we don’t have time to learn SQL, and we really wouldn’t want to anyway. We’re just going to use the amazing Ruby library included with Rails called ActiveRecord. This allows us to just think in terms of Ruby, and classes, and instances, and just do the Ruby that we are used to (we don’t need to run the below anywhere, this was already done in our SQL prompt above): d = Director.new d.name = &quot;Greta Gerwig&quot; d.dob = &quot;August 4, 1983&quot; d.bio = &quot;Greta Celeste Gerwig /ˈɡɜːrwɪɡ/; born August 4, 1983) is an American actress and filmmaker. She first garnered attention after working on and appearing in several mumblecore films. Between 2006 and 2009, she appeared in a number of films by Joe Swanberg, some of which she co-wrote or co-directed, including Hannah Takes the Stairs 2007) and Nights and Weekends 2008).&quot; d.image = &quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Greta_Gerwig_Berlinale_2018.jpg/330px-Greta_Gerwig_Berlinale_2018.jpg&quot; d.save Here, we use .new to create a new class variable instance (a new row in our directors table), and then we use the attribute accessors .name, .dob, .bio, and .image to assign values to that instance. Finally, we call a method .save to put together and issue the SQL statement that will actually add the row (record) to our database table. So ActiveRecord, called an object relational mapper, is a perfect, elegant mapping between the Ruby that we are comfortable with and performant SQL. 21.3.1 Text Companion: SQL and ActiveRecord Intro "],["video-segment-creating-appmodels-classes.html", "21.4 Video Segment: Creating app/models/ Classes", " 21.4 Video Segment: Creating app/models/ Classes -Notes: time stamp 00:12:03 to 00:14:35 just showing off app/models/ files for the four tables that we would like to have not actually creating these yet review our-own-classes.md inheritance from ApplicationRecord Okay, so let’s do this. First we’ll go back to our Rails application and create Ruby classes for the four tables in our database. We need to create four files, each containing a new class in the GitPod folder app/models/: # app/models/actor.rb class Actor &lt; ApplicationRecord end # app/models/character.rb class Character &lt; ApplicationRecord end # app/models/director.rb class Director &lt; ApplicationRecord end # app/models/movie.rb class Movie &lt; ApplicationRecord end Each filename is the table (singular), and it contains the same (but capitalized) classname. For instance, the table actors has a file app/models/actor.rb, containing a class Actor. It’s been a long-time, and if you’re rusty that’s understandable. Now might be a good time to review the idea of defining classes here. BENP: could include a few code blocks from this doc here We haven’t used the app/models/ folder yet, but that’s where all of our database-related Ruby code goes. In some sense, it’s the most important folder to us, as that’s where all of our business logic goes BENP: what is business logic?. Importantly, in the above files, we inherit &lt; from a base class called ApplicationRecord, and that is where we get all of our amazing power. That is a base class provided by Rails, and our classes will inherit methods that translate code to SQL and have insane amounts of power that we will have a lot of time to learn about. 21.4.1 Text Companion: Creating app/models/ Classes "],["video-segment-rcav-directors-and-director-class.html", "21.5 Video Segment: RCAV /directors and Director Class", " 21.5 Video Segment: RCAV /directors and Director Class -Notes: time stamp 00:14:35 to 00:28:12 wire up /directors with RCAV database naming conventions: get(\"/directors\", { :controller =&gt; \"directors\", :action =&gt; \"index\" }), app/models/director.rb, Director class, directors table inheritence in model: Director &lt; ApplicationRecord &lt; ActiveRecord::Base .each to list database info from the one record we added manually via SQL on inherited .all method to Director create app/models/: movies.rb, actors.rb, and characters.rb Before we proceed, as you know there’s no point in writing code or doing anything unless you have a way of seeing what is happening as you go. There’s a bunch of ways we could do this. Let’s pick a page to work on. How about the first page linked in the target, the list of all directors: /directors. So we navigate our app browser to that URL and begin debugging our RCAV. I am also going to keep open the tab /rails/db because it’s a useful visual reference. As usual the first error message is “no route matches”, so connect the dots and make it say hello: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/directors&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;index&quot; }) end {: mark_lines=“6”} Now that we’re in the world of databases, we are going to stick to some common conventions for naming things. Very quickly you will see that we want one controller per database table (\"directors\"). And then the action where we list the whole database is typically called \"index\". You will almost always have an action that just lists all the records in the table, or at least many records, and that is usually called \"index\". Now to the controller (create the file and fill it in): # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end end And we create the view template: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;hi&lt;/h1&gt; If that all works when we refresh our app browser, then we can begin to add some pseudo-code from the target (“View Source” on the page of interest) to our view template: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;%= Director.all %&gt; {: mark_lines=“3-5”} We just want to embed some Ruby code, where we imagine that we have a way to list our entire directors table using a class called Director with a method called .all. That would be cool if we could do something like that, and get all of our directors in an array to put into a table on our HTML page. If we refresh /directors in our app browser, then we get the error “uninitialized constant … Director”, because we haven’t defined our class yet. To define the Director class, if you haven’t already, then create the file director.rb in app/models/ and fill it in: # app/models/director.rb class Director end Now if we refresh /directors, the error message changes to: “undefined method `all’ for Director:Class”. So we do have a Director class (Rails knows to look in app/models/ for it), but no method .all… Well, we can inherit this method! # app/models/director.rb class Director &lt; ApplicationRecord end {: mark_lines=“3”} We don’t need to write the method in here (like def Director.all and all the SQL stuff that would come after that), because we are just going to use the .all method inherited from ApplicationRecord. We can actually look into app/models/ and we would see the file application_record.rb, which looks like: # app/models/application_record.rb class ApplicationRecord &lt; ActiveRecord::Base self.abstract_class = true end We see that this class actually itself inherits from the aforementioned ActiveRecord::Base from inside the Rails gem. Now try to refresh /directors. It works! We should see (assuming we just have the one Greta Gerwig entry that we issued from the SQL editor on /rails/db) something like: “Director::ActiveRecord_Relation (array with 1 Director instance inside)” Think about this! I didn’t need to do anything. I just inherited the .all method. This was able to go to the database, find (out of four tables) the table I wanted to connect to based on the name of the class, and then it issued the SQL to get the records, and then it returned the records to us as this class ActiveRecord_Relation. ActiveRecord_Relation is an important class to memorize the name of. It is not an array, but it is like an array. It has multiple things inside. ActiveRecord_Relation is a term to memorize: it means, “an array full of rows from the database”. We can go to /rails/db and click the link to our directors table, and at the top of the page use the useful “+ ADD” button on the top of the page to manually enter another director record into the database (you can just put your name and some random information for now), and if we refresh the /directors page again, we would see: “Director::ActiveRecord_Relation (array with 2 Director instances inside)” The page is dynamically updating with the .all command reconnecting to the database table everytime I load the page! ActiveRecord_Relation is a funny looking name, but it’s just an array. Which means we can call all the array methods, like: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;%= Director.all.count %&gt; {: mark_lines=“5”} .count to print the number of records on our page. Or, what we want, a .each loop to print our records into a table: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;% Director.all.each do |a_director| %&gt; &lt;li&gt; &lt;%= a_director %&gt; &lt;/li&gt; &lt;% end %&gt; {: mark_lines=“5-9”} If we refresh our URL now, we would see that each list item is an instance of the Director class that we defined in app/models/director.rb. And each of these instances have attribute accessors associated with the columns of the table. To start, if we modify the view template to: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;% Director.all.each do |a_director| %&gt; &lt;li&gt; &lt;%= a_director.name %&gt;, &lt;%= a_director.dob %&gt;, &lt;%= a_director.bio %&gt;, &lt;%= a_director.id %&gt;, &lt;/li&gt; &lt;% end %&gt; {: mark_lines=“7-10”} Then the name, DOB, bio, and table ID of each director will be printed in a list on our refreshed /directors page. Remember, we still haven’t done anything special in our app/models/director.rb file. But we get our attribute accessors for free from Rails using our inherited functionality. If we tried to change one of our embedded Ruby tags in the view template to &lt;%= a_director.title %&gt;, then we would get the page error: “undefined method ‘title’ for #Director”. That’s because title is an attribute associated with the movies table, and we are pulling records from directors with our Director class. All for free, just by defining our classes. If you haven’t done so, let’s define the other three classes now by creating and filling in those files in app/models/: movies.rb, actors.rb, and characters.rb. 21.5.1 Text Companion: RCAV /directors and Director Class "],["video-segment-rails-console.html", "21.6 Video Segment: Rails Console", " 21.6 Video Segment: Rails Console -Notes: time stamp 00:28:12 to 00:32:16 explore Director in rails console state of terminal (pry(main)&gt; vs $) rails console quirks: pagination, quiting view, exiting Alright, now that we have all four classes in our app/models/ folder we can continue. One thing we may have noted is that it’s a bit cumbersome to play with our models in a view template, where we need to keep going to the app/views/ folder, modifying the template’s embedded Ruby tags, and then refreshing our browser URL to see the results. Let’s look at a better place to do this, the Rails console. We’ve already seen this a bit. Go to GitPod, make sure your terminal window is open (Cmd + J), and open a new terminal (keep the bin/server terminal running so the browser tab doesn’t crash). You can can open a new terminal by going to the top menu “Terminal” and selecting “New Terminal”. Now at this fresh terminal you can enter rails console (or just rails c for short will do the same thing): gitpod /workspace/msm-queries $ rails console BENP: not sure the code block name for terminal, leaving it as ruby blank And what should come up is something like: Running via Spring preloader in process 8739 Loading development environment (Rails 6.0.3.2) [1] pry(main)&gt; This is just like the REPLs that we have already seen and used. We can enter whatever Ruby code interactively one line at a time and see printed out results! Now, at the terminal running rails console, try to enter: pry(main)&gt; Director.all This should give you something like: (0.2ms) SELECT COUNT(*) FROM &quot;directors&quot; =&gt; Director::ActiveRecord_Relation (array with 2 Director instances inside) Just like what we saw when experimenting with our view template and the embedded Ruby tag &lt;%= Director.all %&gt;. Keep in mind what state your terminal is in. If you see something like pry(main)&gt; at the terminal prompt, then you know you are not in a regular $-sign terminal prompt and if you try to run rails grade, you will get an “undefined local varialbe or method grade” error. To exit the rails console and get back to a regular terminal, you need to run pry(main)&gt; exit. BENP: Rails Console Quirks, 00:30:05 to 00:32:16 A quick aside with some important notes about rails console: Try to enter: pry(main)&gt; Director.all.at(0) Since Director.all is a type of array, we can use the array method .at(0) to get the first time. Now, what you should see, assuming that first entry is Greta Gerwig and your terminal window is too small to fit the entire bio, is something like: Director Load (0.2ms) SELECT &quot;directors&quot;.* FROM &quot;directors&quot; WHERE &quot;directors&quot;.&quot;name&quot; = ? ORDER BY &quot;directors&quot;.&quot;id&quot; ASC LIMIT ? [[&quot;name&quot;, &quot;Greta Gerwig&quot;], [&quot;LIMIT&quot;, 1]] =&gt; #&lt;Director:0x0000558c86d7d8a0 id: 1, name: &quot;Greta Gerwig&quot;, dob: Thu, 04 Aug 1983, bio: &quot;Greta Celeste Gerwig /ˈɡɜːrwɪɡ/; born August 4, 1983) is an American actress and filmmaker. She first garnered attention after working on a : Sometimes when the output of a Ruby expression is very long, rails console is going to paginate it for you. You will have a : prompt when this is true, and you can hit return to scroll through line by line, or space to scroll through page by page. When you reach the end of the output, you’ll see (END). To get back to the regular prompt so that you can enter your next command, just hit q at any time. And one last thing: if you are in rails console and then make a change to a model (for example, you define a new method or fix a syntax error), then, annoyingly, you have to exit and then start a new rails console to pick up the new logic. The console is not live-loading with changes we make to our app. Or, you can use the reload! method. BENP: \"reload doesn’t always work in my experience, maybe delete this last sentence 21.6.1 Text Companion: Rails Console "],["video-segment-reading-and-creating-records.html", "21.7 Video Segment: Reading and Creating Records", " 21.7 Video Segment: Reading and Creating Records -Notes: time stamp 00:32:16 to 00:36:35 explore Director in rails console R and C in CRUD reading records with Director.all.at(0) creating records with .new and .save Let’s now explore our tables from the rails console prompt! Our main goal, is that we need to learn the Ruby required to Create, Read, Update, and Delete records. Once we know all the Ruby to CRUD, we can connect that with all the other Ruby we learned, and we’ll be able to create an app. Actually, we already started on the R, to read from our table in the view template. For instance if we, at the rails console, enter: pry(main)&gt; a = Director.all (0.2ms) SELECT COUNT(*) FROM &quot;directors&quot; =&gt; Director::ActiveRecord_Relation (array with 2 Director instances inside) pry(main)&gt; a.at(0) Director Load (0.2ms) SELECT &quot;directors&quot;.* FROM &quot;directors&quot; WHERE &quot;directors&quot;.&quot;name&quot; = ? ORDER BY &quot;directors&quot;.&quot;id&quot; ASC LIMIT ? [[&quot;name&quot;, &quot;Greta Gerwig&quot;], [&quot;LIMIT&quot;, 1]] =&gt; #&lt;Director:0x0000558c86d7d8a0 id: 1, name: &quot;Greta Gerwig&quot;, dob: Thu, 04 Aug 1983, bio: &quot;Greta Celeste Gerwig /ˈɡɜːrwɪɡ/; born August 4, 1983) is an American actress and filmmaker. She first garnered attention after working on a : Press q to get back to the prompt if our output is paginated with the : symbol. But we wanted that second input (a.at(0)) in its own variable. Well we can just press the Up Arrow on our keyboard at the prompt and that will give me back the last run line, then I can jump to the beginning of the line with Cntrl + a, and put it in its own variable: pry(main)&gt; x = a.at(0) pry(main)&gt; x.name =&gt; &quot;Greta Gerwig&quot; So we .all to get the records, .at() to select one of the records, and then .name to get one of the column values, and you have Read a value from the database! There’s a lot more depth for reading that we can go into, but there’s the most basic. BENP: Rails Console Creating Records, 00:34:35 to 00:36:35 Now, let’s move onto Creating records. Let’s create a new actor in our actors database table. This is just like how we created a new Person in our previous exercises. There’s even a reference for how to do it in this case here. Again, in the rails console, enter line-by-line: pry(main)&gt; a = Actor.new ... pry(main)&gt; a.name = &quot;Morgan Freeman&quot; ... pry(main)&gt; a.dob = &quot;June 1, 1937&quot; ... Now, we could fill out every attribute of a, with the exception of created_at, updated_at, and id, as these are automatically filled in by Rails and we don’t want to edit them. But if we just have a look now at the variable: pry(main)&gt; a =&gt; #&lt;Actor:0x0000558c85f492e8 id: nil, name: &quot;Morgan Freeman&quot;, dob: Tue, 01 Jun 1937, bio: nil, image: nil, created_at: nil, updated_at: nil&gt; we see a is just an Actor instance being populated by information we enter. But if we go to our tab with the /rails/db page running and go to our table actors, we don’t see this data there. The reason is, it’s not sure if we’re done populating the columns. So when we are done, we need to call the very important method .save: pry(main)&gt; a.save (0.1ms) begin transaction Actor Create (0.8ms) INSERT INTO &quot;actors&quot; (&quot;name&quot;, &quot;dob&quot;, &quot;created_at&quot;, &quot;updated_at&quot;) VALUES (?, ?, ?, ?) [[&quot;name&quot;, &quot;Morgan Freeman&quot;], [&quot;dob&quot;, &quot;1937-06-01&quot;], [&quot;created_at&quot;, &quot;2022-12-20 21:24:14.030804&quot;], [&quot;updated_at&quot;, &quot;2022-12-20 21:24:14.030804&quot;]] (1.9ms) commit transaction =&gt; true What happened there? It begins a transaction, issues the robust SQL, and enters it in the database! Have a look again at the actors table in /rails/db to see for yourself. And we have now Created records. 21.7.1 Text Companion: Reading and Creating Records "],["video-segment-sample_data.html", "21.8 Video Segment: sample_data", " 21.8 Video Segment: sample_data -Notes: time stamp 00:36:35 to 00:42:10 test data without .save rails sample_data rake task in tasks/dev.rake view /rails/db So far we have just manually entering data. For instance if we try: pry(main)&gt; Movie.count (We can leave off .all on the class itself! It’s a class-level method because it is so commonly done, and you will often see it omitted.) And that will return: =&gt; 0. So, the only thing really missing right now is our big database to play with. It would be a huge pain to manually enter a ton of movies, actors, characters, and directors (not to mention keeping track of the foreign keys!). Try a few yourself and see (don’t forget to .save to update the database with each new entry). But wait, stop! That would take forever. In the real world, someone would initially have to add all of our data, whether it’s us, or our employees, or our users (through forms in their browser, obviously, not through rails console). Luckily for us we don’t need to do any of this manual entering for this project! We have included a handy program that you can run. If you open a fresh terminal on GitPod, get back to your regular $-sign command prompt, and run the command rails sample_data: gitpod /workspace/msm-queries $ rails sample_data There are 34 directors in the database There are 52 movies in the database There are 652 actors in the database There are 724 characters in the database It will run a rake task BENP: might need to define rake task here, that I wrote called sample_data, which you can find in the tasks/dev.rake file. This Ruby script will do the process of adding data to our database and making sure the foreign keys are all correct. You can see the number of records entered in each table. This program will also first delete any previous records we entered, so we can start with a fresh dataset from scratch. If you refresh /rails/db, then you will see all of these data in our tables. Also, if you go back to the /directors page that we were working on, you will see many entries now being listed. Progress! 21.8.1 Text Companion: sample_data "],["video-segment-finishing-directors-index.html", "21.9 Video Segment: Finishing /directors index", " 21.9 Video Segment: Finishing /directors index -Notes: time stamp 00:42:10 to 00:51:10 moving Director.all from view template to controller .each to loop over @list_of_directors object, ActiveRecord::Relation formatting results into a table images with robohash (still necessary? works now…) linking to details page with flexible route and primary key, href=\"/director/&lt;%= a_director.id %&gt;\" Now that I have my data, we could return to a rails console and practice some more interesting queries: pry(main)&gt; Movie.count (0.1ms) SELECT COUNT(*) FROM &quot;movies&quot; =&gt; 52 pry(main)&gt; Director.count (0.1ms) SELECT COUNT(*) FROM &quot;directors&quot; =&gt; 34 We will need to read data more precisely than just listing it all out for our task. Before we do that, though, if we look at our target, and go to the list of all directors: /directors, then we will see that we have the necessary data to finish that page in our app. If you go back to the /directors page in our app, it actually looks like the only thing different compared to the target is that we have the information listed as bullets, and the target has it in a table with links for “Show details”. We will just need to work on the formatting. So let’s return to our view template and fix things: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;% Director.all.each do |a_director| %&gt; &lt;li&gt; &lt;%= a_director.name %&gt;, &lt;%= a_director.dob %&gt;, &lt;%= a_director.bio %&gt;, &lt;%= a_director.id %&gt;, &lt;/li&gt; &lt;% end %&gt; We are just looping over a Director.all right in the view template. My preference here would be that we place this call in the controller and just have an instance variable with this array we can use in the view template: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end end {: mark_lines=“5”} &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;% @list_of_directors.each do |a_director| %&gt; &lt;li&gt; &lt;%= a_director.name %&gt;, &lt;%= a_director.dob %&gt;, &lt;%= a_director.bio %&gt;, &lt;%= a_director.id %&gt;, &lt;/li&gt; &lt;% end %&gt; {: mark_lines=“5”} And rather than a list item, let’s format things into a table: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @list_of_directors.each do |a_director| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_director.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.dob %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.bio %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.id %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“5 7-12 14”} All we did here was put each of our previous records into a separate row (&lt;tr&gt;&lt;/tr&gt;) and each attribute into a separate column in that row (&lt;td&gt;&lt;/td&gt;), all within a loop in our &lt;table&gt; element. If we refresh our /directors page and compare it with the target, we’ll see that we’re getting somewhere. But we do need to add table headings, move things around, add the images, and add a link to the director’s page with the bio rather than putting it all in that table. Let’s re-arrange things to match the target and add the image first: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @list_of_directors.each do |a_director| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_director.id %&gt;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&lt;%= a_director.image %&gt;&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;%= a_director.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.dob %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“8-13”} Remember, we can embed Ruby code in the HTML tag attributes, so we’ve done that with the image URLs (contained in a_director.image) from our database records in the src=\"\" attribute to &lt;img&gt;. Using .each for looping over an ActiveRecord_Relation (an array of database rows) like @list_of_directors, and pulling out attributes to put them into embedded Ruby HTML documents is a huge part of our job! As a brief aside, if those images aren’t showing up on the page (for instance because the scraped image URLs are being blocked, which sometimes occurs), there’s actually another way that we can get some dummy images to fill in our table: using https://robohash.org. RoboHash lets developers put sample images into mockups while building stuff. Unique images are generated from any text (including our entire URL strings). All we need to do is replace src=\"&lt;%= a_director.image %&gt;\" with src=\"https://robohash.org/&lt;%= a_director.image %&gt;\". BENP: I note that the director image URLs do seem to work now so maybe this aside can be eliminated Okay, now let’s see how we can get the bio out of our table (it’s not in the target) and into the director’s detail page, which should be linked with “Show details”. In the target, if I click a link it will take me to a URL that looks like /director/1. The second path segment is the id column value of that director, the primary key! &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @list_of_directors.each do |a_director| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_director.id %&gt;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&lt;%= a_director.image %&gt;&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;%= a_director.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.dob %&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/director/1&quot;&gt; Show details &lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“14-18”} If on our /director page in our app, we now click some of the “Show details” links, they all take us to /director/1, and they all have a “no route matches” error. How do we fill in the href=\"/director/1\" attribute to get the input link to take us to the correct page? And how do we get that page to show us the director information from the database, including the long bio? Well, for starters, we have a_director.id, which will give us the primary key for every director and we can fill in the link path with that: &lt;!-- app/views/director_templates/index.html.erb --&gt; &lt;h1&gt;List of all directors&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @list_of_directors.each do |a_director| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_director.id %&gt;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;&lt;%= a_director.image %&gt;&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;%= a_director.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_director.dob %&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/director/&lt;%= a_director.id %&gt;&quot;&gt; Show details &lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“15”} Now when we click the link “Show details”, we are being brought to the correct path for a given director, but we still haven’t defined the routes or made the pages, so we’re not done yet. For this, you will need to use flexible routes. BENP: link to dynamic routes (or is it called flexible routes?) content 21.9.1 Text Companion: Finishing /directors Index "],["video-segment-database-query-with-.html", "21.10 Video Segment: Database Query with .where", " 21.10 Video Segment: Database Query with .where -Notes: time stamp 00:51:10 to 01:09:31 RCAV /directors/eldest query DB in rails console, building up to Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first put query into wisest action, and put @oldest director into view template app/views/director_templates/eldest.html.erb http://strftime.net/ to get .dob formatted Let’s work on something else first. In our target we have those pages for youngest and eldest . We will start with the /directors/eldest URL path in our app. As always, the first job is to make it say hello by following our RCAV: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/directors&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/directors/eldest&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;wisest&quot; }) end {: mark_lines=“8”} And then: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end def wisest render({ :template =&gt; &quot;director_templates/eldest.html.erb&quot; }) end end {: mark_lines=“10-13”} And (going right away to viewing the target source for the copy in our view template): &lt;!-- app/views/director_templates/eldest.html.erb --&gt; &lt;h1&gt;Eldest director&lt;/h1&gt; &lt;p&gt; The eldest director in our dataset right now is Michael Curtiz, born on December 24, 1886. &lt;/p&gt; Now that we have something showing up on our page (refresh /directors/eldest to be sure), we need to get it to dynamically update by looking up the oldest director and showing their name (linked to their page) and date of birth. To figure out how to do this, we will play around in the rails console. So open a new terminal (or use one you have open that is not running bin/server), and start the console. If we do: pry(main)&gt; Director.count (0.1ms) SELECT COUNT(*) FROM &quot;directors&quot; =&gt; 34 then we see we have 34 directors. And our columns can be shown with: pry(main)&gt; Director =&gt; Director(id: integer, name: string, dob: date, bio: text, image: string, created_at: datetime, updated_at: datetime) Now, how are we going to find the oldest director? What methods do we have at our disposal? We have many wonderful methods avaiable from ActiveRecord, so let’s familiarize ourselves with some of them. BENP: some of these notes come directly from zipping in active-record.md chapter content, could just be linked here. We will use the “Time to CRUD” section of this chapter as reference. We see much of the things we have already discussed in this section: how to use the console, how to create records and save them, and how to read. Please read the section, so you can see some of the methods you have available that we haven’t covered. For now, let’s have a look at one in particular, .order. This sorts an ActiveRecord_Relation based on some specified column and a specified direction: :asc for ascending, or :desc for descending. In addition to this handy method, we have the all-important .where. .where is, if I had to pick one, the most important of the read methods. This is how we filter the table based on some criteria. We pick a column and a criteria and we can filter the records down. And you can do this as many times as you want until you are left with just the records you need (in our case, one record). Let’s put these read methods to the test in querying our database for the oldest director! Can you take a moment in your console and try to do this yourself with the reference material linked? In particular this is important to keep in mind. It’s a little tricky, but I’ll wait… Okay let’s do it together. If I want the oldest director, then I will use the dob column from my table, that seems appropriate. First, I’ll order by that column (note, I don’t need to write .all, because it is standard to query all records in a database, so this is implicit): pry(main)&gt; Director.order({ :dob =&gt; :asc }).first We use :asc as the argument because in programming dates grow over time (they are stored as seconds BENP: are they stored as seconds?), so they get bigger and bigger, so the smallest dob column value is the oldest director. Thus, the first row in the ActiveRecord_Relation returned by this ordering should be what I want, so I call it with .first (or .at(0) is equivalent). If you leave off .first, then you will get the entire array of all rows, now ordered. But wait, the above console query returns: =&gt; #&lt;Director:0x00005615f9231698 id: 17, name: &quot;Kátia Lund&quot;, dob: nil, bio: nil, image: &quot;http://ia.media-imdb.com/images/M/MV5BMTUyNTEzODc1NF5BMl5BanBnXkFtZTYwOTUyMjIz._V1._SY314_CR13,0,214,314_.jpg&quot;, created_at: Wed, 12 Aug 2015 17:20:05 UTC +00:00, updated_at: Wed, 12 Aug 2015 17:20:05 UTC +00:00 That’s not right! Kátia Lund is definitely not the eldest director, and look, the dob is nil, or empty. The value nil actually counts as smaller than 0 in our ordering. We’re going to need to chain another query method if we want to avoid any nil values. How about .where? Or better yet, .where.not. Try to solve this yourself! Okay, if you didn’t already, try to enter something like: pry(main)&gt; Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first And that should return: =&gt; #&lt;Director:0x00005615f918d020 id: 19, name: &quot;Michael Curtiz&quot;, dob: Fri, 24 Dec 1886, bio: &quot;Curtiz began acting in and then directing films in his native Hungary in 1912. After WWI, he continued his filmmaking career in Austria and Germany and into the early 1920s when he directed films in other countries in Europe. M : Great! As an aside. Sometimes when you are typing these long query strings into the console you forget a parenthesis and you get stuck: [7] pry(main)&gt; Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }.first [7] pry(main)* Where you see the * symbol at the prompt on the next line, the console is still waiting for you to finish entering. The console is expecting more code! Nothing is working here. Well just remember you can always Ctrl + c to get out of that state and go back to fix the expression. Anyway, now that I’ve figured out the code in the rails console, let’s add it to our controller as an instance variable: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end def wisest @oldest = Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first render({ :template =&gt; &quot;director_templates/eldest.html.erb&quot; }) end end {: mark_lines=“10-13”} And let’s put that instance variable into our view template, keeping in mind that this variable is a record from our database table with attributes (column values) that we can access: &lt;!-- app/views/director_templates/eldest.html.erb --&gt; &lt;h1&gt;Eldest director&lt;/h1&gt; &lt;p&gt; The eldest director in our dataset right now is &lt;%= @oldest.name %&gt;, born on &lt;%= @oldest.dob %&gt;. &lt;/p&gt; {: mark_lines=“6”} Now refresh /directors/eldest. Looking good! We can pretty easily get the director name to link to the director’s page like we did with the “Show details” links on /directors (we haven’t RCAV’d these links yet, but we will soon). Now, how can we get the formatting for the date of birth to match the target? Well for that we can use http://strftime.net/. You never need to memorize these odd string formating characters for dates. Just use a resource for strftime, and over time you may beging to grow familiar with them. With the help of that tool we can reformat the date like so: &lt;!-- app/views/director_templates/eldest.html.erb --&gt; &lt;h1&gt;Eldest director&lt;/h1&gt; &lt;p&gt; The eldest director in our dataset right now is &lt;a href=&quot;/directors/&lt;%= @director.id %&gt;&quot;&gt;&lt;%= @oldest.name %&gt;&lt;/a&gt;, born on &lt;%= @oldest.dob.strftime(&quot;%B %e, %Y&quot;) %&gt;. &lt;/p&gt; {: mark_lines=“6”} And our page is up and running like the target. By the way, have you been using rails grade to check your progress and /git committing when you get things working?!?! Do it now if you haven’t. 21.10.1 Text Companion: Database Query with .where "],["video-segment-flexible-routes-for-director-details.html", "21.11 Video Segment: Flexible Routes for Director Details", " 21.11 Video Segment: Flexible Routes for Director Details -Notes: time stamp 01:09:31 to 01:23:36 should title be “flexible” or “dynamic”? return to unfinished “Show details” links on index page importance of placement of static /director/eldest vs. flexible /director/:an_id in config/routes.rb fetch director ID from params and query DB first in rails console aside: using tp Movie.where({ :year =&gt; 1994 }), \"title\", \"year\", \"id\" in rails console to explore table place finished query in the action director_details and the director info in the view template time_ago_in_words() Now we need to make some flexible routes like /director/1, that accept the id number of a director in the second segment of the path. Let’s begin by visiting such a segment. First, notice that if we enter the URL path /director/eldest, this second segment eldest is not bringing us to a director page. That’s because the config/routes.rb file will search for and match routes starting top to bottom, so we just need to be careful where we put our new routes (they will need to be below the route we don’t want to be flexible): # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/directors&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/directors/eldest&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;wisest&quot; }) get(&quot;/directors/:an_id&quot;, { :controller =&gt; &quot;directors&quot;, :action =&gt; &quot;director_details&quot; }) end {: mark_lines=“10”} If we put the new route above the /directors/eldest route, then we would lose our ability to reach that route! So we put it below. Long story short, if you define a flexible route that matches a static route that you want to have, make sure that your static routes come above your flexible routes. Now let’s make our director’s pages working. We know already about flexible routes. BENP: link to content / assignment here? We can get :an_id above out from our params variable. Visit a “Show details” link on the /directors page, and note in the GitPod terminal running bin/server: ... Parameters: {&quot;an_id&quot;=&gt;&quot;1&quot;} ... Okay, let’s get this data into our controller: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end def wisest @oldest = Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first render({ :template =&gt; &quot;director_templates/eldest.html.erb&quot; }) end def director_details # params looks like {&quot;an_id&quot;=&gt;&quot;1&quot;} the_id = params.fetch(&quot;an_id&quot;) render({ :template =&gt; &quot;director_templates/show.html.erb&quot; }) end end {: mark_lines=“16-22”} Now how do I get the actual director record that matches the_id? With a database query! Try it in our console: pry(main)&gt; Director.where({ :id =&gt; &quot;1&quot; }).first Director Load (0.3ms) SELECT &quot;directors&quot;.* FROM &quot;directors&quot; WHERE &quot;directors&quot;.&quot;id&quot; = ? ORDER BY &quot;directors&quot;.&quot;id&quot; ASC LIMIT ? [[&quot;id&quot;, 1], [&quot;LIMIT&quot;, 1]] =&gt; #&lt;Director:0x00005615f90b0710 id: 1, name: &quot;Frank Darabont&quot;, dob: Wed, 28 Jan 1959, bio: &quot;Three-time Oscar nominee Frank Darabont was born in a refugee camp in 1959 in Montbeliard, France, the son of Hungarian parents who had fled Budapest during the failed 1956 Hungarian revolution. Brought to America as an infant : Don’t forget the .first or .at(0), or you will just get back an array rather than a single record. As another aside, you can view records in your console with some table printing. For instance, at the console we could view the movies. Like what if you wanted to show the movies that were made in 1994? pry(main)&gt; Movie.where({ :year =&gt; 1994 }) (0.1ms) SELECT COUNT(*) FROM &quot;movies&quot; WHERE &quot;movies&quot;.&quot;year&quot; = ? [[&quot;year&quot;, 1994]] =&gt; Movie::ActiveRecord_Relation (array with 4 Movie instances inside) We see there are four movies, but how can we quick n’ dirty actually see them? We can use a nice method called “table print”, or tp: pry(main)&gt; tp Movie.where({ :year =&gt; 1994 }) Movie Load (0.2ms) SELECT &quot;movies&quot;.* FROM &quot;movies&quot; WHERE &quot;movies&quot;.&quot;year&quot; = ? [[&quot;year&quot;, 1994]] ID | TITLE | YEAR | DURATION | DESCRIPTION | IMAGE | DIRECTOR_ID | CREATED_AT | UPDATED_AT ---|--------------------------|------|----------|--------------------------------|--------------------------------|-------------|-------------------------|------------------------ 1 | The Shawshank Redemption | 1994 | 142 | Two imprisoned men bond ove... | http://ia.media-imdb.com/im... | 1 | 2015-08-12 17:20:05 | 2015-08-12 17:20:05 4 | Pulp Fiction | 1994 | 154 | The lives of two mob hit me... | http://ia.media-imdb.com/im... | 3 | 2015-08-12 17:20:05 | 2015-08-12 17:20:05 ... Now this is ugly, because it is printing every column, so we can also specify just a few columns like so, with comma separated values of strings: pry(main)&gt; tp Movie.where({ :year =&gt; 1994 }), &quot;title&quot;, &quot;year&quot;, &quot;id&quot; Movie Load (0.2ms) SELECT &quot;movies&quot;.* FROM &quot;movies&quot; WHERE &quot;movies&quot;.&quot;year&quot; = ? [[&quot;year&quot;, 1994]] TITLE | YEAR | ID -------------------------|------|--- The Shawshank Redemption | 1994 | 1 Pulp Fiction | 1994 | 4 Forrest Gump | 1994 | 18 Léon: The Professional | 1994 | 31 =&gt; 0.00055176 Okay, back to the task at hand, we can put the working database query in our controller to get the director record: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end def wisest @oldest = Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first render({ :template =&gt; &quot;director_templates/eldest.html.erb&quot; }) end def director_details # params looks like {&quot;an_id&quot;=&gt;&quot;1&quot;} the_id = params.fetch(&quot;an_id&quot;) @the_director = Director.where({ :id =&gt; the_id }).first render({ :template =&gt; &quot;director_templates/show.html.erb&quot; }) end end {: mark_lines=“20”} And we can use this director record @the_director instance variable in our view template to generate dynamic content at each flexible route (copy pasting a lot from our target to save time and populating with the instance variable). &lt;!-- app/views/director_templates/show.html.erb --&gt; &lt;h1&gt;Director #&lt;%= @the_director.id %&gt; details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Name&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.name %&gt;&lt;/dd&gt; &lt;dt&gt;Dob&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.dob %&gt;&lt;/dd&gt; &lt;dt&gt;Bio&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.bio %&gt;&lt;/dd&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;&lt;img src=&lt;%= @the_director.image %&gt;&gt;&lt;/dd&gt; &lt;dt&gt;Created at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.created_at %&gt;&lt;/dd&gt; &lt;dt&gt;Updated at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.updated_at %&gt;&lt;/dd&gt; &lt;/dl&gt; And just to note, the target has some nice formatting for the “Created at” and “Updated at” information. The way this is done is simply wrapping the instance variable attribute, which come out as Time classes, in the inherited Rails function time_ago_in_words(), like: &lt;%= time_ago_in_words(@the_director.created_at) %&gt;. The “Show details” pages on /directors now appear to be working (test is manually yourself), so we can rails grade and /git commit, then move on to the next thing. 21.11.1 Text Companion: Flexible Routes for Director Details "],["video-segment-filmography.html", "21.12 Video Segment: Filmography", " 21.12 Video Segment: Filmography -Notes: time stamp 01:23:36 to 01:35:54 foreign keys for director_id in Movie rails console to show tp Movie.where({ :director_id =&gt; 1 }), \"title\", \"year\", \"id\" add query to director_details format filmography table in view template app/views/director_templates/show.html.erb, including the query: &lt;%= Director.where({ :id =&gt; a_film.director_id }).at(0).name %&gt; We now want our director’s pages to list the filmography (the movies) that each director made. On Day One, we spent a long time thinking about how our tables relate to one another, and this largely came down to keeping track of foreign keys added to each table. If you forget what columns you have in your table, you can navigate in your browser to /rails/db, click on a given table, and then select the “Schema” tab above the table. This will give you the real column names, datatype, and other information. Let’s begin by playing around in our rails console. What if we did: pry(main)&gt; tp Movie.where({ :director_id =&gt; 1 }), &quot;title&quot;, &quot;year&quot;, &quot;id&quot; Movie Load (0.2ms) SELECT &quot;movies&quot;.* FROM &quot;movies&quot; WHERE &quot;movies&quot;.&quot;director_id&quot; = ? [[&quot;director_id&quot;, 1]] TITLE | YEAR | ID -------------------------|------|--- The Shawshank Redemption | 1994 | 1 =&gt; 0.00032467 We wanted to find all of the movies that had a given director (with id of 1). And we know our movies table keeps track of this director ID with the foreign key column director_id. So we just query our database table (the class Movie in Rails) for a given director_id, and we get back all of those records (nicely formatted above with tp and a few columns of interest). Let’s add this query to our action in the controller: # app/controllers/directors_controller.rb class DirectorsController &lt; ApplicationController def index @list_of_directors = Director.all render({ :template =&gt; &quot;director_templates/index.html.erb&quot; }) end def wisest @oldest = Director.where.not({ :dob =&gt; nil }).order({ :dob =&gt; :asc }).first render({ :template =&gt; &quot;director_templates/eldest.html.erb&quot; }) end def director_details # params looks like {&quot;an_id&quot;=&gt;&quot;1&quot;} the_id = params.fetch(&quot;an_id&quot;) @the_director = Director.where({ :id =&gt; the_id }).first @filmography = Movie.where({ :director_id =&gt; @the_director.id }) render({ :template =&gt; &quot;director_templates/show.html.erb&quot; }) end end {: mark_lines=“21”} Noting above that we need to use the current director (@the_director) ID to query our database for just that person’s filmography. Also note, @filmography is an ActiveRecord_Relation array (we didn’t call .first or .at(0) on it) containing potentially many records. So in our view template we will need to loop over it with .each and format the attributes for each record into a table. Just like we did for the index action on our @list_of_directors! So now in our view template, we can: &lt;!-- app/views/director_templates/show.html.erb --&gt; &lt;h1&gt;Director #&lt;%= @the_director.id %&gt; details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Name&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.name %&gt;&lt;/dd&gt; &lt;dt&gt;Dob&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.dob %&gt;&lt;/dd&gt; &lt;dt&gt;Bio&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.bio %&gt;&lt;/dd&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;&lt;img src=&lt;%= @the_director.image %&gt;&gt;&lt;/dd&gt; &lt;dt&gt;Created at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.created_at %&gt;&lt;/dd&gt; &lt;dt&gt;Updated at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.updated_at %&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;h2&gt;Filmography&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @filmography.each do |a_film| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_film.id %&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;&lt;%= a_film.image %&gt;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_film.title %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_film.year %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_film.director_id %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“22-32”} If we click around now on our “Show details” pages on /directors, then we should see the table of filmographies updating on each page. But there’s something pesky. Right now we are showing users a column with a_film.director_id, which is just the ID number of the director. We don’t every want to show users ID numbers, we want to show them information associated with that id. In this case, we want the name of the director, but that’s not a column we have in a_flim, which comes from our movies table. So how to get this? We could use the @the_director.name from above since we are on this page, but ignore this for a moment. If we didn’t have the name already available, we could use another database query and a mix of invisible and visible embedded Ruby tags: &lt;!-- app/views/director_templates/show.html.erb --&gt; &lt;h1&gt;Director #&lt;%= @the_director.id %&gt; details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Name&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.name %&gt;&lt;/dd&gt; &lt;dt&gt;Dob&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.dob %&gt;&lt;/dd&gt; &lt;dt&gt;Bio&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.bio %&gt;&lt;/dd&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;&lt;img src=&lt;%= @the_director.image %&gt;&gt;&lt;/dd&gt; &lt;dt&gt;Created at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.created_at %&gt;&lt;/dd&gt; &lt;dt&gt;Updated at&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_director.updated_at %&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;h2&gt;Filmography&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;% @filmography.each do |a_film| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_film.id %&gt;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;&lt;%= a_film.image %&gt;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_film.title %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_film.year %&gt;&lt;/td&gt; &lt;td&gt; &lt;% d = Director.where({ :id =&gt; a_film.director_id }).at(0) %&gt; &lt;%= d.name %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“31-34”} Okay, now that we have a filmography we’ve really circled back on all of the early stuff we talked about with one-to-many and many-to-many relationships. This is what makes our applications powerful! Now, after a rails grade and potentially a /git commit if everything is work, the rest of the project to match the target is up to you. 21.12.1 Text Companion: Filmography "],["finish-and-submit-msm-queries.html", "21.13 Finish and Submit MSM Queries", " 21.13 Finish and Submit MSM Queries 21.13.1 Additional Query Tasks for Practice Notes: from https://github.com/appdev-projects/msm-queries#tasks 21.13.1.1 Finding a movie by title How many years ago was “Casablanca” released? Use the .where method. It is everything. Remember that .where always returns a collection, not a single row. Calculate the value dynamically (using e.g. Time.now.year), so that the number is always up to date. 21.13.1.2 Other queries How many movies in our table are from before the year 2000? Displays the titles and years of the films. Who is the youngest director in our table? Display the date of birth of the director. (Remember you can call .strftime(\"\") on Time, Date, and DateTimes to format them. Tools like strftime.net and For a Good Strftime exist to help compose the formatting string argument.) How many directors in our table are less than 55 years old? Display their names and dates of birth. How many films in our table were directed by Francis Ford Coppola? Display the titles and years of the films. How many films did Morgan Freeman appear in? Display the titles and years of the films. "],["classroom-queries-debug.html", "22 Classroom Queries Debug", " 22 Classroom Queries Debug Notes: Chapters (and slides): README at https://github.com/appdev-projects/classroom-queries-debug#readme Project: https://github.com/appdev-projects/classroom-queries-debug Target: https://classroom-queries-debug.matchthetarget.com/ "],["different-ruby-styles.html", "23 Different Ruby Styles", " 23 Different Ruby Styles Notes: Could be copied in here: optional-syntaxes-in-ruby.md "],["history-of-ml.html", "24 History of ML", " 24 History of ML Notes: many links, could be compressed, see Canvas "],["refactoring-must-see-movies.html", "25 Refactoring Must See Movies", " 25 Refactoring Must See Movies Notes: Original day 6 recording video transcription is in refactoring-MSM-queries.md Project (graded): https://github.com/appdev-projects/refactoring-msm-queries-1 Target: https://msm-queries.matchthetarget.com/ Useful chapters: refactoring-msm-queries-with-methods.md, not yet copied in here "],["video-segment-exploring-the-target-what-is-refactoring.html", "25.1 Video Segment: Exploring the Target, What is Refactoring?", " 25.1 Video Segment: Exploring the Target, What is Refactoring? Notes: time stamp 00:01:45 to 00:06:57 explore target, which is a solution to MSM Queries technical debt, refactoring automated tests with rails grade Here’s the plan for today’s assignment. First, we’re going to look at a project called refactoring MSM queries. The starting point of that assignment is the ending point for MSM queries. So once you set up your workspace you’ll have a solution for the homework. So the first thing that you should do is look through the starting point for refactoring MSM queries. Compare this solution to your solution. Compare my code to your code and try to think of some questions about the choices that I made. If nothing else, compare my actor details view template and your actor details view template, because there is a lot going on there. Practice reading the code and reasoning your way through it, line by line; explain it to yourself, or to your rubber ducky. Developers read far more code than we write. Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project is here. It is the same as MSM Queries, because the functionality is unchanged, just refactored! A refactoring will not change the visual appearance, or anything related to functionality. On a team, when you go through a refactoring sprint or chunk of work, your users should not be affected. We’re just trying to improve the code base and pay off technical debt. A lot of times we know it’s not the best way it could be done, we know there’s repetitive stuff, so refactoring is when we pause, freeze the functionality and pay off the technical debt. And that’s why automated tests like rails grade are amazing. We’ve been writing all the automated tests for you and we just run them with Rails. But in a real world setting, refactoring is where automated tests really pay off. If you don’t have automated tests, you never pay off that technical debt because you’re afraid of breaking something. We’re going to make the code much more modular and re-usable, while keeping the functionality exactly the same. How? By defining methods to encapsulate our querying logic. 25.1.1 Text Companion: Exploring the Target, What is Refactoring? "],["video-segment-actor-details-show-page.html", "25.2 Video Segment: Actor Details show Page", " 25.2 Video Segment: Actor Details show Page Notes: time stamp 00:06:57 to 00:09:14 examine view template and show action in app/controllers/actors_controller.rb reiterate ActiveRecord::Relation Now that we have our bin/server running, I’m going to visit an actor details page myself in the browser of my app. If you don’t have any data in this brand new project and workspace, open up a new terminal, run rails sample_data, and get some stuff to look at. Once you have data you can click through the list of actors at /actors and find Morgan Freeman, then “Show details” to end up on that page with the URL path /actors/2 (or whatever Morgan Freeman’s id number is in that second path segment). You see I have the filmography on the page. So this is a working version MSM Queries to begin with. Let’s zoom in on the actual code by opening the actor details view template: &lt;!-- app/views/actor_templates/show.html.erb --&gt; &lt;h1&gt; Actor #&lt;%= @the_actor.id %&gt; details &lt;/h1&gt; ... &lt;dl&gt; &lt;dt&gt; Name &lt;/dt&gt; &lt;dd&gt; &lt;%= @the_actor.name %&gt; &lt;/dd&gt; &lt;dt&gt; Dob &lt;/dt&gt; &lt;dd&gt; &lt;%= @the_actor.dob %&gt; &lt;/dd&gt; ... &lt;/dl&gt; ... I have this instance variable called @the_actor, which I set up in the action that I made in the controller: # app/controllers/actors_controller.rb class ActorsController &lt; ApplicationController def index matching_actors = Actor.all @list_of_actors = matching_actors.order({ :created_at =&gt; :desc }) render({ :template =&gt; &quot;actor_templates/index.html.erb&quot; }) end def show the_id = params.fetch(&quot;path_id&quot;) matching_actors = Actor.where({ :id =&gt; the_id }) @the_actor = matching_actors.at(0) render({ :template =&gt; &quot;actor_templates/show.html.erb&quot; }) end end {: mark_lines=“11-18”} I did this standard dance, which we’re going to be doing a lot, which is get the id number out of the path. This is the dynamic segment of the path: path_id. And then look up the actors where that value appears in the id column. That .where method returns an ActiveRecord::Relation in the matching_actors variable. ActiveRecord::Relations contain some number of records, which match the search criteria that we put in. If you’re searching an id column, of course we know there’s only going to be one record and that’s unique. Or there might be zero records in case we provide an id that doesn’t exist. There’s only going to be zero or one. But we still have to get that first element out of the relation, so we use .at(0) to get the @the_actor instance variable for the view template. 25.2.1 Text Companion: Actor Details show Page "],["video-segment-activerecordrelation-review.html", "25.3 Video Segment: ActiveRecord::Relation Review", " 25.3 Video Segment: ActiveRecord::Relation Review Notes: time stamp 00:09:14 to 00:12:05 rails console to explore ActiveRecord objects To review, an ActiveRecord::Relation is very similar to an array, but in this case the only thing they can contain are individual ActiveRecord objects, which are rows in the table. These rows then have attributes (column values) that we can get data from using the column accessor method. For instance, at the rails console: pry(main)&gt; m = Movie.all (0.1ms) SELECT COUNT(*) FROM &quot;movies&quot; =&gt; Movie::ActiveRecord::Relation (array with 52 Movie instances inside) .all returns an array-like object with 52 movie instances, and when I get the first one out: pry(main)&gt; x = m.first Movie Load (0.2ms) SELECT &quot;movies&quot;.* FROM &quot;movies&quot; ORDER BY &quot;movies&quot;.&quot;id&quot; ASC LIMIT ? [[&quot;LIMIT&quot;, 1]] =&gt; #&lt;Movie:0x000055ba1a471588 id: 1, title: &quot;The Shawshank Redemption&quot;, year: 1994, duration: 142, : Now I have a single instance of Movie, which I can call methods on to get column values: pry(main)&gt; x.title =&gt; &quot;The Shawshank Redemption&quot; pry(main)&gt; x.year =&gt; 1994 We can note some similarities to hashes for our x instance of Movie: pry(main)&gt; x.fetch(:title) =&gt; &quot;The Shawshank Redemption&quot; pry(main)&gt; x[:title] =&gt; &quot;The Shawshank Redemption&quot; but these are not hashes, because we can call methods like .title from the table columns directly on them. 25.3.1 Text Companion: ActiveRecord::Relation Review "],["video-segment-actor-details-filmography.html", "25.4 Video Segment: Actor Details Filmography", " 25.4 Video Segment: Actor Details Filmography Notes: time stamp 00:12:05 to 00:15:31 ActiveRecord::Relation objects in app/views/actor_templates/show.html.erb to query from Actor to Character, Character to Movie, and Movie to Director on So we look at this details page view template: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;dl&gt; &lt;dt&gt; Name &lt;/dt&gt; &lt;dd&gt; &lt;%= @the_actor.name %&gt; &lt;/dd&gt; &lt;dt&gt; Dob &lt;/dt&gt; &lt;dd&gt; &lt;%= @the_actor.dob %&gt; &lt;/dd&gt; ... So first, we’re using the instance variable, the @the_actor objects, and we’re saying .name, .dob, etc., which you can do because these columns exist. So we get a method for each column, a column acts as a method for free from ActiveRecord, we didn’t have to define them. Then I get down to the filmography part of the page lower down: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;h2&gt;Filmography&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; ... &lt;% a_id = @the_actor.id %&gt; &lt;% matching_characters = Character.where({ :actor_id =&gt; a_id }) %&gt; &lt;% matching_characters.each do |a_character| %&gt; &lt;% m_id = a_character.movie_id %&gt; &lt;% matching_movies = Movie.where({ :id =&gt; m_id }) %&gt; &lt;% the_movie = matching_movies.at(0) %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= the_movie.title %&gt; &lt;/td&gt; ... &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“10-19”} If you remember the domain model here, actors and movies are in a many-to-many relationship and they’re joined by characters. These tables have associated classes in our Rails app in the app/models/ folder, and the classes are named Actor, Movie, and Character. If we recall by looking at /rails/db, our visual database browser, and navigating to the characters table, then we see there is a movie_id and actor_id. So first I got the current actor ID because we are on the page of @the_actor: &lt;% a_id = @the_actor.id %&gt;` which is just a column like any other column, so I get this accessor method .id. Then I looked at the records in the characters table with a matching actor_id: &lt;% matching_characters = Character.where({ :actor_id =&gt; a_id }) %&gt; Now I have an ActiveRecord::Relation of characters, and each of these have a movie_id. Then I’m going to do a .each on the matching_characters, and for each of these rows, put it in a block variable a_character, pull out the movie_id from the row, and look up this movie in the movies table to iteratively fill the table with movie information, like the_movie.title, in my loop: &lt;% matching_characters.each do |a_character| %&gt; &lt;% m_id = a_character.movie_id %&gt; &lt;% matching_movies = Movie.where({ :id =&gt; m_id }) %&gt; &lt;% the_movie = matching_movies.at(0) %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= the_movie.title %&gt; &lt;/td&gt; If we look further down in the filmography section, to show the director of the movie: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;h2&gt;Filmography&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; ... &lt;td&gt; &lt;% d_id = the_movie.director_id %&gt; &lt;% matching_directors = Director.where({ :id =&gt; d_id }) %&gt; &lt;% the_director = matching_directors.at(0) %&gt; &lt;%= the_director.name %&gt; &lt;/td&gt; ... &lt;/table&gt; {: mark_lines=“10-15”} I need to use the director_id column from my current movie: &lt;% d_id = the_movie.director_id %&gt; and look that director up in the directors table: &lt;% matching_directors = Director.where({ :id =&gt; d_id }) %&gt; &lt;% the_director = matching_directors.at(0) %&gt; then call .name on the row to get my table value: &lt;%= the_director.name %&gt; We’re jumping through all four tables here! Actor to Character, Character to Movie, and Movie to Director! That’s how pretty much all database relationships work. If we can do this, we can do anything. 25.4.1 Text Companion: Actor Details Filmography "],["video-segment-defining-instance-methods-in-the-model.html", "25.5 Video Segment: Defining Instance Methods in the Model", " 25.5 Video Segment: Defining Instance Methods in the Model Notes: time stamp 00:15:31 to 00:22:09 define title_with_year in app/models/movie.rb see refactoring-msm-queries-with-methods.md section “Instance method review” use of self. in model method apply new method to app/views/movie_templates/show.html.erb Let’s look at some techniques that we use to make this much easier on ourselves and more efficient for our teams. Let’s take the Movie class. All we do when we want to start using ActiveRecord, is we create the model. We put it in the app/models/ folder, named after the table singular movie.rb, define the class there inheriting from ApplicationRecord, and then boom, magically, we get a whole bunch of methods. And this is still app/models/movie.rb file is still empty. But, the power of object oriented programming, which is what Ruby is, is that we can add our own methods to this class and encapsulate frequently used logic in a nicely named method. So we don’t have to keep doing it over and over again. For example, let’s just say in the movie details view template page: &lt;!-- app/views/movie_templates/show.html.erb --&gt; &lt;h1&gt; Movie #&lt;%= @the_movie.id %&gt; details &lt;/h1&gt; &lt;a href=&quot;/movies&quot;&gt; Go back &lt;/a&gt; ... {: mark_lines=“4”} Right now I have the movie ID number in the page heading. Let’s say I want to replace that with the movie title, and next to it I want the year it was released in parantheses: &lt;!-- app/views/movie_templates/show.html.erb --&gt; &lt;h1&gt; &lt;%= @the_movie.name %&gt; (&lt;%= @the_movie.year %&gt;) &lt;/h1&gt; &lt;a href=&quot;/movies&quot;&gt; Go back &lt;/a&gt; ... {: mark_lines=“4”} That works if you visit a given movie details page like /movies/1. And I could repeat this pattern all over the place. But that’s not great. What if I just want to have that string pre-assembled? In our rails console that we opened previously using string interpolation: pry(main)&gt; &quot;#{x.title} (#{x.year})&quot; =&gt; &quot;The Shawshank Redemption (1994)&quot; I can create a method in my model! Let’s create this: # app/models/movie.rb # == Schema Information # # Table name: movies # # id :integer not null, primary key # description :text # duration :integer # image :string # title :string # year :integer # created_at :datetime not null # updated_at :datetime not null # director_id :integer # class Movie &lt; ApplicationRecord def title_with_year return &quot;howdy!&quot; end end {: mark_lines=“16-18”} BENP: have we ever up to this point seen a function with a return statement? Note the # == Schema Information in the header of this file. This is the same as the “Schema” tab that we say previously on /rails/db, and it serves as a nice reference for what is contained in the table movies associated with the file movie.rb, and the Movie class contained therein. Now in our view template we can say: &lt;!-- app/views/movie_templates/show.html.erb --&gt; &lt;h1&gt; &lt;%= @the_movie.title_with_year %&gt; &lt;/h1&gt; &lt;a href=&quot;/movies&quot;&gt; Go back &lt;/a&gt; ... {: mark_lines=“4”} And if you reload the browser page with your movie details, you will see “howdy!” at the top. The point is, you can define whatever method you want in the model file. And then you can call those methods on any movie wherever you have that movie object. So now I can do something better, like: # app/models/movie.rb ... def title_with_year return &quot;#{self.title} (#{self.year})&quot; end ... {: mark_lines=“5”} We get the title and year from whichever movie this method is being run on, and that is what the keyword self. is for. When you’re defining an instance method, and you need to call some other instance method, in order to make this instance method work, the self. keyword gives us a way to call the other instance method within the definition of this instance method. BENP: this is somewhat confusing wording. needs to be stated clearly and maybe linked to previous material. Right now there is a very long section called “Instance method review” in refactoring-msm-queries-with-methods.md that goes into this. Try to reload the movie details page at /movies/1. You should see the title and year instead of “howdy!”. So now I have this method that my whole team can use for the next ten years, saving us from tons of duplication and potential bugs! 25.5.1 Text Companion: Defining Instance Methods in the Model "],["video-segment-moviedirector.html", "25.6 Video Segment: Movie#director", " 25.6 Video Segment: Movie#director Notes: time stamp 00:22:09 to 00:29:19 define director in app/models/movie.rb to get rid of query in view templates and replace with @the_movie.director apply new method to app/views/movie_templates/show.html.erb 1-N association Let’s define a really handy one now. Currently, if I want to get the director in the /movies/1 page, I need to do something like: &lt;!-- app/views/movie_templates/show.html.erb --&gt; &lt;h1&gt; &lt;%= @the_movie.title_with_year %&gt; &lt;/h1&gt; &lt;% d_id = @the_movie.director_id %&gt; &lt;% matching = Director.where({ :id =&gt; d_id }) %&gt; &lt;% d = matching.at(0) %&gt; &lt;h1&gt; Directed by &lt;%= d.name %&gt; &lt;/h1&gt; &lt;a href=&quot;/movies&quot;&gt; Go back &lt;/a&gt; ... {: mark_lines=“7-12”} I need to use the column accessor method to get the ID number of the director, then I need to store it, then I need to look up the director by searching within the ID column, then I store that, then I get the first element, and finally I have the director record which I can call the name on and place in an HTML tag. This should all work and we can now see the director on the page. Sure this works, but it’s pretty annoying. What if I just had a method I could call that looked like @the_movie.director, which just returns the director record (d above), and I can avoid several lines of embedded code? Let’s do it. # app/models/movie.rb ... class Movie &lt; ApplicationRecord def title_with_year return &quot;#{self.title} (#{self.year})&quot; end def director the_director = Director.where({ :id =&gt; self.director_id }).at(0) return the_director end end {: mark_lines=“9-12”} Again, we are using self. to get the director_id of the object that this method is called on, which is an instance of the Movie object (@the_movie on our view template page). Then we look up this ID in the directors table in the id column using the Director model that we defined. And now we can just return this single record! So now in our view template, we can replace the previous multiline code with: &lt;!-- app/views/movie_templates/show.html.erb --&gt; &lt;h1&gt; &lt;%= @the_movie.title_with_year %&gt; &lt;/h1&gt; &lt;h1&gt; Directed by &lt;%= @the_movie.director.name %&gt; &lt;/h1&gt; &lt;a href=&quot;/movies&quot;&gt; Go back &lt;/a&gt; ... {: mark_lines=“8”} We get our @the_movie.director object, which is a whole row of the directors table, and we can get the name using our attribute accessor method for that object. We could even do @the_movie.director.dob or @the_movie.director.bio to get other information about the director in that row. Reload /movies/1 and you will see the intended result! Our new instance method encapsulates the one-to-many association between movies and directors, and we (and our team) can use it anywhere. It dramatically simplifies our work. If you take the time, especially for these one-to-many and many-to-many associations, which we work with a lot, and define a method, then it makes other things much easier. 25.6.1 Text Companion: Movie#director "],["video-segment-directorfilmography.html", "25.7 Video Segment: Director#filmography", " 25.7 Video Segment: Director#filmography Notes: time stamp 00:29:19 to 00:33:34 other side of 1-N association define filmography in app/models/director.rb to get rid of query in view templates and replace with @the_director.filmography apply new method to app/views/director_templates/show.html.erb We make these associations a lot, so it’s convention after we have our models in our Rails app, to encapsulate them in instance methods immediately. And we call the method the singular of the other table like def director, if it’s the one-side of a one-to-many relationship. Of course there’s another side of this one-to-many relationship: a director can have many movies. On my director details view template in the filmography section, I will find a bit of code like: &lt;!-- app/views/director_templates/show.html.erb --&gt; ... &lt;% the_id = @the_director.id %&gt; &lt;% matching_movies = Movie.where({ :director_id =&gt; the_id }) %&gt; &lt;% films = matching_movies.order({ :year =&gt; :asc }) %&gt; &lt;% films.each do |a_movie| %&gt; ... This is a similar but inverse procedure from before. Before, we started with the foreign key and looked up the primary key, and here it is the opposite. We start with the record @the_director, get the primary key id of that, look up this primary key in the foreign key column of movies, and then loop through the resulting records in matching_movies. In this case, we also sorted the resulting records into chronologically ascending order with the year column prior to looping. What we want instead here is a method that looks like: @the_director.filmography, that will give us back the matching_movies variable, and avoid all these lines of code. Well, let’s now go into our director.rb model and code in this method: # app/models/director.rb ... class Director &lt; ApplicationRecord def filmography the_films = Movie.where({ :director_id =&gt; self.id }).order({ :year =&gt; :asc }) return the_films end end {: mark_lines=“5-8”} Again, we see the opposite logic from last time when we wanted the director of a movie. Here we have the primary key from the director (self.id), and we want to look up all similar ids in the foreign key of the movies table. Again, we are chaining an .order method here, so the returned records are chronologically ordered for our looping step. Armed with this new method we can replace the all the previous code in our view template with just one line: &lt;!-- app/views/director_templates/show.html.erb --&gt; ... &lt;% @the_director.filmography.each do |a_movie| %&gt; ... 25.7.1 Text Companion: Director#filmography "],["video-segment-additional-association-accessor-methods.html", "25.8 Video Segment: Additional Association Accessor Methods", " 25.8 Video Segment: Additional Association Accessor Methods Notes: time stamp 00:33:34 to 00:59:46 work independently to define additional 1-N associations BENP: recording is just class working independently for most of this time All of this is what we call association accessor methods, and we do it at the beginning of every project. The first step is we create our data model, we figure out our columns, our tables, our one-to-manys and our many-to-manys. Then, as soon as we start writing code, as soon as we create our model files, we first write these methods on both sides of the relationship that need them to make querying much easier. We have some other association accessor methods that we need to define our current data model. There are three 1-N associations:: # Director =&gt; Movie # Movie =&gt; Character # Actor =&gt; Character You should try to define the six methods needed: # Director#filmography (we did this!) # Movie#director (and this!) # Movie#characters # Character#movie # Actor#characters # Character#actor Defining these last four is your job. Try and do this on your own based on the two sides of the 1-N that we defined, and run rails grade and /git commit as you get things working! Keep in mind there is some reference (written notes) for this project here, including a section reviewing instance methods. 25.8.1 Text Companion: Additional Association Accessor Methods "],["video-segment-additional-association-accessor-methods-solved.html", "25.9 Video Segment: Additional Association Accessor Methods Solved", " 25.9 Video Segment: Additional Association Accessor Methods Solved Notes: time stamp 00:59:46 to 01:05:57 finish 1-N association accessor methods in the models First, we can solve the 1-N relationship for movies to characters: # app/models/movie.rb ... class Movie &lt; ApplicationRecord def title_with_year return &quot;#{self.title} (#{self.year})&quot; end def director the_director = Director.where({ :id =&gt; self.director_id }).at(0) return the_director end def characters the_characters = Character.where({ :movie_id =&gt; self.id }) return the_characters end end {: mark_lines=“14-17”} By convention we define the method as characters (the name of what we want plural), unless we have a better, more descriptive name in mind (like when we used filmography). I am filtering the characters table above by the primary key of the currenty movie, in the foreign key column of that table. We get back potentially multiple rows, so we don’t need a .at(0). On the other side of this relationship in character.rb, we can do: # app/models/character.rb ... class Character &lt; ApplicationRecord def movie return Movie.where({ :id =&gt; self.movie_id }).at(0) end end {: mark_lines=“5-7”} And now we go to the movies table with our foreign key from the current character, and filter the primary keys to get the one movie that matches with .at(0). And now for the last 1-N, we start with the many characters that can be associated to one actor: # app/models/actor.rb ... class Actor &lt; ApplicationRecord def characters return Character.where({ :actor_id =&gt; self.id }) end end {: mark_lines=“5-7”} And back in our character.rb, the one actor associated with a given character: # app/models/character.rb ... class Character &lt; ApplicationRecord def movie return Movie.where({ :id =&gt; self.movie_id }).at(0) end def actor return Actor.where({ :id =&gt; self.actor_id }).at(0) end end {: mark_lines=“9-11”} Are you seeing the patterns and similarities? In many cases we can just copy-paste and change the name of the table! 25.9.1 Text Companion: Additional Association Accessor Methods Solved "],["video-segment-applying-association-accessor-methods.html", "25.10 Video Segment: Applying Association Accessor Methods", " 25.10 Video Segment: Applying Association Accessor Methods Notes: time stamp 01:05:57 to 01:12:15 replace all DB queries with 1-N association accessor methods in the view templates Any place where we have a database query in one of the 1-N associations, we want to replace it. Let’s begin by going to the director details view template and replacing this: &lt;!-- app/views/director_templates/show.html.erb --&gt; ... &lt;% the_id = @the_director.id %&gt; &lt;% matching_movies = Movie.where({ :director_id =&gt; the_id }) %&gt; &lt;% films = matching_movies.order({ :year =&gt; :asc }) %&gt; &lt;% films.each do |a_movie| %&gt; ... with: &lt;!-- app/views/director_templates/show.html.erb --&gt; ... &lt;% @the_director.filmography.each do |a_movie| %&gt; ... if you haven’t already. Let’s go to the movie index view template and replace this: &lt;!-- app/views/movie_templates/index.html.erb --&gt; ... &lt;% matching_directors = Director.where({ :id =&gt; a_movie.director_id }) %&gt; &lt;% the_director = matching_directors.at(0) %&gt; &lt;%= the_director.name %&gt; ... with: &lt;!-- app/views/movie_templates/index.html.erb --&gt; ... &lt;%= a_movie.director.name %&gt; ... Let’s go to the movie details view template and replace this: &lt;!-- app/views/movie_templates/show.html.erb --&gt; ... &lt;% matching_directors = Director.where({ :id =&gt; @the_movie.director_id }) %&gt; &lt;% the_director = matching_directors.at(0) %&gt; &lt;%= the_director.name %&gt; ... with: &lt;!-- app/views/movie_templates/show.html.erb --&gt; ... &lt;%= @the_movie.director.name %&gt; ... And now on the actor details page, replace this: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;% a_id = @the_actor.id %&gt; &lt;% matching_characters = Character.where({ :actor_id =&gt; a_id }) %&gt; &lt;% matching_characters.each do |a_character| %&gt; &lt;% m_id = a_character.movie_id %&gt; &lt;% matching_movies = Movie.where({ :id =&gt; m_id }) %&gt; &lt;% the_movie = matching_movies.at(0) %&gt; ... with: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;% @the_actor.characters.each do |a_character| %&gt; &lt;% the_movie = a_character.movie %&gt; ... And below this in the same file replace: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;% d_id = the_movie.director_id %&gt; &lt;% matching_directors = Director.where({ :id =&gt; d_id }) %&gt; &lt;% the_director = matching_directors.at(0) %&gt; &lt;%= the_director.name %&gt; ... with: &lt;!-- app/views/actor_templates/show.html.erb --&gt; ... &lt;%= the_movie.director.name %&gt; ... This became dramatically simpler here. We have these methods to traverse through all of our tables. Let’s make sure this all works by manually visiting the pages and checking, and then running our automated tests with rails grade to insure that our refactoring did not break anything and introduce regressions. We didn’t gain any new superpowers as far as new features that we’re able to build. But our code base is so much more maintainable now. It’s going to be so much easier for us to build new features now that we have these association accessor methods. 25.10.1 Text Companion: Applying Association Accessor Methods "],["finish-and-submit-refactoring-msm-queries.html", "25.11 Finish and Submit Refactoring MSM Queries", " 25.11 Finish and Submit Refactoring MSM Queries "],["domain-modeling.html", "26 Domain Modeling", " 26 Domain Modeling Notes: This is classroom work, but there is room here for a video+text walkthrough of ideas.firstdraft Day 6 recording video is partially transcribed in day-6-recording.md. This is copied below/ Project: domain model OfferUp Solution: https://canvas.uchicago.edu/courses/41147/assignments/465866 "],["data-model-for-offerup.html", "26.1 Data model for OfferUp", " 26.1 Data model for OfferUp BENP: this is Copy-Paste from Canvas Explore this target application: OfferUp It’s a simplified version of the real OfferUp – a two-sided market. Users can: post items to sell browse items to purchase chat with sellers to make offers sellers can mark items as sold once satisfied buyers and sellers coordinate meeting up on their own Sign up for a new account in our version of Offer Up or use our standard (alice/bob/carol@example.com with password of password). Explore and experiment with the features. Then: design a data model that can support all user actions that you observe in app. I.e., a complete listing of tables and columns. Some old slide decks that might be handy to refer to: ERD &amp; Ideas Records &amp; Relationships Remember that it’s usually helpful to create your tables on paper or in a spreadsheet and entering some sample records to make sure you can record everything you’re trying to record, before attempting to create the compact Entity Relationship Diagram (ERD). Finally, draw an ERD of your schema design in firstdraft.com. You can refer to the written documentation on how to use firstdraft.com. BENP: the image / GIF of the OfferUp firstdraft solution (“Part 2b: OfferUp example solution” on Canvas) could be plopped in here, or that’s part of the tutorial video for this app "],["video-segment-ideas-tutorial.html", "26.2 Video Segment: Ideas Tutorial", " 26.2 Video Segment: Ideas Tutorial Notes: content does not exist dedicated tutorial for ideas.firstdraft.com with domain model for OfferUp 26.2.0.1 Text Companion: Ideas Tutorial Notes: can be pulled from https://canvas.uchicago.edu/courses/41147/pages/firstdraft-ideas-erd-tool "],["photogram-gui.html", "27 Photogram GUI", " 27 Photogram GUI Notes: Video transcription is in photogram-gui.md Project (graded): https://github.com/appdev-projects/photogram-gui Target: https://photogram-gui.matchthetarget.com/ Useful chapters: active-record.md#time-to-crud "],["video-segment-crud-with-forms.html", "27.1 Video Segment: CRUD with Forms", " 27.1 Video Segment: CRUD with Forms Notes: time stamp 00:00:00 to 00:05:11 CRUD in relation to MSM app forms for getting data into query string and then into database BENP: up to 00:10:00 is just a walk through with lots of talking in the target. I wrote down what was said but no screenshots. Video is pretty good as is up to this point. In this project, Photogram GUI, we’re finally going to be building a Graphical User Interface, for our users to CRUD, Create, Read, Update and Delete data into our database tables. We’ve already done a lot of work with the R part. Given some data, we have displayed that data in our webpages a whole bunch of different ways. We’ve done really complicated queries to display that data. We’ve shown the rows in a table, we’ve shown an individual record details based on the ID number in the URL, and we’re using params. We also showed the records associated to an individual record in a one-to-many association. For example, the movies in the filmography for a director. We put those movies right on the details page in the director. So that was pretty great. We also showed, in a many-to-many relationship, the rows associated to a record. For example, on the actor details page, we showed all of the movies in a filmography. So we’ve done actually, believe it or not, quite advanced queries, if you ask a database person. And all without really thinking too hard about it. All we were doing was using .where, our bread-and-butter query method, and using what we have been thinking about since week one: foreign keys and join tables to connect our entities together in 1-N and N-N relationships, and doing lookups. And that’s all CRUD applications boil down to. Okay, but we’re missing one huge thing, which is, how do we get the data into the database in the first place? So far, we’ve been relying on rails console (manual entry), /rails/db (visual interface), and rails sample_data (rake task for sample data). We need to give our users a way to enter data. The whole point of our applications was keeping track of important information on behalf of our users: record keeping. And so we spent the first couple of weeks figuring out how to think of what that information is, and design database tables to keep track of that information. Let’s give them some forms (&lt;form&gt;&lt;/form&gt;) to fill out so that they can tell us their information (&lt;label&gt;&lt;/label&gt; and &lt;input&gt;). And then when they click submit (&lt;button&gt;&lt;/button&gt;) on those forms, we know that that information is going to go to some other URL, specified by the action attribute of the opening form tag (&lt;form action=\"/URL/here/\"&gt;). The information they provide in the form is going to be put into the query string on that next URL (/URL/here?input_one=foo&amp;input_two=bar), and then Rails is going to stick all that into the params hash. And then we can take all that stuff out of the params hash in that second action. Phew! In the past, we just computed some stuff and then kind of showed them some output and then forgot about all that stuff. Or maybe we put it into a cookie that we store in their browser, which is useful for a whole bunch of stuff, especially sign-in and sign-up in the next week. BENP: we didn’t talk about cookies up to this point, maybe leave out Now, we’re going to take all that information from the user and save it into a record in our database, rather than us, the developers, using rails console, /rails/db, and/or rails sample_data. And so it’s all going to finally come together. Everything we learned about routing, RCAV, params, forms, all that stuff. And everything we’ve been learning about ActiveRecord and databases, that’s finally going to come together, and we’re going to build our target Photogram app. 27.1.1 Text Companion: CRUD with Forms "],["video-segment-explore-the-target.html", "27.2 Video Segment: Explore the Target", " 27.2 Video Segment: Explore the Target Notes: time stamp 00:05:11 to 00:10:05 CRUD in relation to Photogram GUI BENP: here’s where screenshots or GIFs could be inserted It’s very simple. Right now it’s just a list of users and photos. Next week, we’re going to add the final piece of this, which is cookies for sign-in and sign-up. But right now, anybody can just add users and it just adds the record to the table. So there are no accounts yet. It’s just like adding an actor or adding a director. We are just adding records to the table right now. There’s a form to add /users. There’s a form to add /photos. And that’s what we have to wire up. In addition to that, if we go into the details page of a user, like /users/desmond, there’s also a form with the username pre-populated. Notice this URL /users/desmond isn’t an ID number, but it’s a username, and follows the same principle as putting the ID number. We know how to build a route where this can vary, and then take that information and use it to populate a page. We did that! We’re going to do that again, but now we’re going put a form in here and let them update some information. If we change the username with the form to “desmond2” and click “Update user”, I come back to the same URL, but now changed to /users/desmond2. Now, similarly, you’ve got /photos, and you can go to the details page of one, say /photos/861. There’s a another edit form here, and again if I change something and click “Update photo”, I’ll end up back on the details page and that change has been persisted. And I can delete the photo. If I scroll down farther on the photo details page, there’s a section for “Comments”, and I can add a new comment. Now, when I’m adding a new comment, I have to type in an “Author ID”, which is kind of annoying. You have to provide a valid ID number, or it’s not going to work. So there’s a new concept of validation. BENP: validates is used in this project and there are notes and examples below, but this is covered in much more detail in data-integrity-with-validations.md chapter: https://chapters.firstdraft.com/chapters/845, and optional project: https://github.com/appdev-projects/msm-validations Okay, so there’s some work to be done to get here to this target. Believe it or not, little of this is new. We’ve done forms, we’ve done params, we’ve done dynamic routes, we’ve done ActiveRecord, and we’ve done CRUD at the rails console (e.g., with .new, then add attribute values, then .save). It might help to actually keep that CRUD chapter section handy for reference. In fact, another useful chapter to keep open for reference is the compendium one reference chapter, which is a concise class and method reference. BENP: editorialized that last sentence, which you bring up a few minutes later in video Let’s get started. 27.2.1 Text Companion: Explore the Target "],["video-segment-explore-the-erd.html", "27.3 Video Segment: Explore the ERD", " 27.3 Video Segment: Explore the ERD Notes: time stamp 00:10:10 to 00:18:15 examine /rails/db, run rails sample_data examine ERD (https://github.com/appdev-projects/photogram-gui/blob/master/erd.png) discuss 1-N and N-N relationships in the domain As usual, I’m going to start with config/routes.rb, because that’s the entry point to any Rails application: the list of URLs a user can visit. You can also use the tool /rails/info in the browser of your workspace, which will answer the same question: what requests does this Rails app respond to right now? Open that file now: # config/routes.rb Rails.application.routes.draw do end It’s empty! Looks like we need to build it all from scratch… not quite true. If I visit /rails/db in my browser, I at least have database tables created for comments, follow_requests, likes, photos, and users. We’ve been planning this architecture for a long time for our social network. The database is, however, empty, and we don’t have any routes defined. We can hope that someone wrote a rake task to populate our database with sample data… and if you run rails sample_data at the terminal in GitPod you will find that this is the case! If we click on the users table in /rails/db (taking us to /rails/db/tables/users/data), we see we have lots of columns, and it might help to actually view our domain model: This is our Entity Relationship Diagram or ERD. I like to include such diagrams with my project README. In fact there’s a gem that generates such ERDs for you. Remember we have users and photos in a 1-N association. I called the foreign key owner_id in photos, to keep track of which user owns which photo. Conventionally we would call the foreign key whatever the other table is called with an _id, user_id in this case. But, sometimes we want something more descriptive, and in the end it is up to me, the developer to choose these names. Photos also have caption, comments_count, and likes_count. I didn’t necessarily even need the _count columns, since these could be looked up with the photo foreign key columns. But it’s nice to keep the value here so I can use .order by the number of likes for sorting the records. We also have a join table for an N-N relationship called likes with the two foreign keys fan_id (from users table) and photo_id (from photos table). Again, we see a more descriptive name chosen in this case than the conventional user_id for this table. Now we have our comments table, which is very similar to likes, with foreign key columns for the users (author_id here) and photos (photo_id again), and the addition of the comment text in the body column. Within the users table we also have an internal N-N relationship, since one user can have many followers and leaders, and this is captured in the follow_requests table. We note that here the model classname will be FollowRequest (snake_case to CamelCase and made singular). Follow requests has two foreign key columns, both from the users table: recipient_id and sender_id. There is also the status column for keeping track of whether the “pending” request was “accepted” or “rejected”. We won’t tackle all of this now. Today, we are just building an interface for users to enter records into these tables, update them, and delete them. This means we’re going to have to do a lot of RCAV to set everything up. 27.3.1 Text Companion: Explore the ERD "],["video-segment-explore-model-classes.html", "27.4 Video Segment: Explore Model Classes", " 27.4 Video Segment: Explore Model Classes Notes: time stamp 00:18:15 to 00:20:58 examine app/models/user.rb association accessor instance methods there and in other models validates (first mention, only detailed later in https://github.com/appdev-projects/msm-validations and data-integrity-with-validations.md) But we actually have even more in our starting point that will help us. The model files are already in the project, for instance, you can find: # app/models/user.rb # == Schema Information # # Table name: users # # id :integer not null, primary key # comments_count :integer # likes_count :integer # private :boolean # username :string # created_at :datetime not null # updated_at :datetime not null # class User &lt; ApplicationRecord validates(:username, { :presence =&gt; true, :uniqueness =&gt; { :case_sensitive =&gt; false }, }) def comments my_id = self.id matching_comments = Comment.where({ :author_id =&gt; my_id }) return matching_comments end ... end And these are full of association accessor instance methods BENP: I have not been using or have been loose with instance vs class method, probably need to comb through everything and check consistency, like comments above, which you can use out-of-the-box to query across your tables. This is what we spent all the time building when we refactored MSM queries, and you get it here for free. Note that there are also some validates functions, which we haven’t discussed yet, to do the validations of data entered into our tables. BENP: here is the first mention of validates, which we use here, but is covered much more in chapter/project that follows Photogram GUI: https://github.com/appdev-projects/msm-validations The comments method will return a list of comments made by a given user, and would be used like a_user.comments. This is an ActiveRecord::Relation returned, and one could .each over the rows to display data on a page! No need for writing out these queries over and over again on your view templates. Ever! Take a look at the model files for each table in app/models. Spend time reading them. There are a lot of methods and having them are going to make our job a lot easier. Familiarlize yourself with what you have so that you are armed to build out the app. 27.4.1 Text Companion: Explore Model Classes "],["video-segment-users-index.html", "27.5 Video Segment: Users index", " 27.5 Video Segment: Users index Notes: time stamp 00:20:58 to 00:27:25 RCAV to get table of users at /users query in index action to get ActiveRecord::Relation object @list_of_users Let’s start building out the pages. The homepage / in our target is the list of users (also at the path /users). So let’s RCAV. # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) end {: mark_lines=“5-6”} We are using the standard, conventional names in use in the Rails community from here on out. That means we name the controller for the page after the table plural. For the action that just lists our records, we call it index. Now we create that controller and action: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def index render({ :template =&gt; &quot;user_templates/index.html.erb&quot; }) end end Now we create the view template user_templates/index.html.erb, place some copy there (why not.. “hi”?), and view it in our browser at / or /users: &lt;!--- app/views/user_templates/index.html.erb ---&gt; &lt;h1&gt;hi&lt;/h1&gt; We can view the target, and see that we want a table with a list of users here. So let’s put some mockup in our view template based on what we see there: &lt;!--- app/views/user_templates/index.html.erb ---&gt; &lt;h1&gt;List of users&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt; ID &lt;/th&gt; &lt;th&gt; Username &lt;/th&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; {: mark_lines=“3-18”} If we now refresh the /users URL, this is going to make a blank table with three columns that we want to fill in with the ID, username, and a “Show details” link. So now we need all of the user records from our users table. What we want is something like: &lt;!--- app/views/user_templates/index.html.erb ---&gt; &lt;h1&gt;List of users&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt; ID &lt;/th&gt; &lt;th&gt; Username &lt;/th&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% @list_of_users.each do |a_user| %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= a_user.id %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= a_user.username %&gt; &lt;/td&gt; &lt;td&gt; Show details &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“19-33”} We want an instance variable to loop over in our front-end. Specifically we want a list of rows from our users table and then we can get things like the .id and .username from each row. We’ll make the “Show details” link work later. Let’s go back to our action in the back-end and prepare this instance variable @list_of_users: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def index @list_of_users = User.all.order({ :username =&gt; :asc }) render({ :template =&gt; &quot;user_templates/index.html.erb&quot; }) end end {: mark_lines=“5”} And now, since we defined the variable, if we refresh /users in our browser, then we will see the populated table with our list of records with no error messages. And we even ordered is alphabetically by username using .order({ :username =&gt; :asc }) in the action. Now would be a good time for a rails grade and a /git commit if everything is working like the target. 27.5.1 Text Companion: Users index "],["video-segment-user-details-show.html", "27.6 Video Segment: User Details show", " 27.6 Video Segment: User Details show Notes: time stamp 00:27:25 to 00:47:40 more on validates (probably should be moved from here) RCAV a details page with flexible / dynamic routes, using /users/:path_username redirect_to if nil user, otherwise render({ :template =&gt; \"user_templates/show.html.erb\" }) “Own photos” table with association accessor methods @the_user.own_photos and a_photo.poster.username Faker gem We still need to make the “Show details” link work. This user details page has the username as the second dynamic segment. In the past we have just used the ID number to do this. But every user has to have a valid username, which we saw in our model, but didn’t discuss: # app/models/user.rb ... class User &lt; ApplicationRecord validates(:username, { :presence =&gt; true, :uniqueness =&gt; { :case_sensitive =&gt; false }, }) ... end What is this saying? Well we are using the inherited function validates() and the first argument is the column of our users table, username. The second argument is a hash containing some requirements for the username value. It must be present, so it must exist, with :presence =&gt; true, and it must be unique among users and case-sensitive, with :uniqueness =&gt; { :case_sensitive =&gt; false }. So a user must include a username, it must not exist in the table, and if a user like “raghu” exists, then “Raghu” won’t work. BENP: this aside about validates could be removed. Actually probably not because comes back below (see my note there) Before we get “Show details” to work on our index page, we need to build the show action, which is the user details page. Just like how we had movie or director details. If in our app we go to /users/austin (or any other username in our table), then we get the “no route matches” error and we can start debugging the RCAV: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) end {: mark_lines=“7”} We are using a dynamic route with the second segment :path_username, which we know will end up in our params, and we use the conventional action name for showing the details of a record, show. Now we create that action and show something in our view template: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def show render({ :template =&gt; &quot;user_templates/show.html.erb&quot; }) end end {: mark_lines=“5-7”} Right away we put in some mockup to match the target here: &lt;!--- app/views/user_templates/show.html.erb ---&gt; &lt;h1&gt;username&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;ID&lt;/dt&gt; &lt;dd&gt;user_id&lt;/dd&gt; &lt;dt&gt;Edit user&lt;/dt&gt; &lt;dd&gt;Form goes here&lt;/dd&gt; &lt;/dl&gt; &lt;h2&gt;Own photos (photo count count goes here)&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;/table&gt; Of course, we will now need to fill in the static HTML here with dynamic embedded Ruby to get the page to work for each user. In my server log on GitPod (the terminal running bin/server), we can see that anything I put in the second segment of /users/austin, will end up in the params, like {\"path_username\"=&gt;\"austin\"}. That is available in our show action. So let’s make it work now: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def show url_username = params.fetch(&quot;path_username&quot;) @the_user = User.where({ :username =&gt; url_username }).first render({ :template =&gt; &quot;user_templates/show.html.erb&quot; }) end end {: mark_lines=“6-7”} We got the username from the URL path, then we used that username to find the matching record in our users table by searching the username column (which we have access to through the User model). We are expecting one record, so we use .first to get back a single object, our instance variable @the_user, which we’ll use in our view template. But wait! This @the_user could be empty or nil, if there is no valid username that was entered in the URL found in our table. What do we do then? Well we can check on this and redirect if necessary: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def show url_username = params.fetch(&quot;path_username&quot;) @the_user = User.where({ :username =&gt; url_username }).first if @the_user == nil redirect_to(&quot;/&quot;) else render({ :template =&gt; &quot;user_templates/show.html.erb&quot; }) end end {: mark_lines=“9-12”} So now if you get back a nil user, then you are redirected to the homepage, otherwise you are taken to the details page. Now, if we really wanted to write our code defensively like this, we would need to put similar if-else statements in many other places. But we won’t worry about this for now, we just want to be aware of the possibility of returning nil and one solution. BENP: this nil redirect aside is also removable, you comment out the code in the video… Back to the view template with our new @the_user object: &lt;!--- app/views/user_templates/show.html.erb ---&gt; &lt;h1&gt;&lt;%= @the_user.username %&gt;&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;ID&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_user.id %&gt;&lt;/dd&gt; &lt;dt&gt;Edit user&lt;/dt&gt; &lt;dd&gt;Form goes here&lt;/dd&gt; &lt;/dl&gt; ... {: mark_lines=“3 7”} We have some progress. Now, what about the “Own photos” section farther down the page? Association accessor methods to the rescue! We have pre-defined a method own_photos in the app/models/user.rb model (go see for yourself). This method returns a list of a given users photos, which we can put in the table (or even call a .count on to get the number of records): &lt;!--- app/views/user_templates/show.html.erb ---&gt; ... &lt;h2&gt;Own photos (&lt;%= @the_user.own_photos.count %&gt;)&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Image&lt;/th&gt; &lt;th&gt;Owner&lt;/th&gt; &lt;th&gt;Caption&lt;/th&gt; &lt;th&gt;Posted&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;% @the_user.own_photos.each do |a_photo| %&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;&lt;%= a_photo.image %&gt;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.poster.username %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.caption %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.created_at %&gt;&lt;/td&gt; &lt;td&gt;Show details&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“4-23”} These are all the familiar patterns of .each looping over table records and accessing attributes to print in a table (or assign to an HTML tag attribute as in &lt;img src=\"\"&gt;). Note that we could have easily just used the @the_user.username to fill the “Owner” column, because we are on that user’s page. But we showed off another association accessor method, by going from the photo a_photo through the method in the Photo model poster (have a look in app/models/photo.rb and see for yourself), to give us back the user that posted that image, and call username there. As an aside, we generated all this random data with a gem called Faker. Very useful for testing purposes. 27.6.1 Text Companion: User Details show "],["video-segment-adding-navigation-links.html", "27.7 Video Segment: Adding Navigation Links", " 27.7 Video Segment: Adding Navigation Links Notes: time stamp 00:47:40 to 00:50:45 add navbar links to the app/views/layouts/application.html.erb Before we go any further, I want a way to navigate my site by clicking rather than manually entering URLs. Let’s add the navigation links in the page headers like we see on the target for “Users” and “Photos”. To do that we go into our layout view and add it in the &lt;body&gt; tag around where we want the pages to &lt;%= yield %&gt;: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Photogram GUI&lt;/title&gt; &lt;%= csrf_meta_tags %&gt; &lt;!-- Expand the number of characters we can use in the document beyond basic ASCII  --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- Make it responsive to small screens --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;%= csp_meta_tag %&gt; &lt;%= stylesheet_link_tag &#39;application&#39;, media: &#39;all&#39; %&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/users&quot;&gt;Users&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/photos&quot;&gt;Photos&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“20-25”} Remember, Rails made this file for you and included all of the HTML header information we discussed early on, so we don’t need to worry about putting this on all of our view templates. Rails gives you a huge head start with this and so many other files that we see in the GitPod workspace. By adding this code to our application layout file, we will see that anywhere we go in our app, the nav bar will follow. 27.7.1 Text Companion: Adding Navigation Links "],["video-segment-users-show-details-link.html", "27.8 Video Segment: Users Show Details Link", " 27.8 Video Segment: Users Show Details Link Notes: time stamp 00:50:45 to 00:52:44 add show details link on /users table with href=\"/users/&lt;%= a_user.username %&gt;\" Let’s go back and make the user “Show details” link on the /users page actually work, so we don’t need to manually enter usernames in our URL path to get to their page. &lt;!--- app/views/user_templates/index.html.erb ---&gt; ... &lt;% @list_of_users.each do |a_user| %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= a_user.id %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= a_user.username %&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/users/&lt;%= a_user.username %&gt;&quot;&gt;Show details&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“15”} And this link will work right away for each user in the table because we defined our dynamic routes, like /users/anisa, /users/austin, etc. So this href=\"\" attribute will lead to a defined route when we click the “Show details” link in our table on /users. The index and show pages for users is looking good, so let’s rails grade and /git commit. 27.8.1 Text Companion: Users Show Details Link "],["video-segment-photos-index.html", "27.9 Video Segment: Photos index", " 27.9 Video Segment: Photos index Notes: time stamp 00:52:44 to 01:00:00 RCAV /photos and get list of photos in index action for table in view template include show details link with href=\"/photos/&lt;%= a_photo.id %&gt;\" Let’s work on the photos page now so we can move on to our new stuff, which is the “Delete” links and the forms. The usual steps now: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) end {: mark_lines=“8”} # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController def index render({ :template =&gt; &quot;photo_templates/index.html.erb&quot; }) end end &lt;!--- app/views/photo_templates/index.html.erb ---&gt; &lt;h1&gt;hi&lt;/h1&gt; And once that’s working and we have no errors when we go to /photos in our browser, we add mockup HTML from the target and what we want to loop in our table: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; &lt;h1&gt;List of photos&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Image&lt;/th&gt; &lt;th&gt;Caption&lt;/th&gt; &lt;th&gt;Owner&lt;/th&gt; &lt;th&gt;Posted&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% @list_of_photos.each do |a_photo| %&gt; &lt;tr&gt; &lt;td&gt;Some image&lt;/td&gt; &lt;td&gt;Some caption&lt;/td&gt; &lt;td&gt;Some username&lt;/td&gt; &lt;td&gt;Some time&lt;/td&gt; &lt;td&gt;Show details&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; And now we need to get our required instance variable in the action on the back-end: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController def index @list_of_photos = Photo.all.order({ :created_at =&gt; :desc }) render({ :template =&gt; &quot;photo_templates/index.html.erb&quot; }) end end {: mark_lines=“5”} In our new controller action we ordered by newest photo first (created_at column ordered into descending time). And now we can fill in our static HTML in the loop with our new dynamic Ruby: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; &lt;h1&gt;List of photos&lt;/h1&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Image&lt;/th&gt; &lt;th&gt;Caption&lt;/th&gt; &lt;th&gt;Owner&lt;/th&gt; &lt;th&gt;Posted&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% @list_of_photos.each do |a_photo| %&gt; &lt;tr&gt; &lt;td&gt;&lt;img src=&quot;&lt;%= a_photo.image %&gt;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.caption %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.poster.username %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_photo.created_at %&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/photos/&lt;%= a_photo.id %&gt;&quot;&gt;Show details&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“16-20”} And if we refresh /photos, we will see our nice table of records. Let’s /git commit it. 27.9.1 Text Companion: Photos index "],["video-segment-photo-details-show.html", "27.10 Video Segment: Photo Details show", " 27.10 Video Segment: Photo Details show Notes: time stamp 01:00:00 to 01:06:43 RCAV /photos/:path_id flexible route use photo ID from URL in params in show action to get photo details and display Now if I click on one of the “Show details” links on /photos, I get a “no route matches” error. So we can RCAV that now. # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/photos/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot; }) end {: mark_lines=“9”} # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def show render({ :template =&gt; &quot;photo_templates/show.html.erb&quot; }) end end {: mark_lines=“5-7”} &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;hi&lt;/h1&gt; And once that’s working and we have no errors when we go to /photos/777 in our browser (or any photo ID in that second segment), we add mockup HTML from the target and what we want to display: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;Some image&lt;/dd&gt; &lt;dt&gt;Caption&lt;/dt&gt; &lt;dd&gt;Some caption&lt;/dd&gt; &lt;dt&gt;Owner&lt;/dt&gt; &lt;dd&gt;Some owner&lt;/dd&gt; &lt;dt&gt;Posted&lt;/dt&gt; &lt;dd&gt;Some time&lt;/dd&gt; &lt;dt&gt;Edit photo&lt;/dt&gt; &lt;dd&gt;Form goes here&lt;/dd&gt; &lt;dt&gt;Delete photo&lt;/dt&gt; &lt;dd&gt;Delete this photo&lt;/dd&gt; &lt;/dl&gt; And now we need to get our instance variable in the action on the back-end. Well we have the ID number of the photo is our URL path, and we have defined this path dynamically in config/routes.rb, so we know this photo ID number is in params (you can check in the bin/server terminal log when you visit a photo details page). Well then, back in the action we can: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def show url_id = params.fetch(&quot;path_id&quot;) @the_photo = Photo.where({ :id =&gt; url_id }).first render({ :template =&gt; &quot;photo_templates/show.html.erb&quot; }) end end {: mark_lines=“6-7”} And use this photo record back in the template to replace the static portions: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;&lt;img src=&quot;&lt;%= @the_photo.image %&gt;&quot;&gt;&lt;/dd&gt; &lt;dt&gt;Caption&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.caption %&gt;&lt;/dd&gt; &lt;dt&gt;Owner&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.poster.username %&gt;&lt;/dd&gt; &lt;dt&gt;Posted&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.created_at %&gt;&lt;/dd&gt; ... &lt;/dl&gt; {: mark_lines=“7 10 13 16”} And if we refresh /photos/777 (or any other photo), we will see our details (minus the form and delete link). 27.10.1 Text Companion: Photo Details Page "],["video-segment-photo-comments-with-association-accessors.html", "27.11 Video Segment: Photo Comments with Association Accessors", " 27.11 Video Segment: Photo Comments with Association Accessors Notes: time stamp 01:06:43 to 01:10:54 get “Comments” section on photo details page using @the_photo.comments.each and a_comment.commenter association accessor methods Just like in the target, we still need to add the photo comments below the photo details on the show page. We can “View Source” on the target and get some static HTML to begin working with: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; ... &lt;h2&gt;Comments&lt;/h2&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Commenter&lt;/th&gt; &lt;th&gt;Comment&lt;/th&gt; &lt;th&gt;Posted&lt;/th&gt; &lt;/tr&gt; &lt;% @list_of_comments do |a_comment| %&gt; &lt;tr&gt; &lt;td&gt;Some commenter name&lt;/td&gt; &lt;td&gt;The comment&lt;/td&gt; &lt;td&gt;Created at&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“8-24”} Now we could go back into our action and define something in the show action to get this @list_of_comments variable that we want for each photo. But, wait! Association accessor methods! Have another look in app/models/photo.rb… If you look then you will find the method .comments. Great, so let’s use that on the @the_photo record that we already have on this page, and fill in the comment attributes (column values) in the loop as well: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; ... &lt;% @the_photo.comments.each do |a_comment| %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= a_comment.commenter.username %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_comment.body %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= a_comment.created_at %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/table&gt; {: mark_lines=“5 7-9”} Note that we are using yet another association accessor method .commenter (you can find that in app/models/comment.rb) on our a_comment variable to get the username (because this method returns a user). Let’s /git commit all of this before we move on to updating and deleting records with forms. 27.11.1 Text Companion: Photo Comments with Association Accessors "],["video-segment-delete-photo-link.html", "27.12 Video Segment: Delete Photo Link", " 27.12 Video Segment: Delete Photo Link Notes: time stamp 01:10:54 to 01:20:07 moving to the D in CRUD get “Delete this photo” link on photo details page by RCAVing \"/delete_photo/&lt;%= @the_photo.id %&gt;\" .destroy in the action to delete photo On the photo details page (maybe /photos/777), let’s think about that delete link. This is just static right now: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; &lt;dl&gt; ... &lt;dt&gt;Delete photo&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;&quot;&gt;Delete this photo&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“9”} When I click on the “Delete this photo” link, it needs to take me to a URL (empty href=\"\" right now) that knows the photo ID I’m interested in deleting, and then the action for that URL will look up the photo with that ID and call .destroy. After that, we need to send the user somewhere, and it can’t be back to the photo details page because that photo will be gone. If we look at the target and “View Source”, we will find the structure of this delete link is: href=\"/delete_photo/photo_ID_number\", where photo_ID_number is the photo ID of the photo page we are currently on. This segment of the path will need to be dynamic, like: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; &lt;dl&gt; ... &lt;dt&gt;Delete photo&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;/delete_photo/&lt;%= @the_photo.id %&gt;&quot;&gt;Delete this photo&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“9”} Now this link will not work yet when we click it in our app. “No route matches”, because we haven’t defined the route! Let’s do that: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/photos/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/delete_photo/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;delete&quot; })) end {: mark_lines=“10”} And let’s also define this action that will destroy the record and redirect the user to the /photos page (as the target does when a photo is deleted): # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def delete url_id = params.fetch(&quot;path_id&quot;) the_photo = Photo.where({ :id =&gt; url_id }).first the_photo.destroy redirect_to(&quot;/photos&quot;) end end {: mark_lines=“5-10”} BENP: in the above code, in the video you use baii as the action name and you also originally render a baii.html.erb template. Could this just be skipped as I have it? We have already seen redirect_to, it’s nothing new. We also do the render then redirect_to dance in the Photo Create Form section below, and here I left this in because it is done more concisely. And this is it! .destroy issues the SQL to the database and deletes the record from the table. Try going to a photo details page and clicking on the “Delete this photo” link now. We have just set the action to redirect to the /photos page, but we could have also had this action render another page with some information, like a page that informs the user that the action was successful. Let’s make a /git commit! 27.12.1 Text Companion: Delete Photo Link "],["video-segment-create-photo-form.html", "27.13 Video Segment: Create Photo Form", " 27.13 Video Segment: Create Photo Form Notes: time stamp 01:20:07 to 01:36:27 moving to the C in CRUD build up form in app/views/photo_templates/index.html.erb RCAV action=\"/insert_photo\" with action create fetch params from form, .save to database We’re done with reading and deleting, so now let’s do the trickier ones. Create and update. For create, in the target at /photos, there is a form above the table with all the photos. As an example we can choose a URL, maybe one of the images on the Chicago Booth homepage, like this one. You can right click on any image of your choosing on the page and click on “Copy image address” to get the URL. BENP: might want to change the image in case this URL changes Now we can take our URL back to the target, paste it into the first input on the form, and put some caption in the second input (maybe “UChicago Campus”). For the last input on the form, “Owner ID”, if you put in a user ID that doesn’t exist, like “1”, then it’s not going to add the photo to the table. Why? Because we have a validation on this Photo model: # app/models/photo.rb ... class Photo &lt; ApplicationRecord validates(:poster, { :presence =&gt; true }) def poster my_owner_id = self.owner_id matching_users = User.where({ :id =&gt; my_owner_id }) the_user = matching_users.at(0) return the_user end ... end The association accessor method poster returns a user based on an ID. Above this method, there is a validation associated with it. This is saying that the return of poster (the_user) must be present ({ :presence =&gt; true }), it cannot be nil. BENP: another validation aside, I see it is important now to keep the previous aside So if we try and use a valid “Owner ID” in our add photo form (you can check for a valid user ID in the /users table), then the photo will be added to the top of our /photos index page. Actually, the form takes us directly to the show page for that photo we just added. We need to make this form in our app now. This is standard stuff that we’ve done before for form generation, but the trick now will just be getting the input to save to our database. Try to build the form out for yourself! I’ll wait… BENP: could lnk to active record and forms chapters Let’s work on this together. We need to add a form to our /photos index view template: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; &lt;h1&gt;List of photos&lt;/h1&gt; &lt;hr&gt; &lt;form&gt; &lt;input&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;input&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; &lt;hr&gt; ... {: mark_lines=“5-14”} To give ourselves a little visual space, we added &lt;hr&gt; tags, which stands for “horizontal rule”, and just adds some horizontal lines to bracket the form. The rest is just the skeleton of the &lt;form&gt; we want with two &lt;input&gt;s (no closing tag required), one &lt;textarea&gt;, and a &lt;button&gt;. Let’s add some labels (and some code spacing for readability) to the inputs: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; ... &lt;form&gt; &lt;label&gt;Image&lt;/label&gt; &lt;input&gt; &lt;label&gt;Caption&lt;/label&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;label&gt;Owner ID&lt;/label&gt; &lt;input&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; ... {: mark_lines=“5 8 11”} We also need to make sure that we tie each label to an input to make the form valid usign for= and id=: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; ... &lt;form&gt; &lt;label for=&quot;image_box&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;image_box&quot;&gt; &lt;label for=&quot;caption_box&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;caption_box&quot;&gt;&lt;/textarea&gt; &lt;label for=&quot;owner_id_box&quot;&gt;Owner ID&lt;/label&gt; &lt;input id=&quot;owner_id_box&quot;&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; ... {: mark_lines=“5-6 8-9 11-12”} If we refresh /photos, we will see that cosmetically the from is already looking good. But it won’t do anything yet. When I click on “Add photo”, I want the form to have an action that points to a new URL, and that URL should call an action that actually takes the input to the form and adds a record to the database. So we need to add an action=\"\" with a URL, and we also need to add a name for each form input, which will go into our query string: &lt;!--- app/views/photo_templates/index.html.erb ---&gt; ... &lt;form action=&quot;/insert_photo&quot;&gt; &lt;label for=&quot;image_box&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;image_box&quot; name=&quot;query_image&quot;&gt; &lt;label for=&quot;caption_box&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;caption_box&quot; name=&quot;query_caption&quot; &gt;&lt;/textarea&gt; &lt;label for=&quot;owner_id_box&quot;&gt;Owner ID&lt;/label&gt; &lt;input id=&quot;owner_id_box&quot; name=&quot;query_owner_id&quot;&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; ... {: mark_lines=“4 6 9 12”} Now if you put some input into the form and click “Add button”, then you will be routed to a new URL that begins with /insert_photo?, and has all of your named inputs (query_) and values following the ?. So everything we typed is saved in the query string, and that means it was sent to the params hash, which we can access in our back-end action. We could also add additional attributes to the &lt;input&gt; and &lt;textarea&gt;, like placeholder=\"\" or type=\"\", but that’s up to you. For now the form is functional. Our new URL is getting the “no route matches” error, because we still need to define the route and make the action: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/photos/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/delete_photo/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;delete&quot; })) get(&quot;/insert_photo&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;create&quot; })) end {: mark_lines=“11”} And let’s also define this action that will create the record and redirect the user to the new show page of that photo. At first I’m just going to make a view template to get the action working and rendering some new HTML: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def create render({ :template =&gt; &quot;photo_templates/create.html.erb&quot; }) end end {: mark_lines=“5-8”} Once we get that page to say “hi” after we click on the “Add photo” button on our new, filled-out form, then we can return to the action and get it to do what we actually want. First we need to go into params and pull out the input from our query string: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def create input_image = params.fetch(&quot;query_image&quot;) input_caption = params.fetch(&quot;query_caption&quot;) input_owner_id = params.fetch(&quot;query_owner_id&quot;) render({ :template =&gt; &quot;photo_templates/create.html.erb&quot; }) end end {: mark_lines=“6-8”} So how can we save this information into our database? We just need to create a new Photo instance, fill in the attributes, and .save it to issue the SQL and add the record to our table: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def create input_image = params.fetch(&quot;query_image&quot;) input_caption = params.fetch(&quot;query_caption&quot;) input_owner_id = params.fetch(&quot;query_owner_id&quot;) new_photo = Photo.new new_photo.image = input_image new_photo.caption = input_caption new_photo.owner_id = input_owner_id new_photo.save render({ :template =&gt; &quot;photo_templates/create.html.erb&quot; }) end end {: mark_lines=“10-14”} We can already try and re-submit the form on /photos, and we should be brought again to the create.html.erb template that is just saying “hi”. It’s hard to tell that anything was added to our database, but if we go to our GitPod terminal where bin/server is running and look in the log, then we will see the SQL telling us that our photo was saved. And the new photo was even assigned a unique photo ID that we can use to go directly to (redirect_to) the show page of our new photo: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def create input_image = params.fetch(&quot;query_image&quot;) input_caption = params.fetch(&quot;query_caption&quot;) input_owner_id = params.fetch(&quot;query_owner_id&quot;) new_photo = Photo.new new_photo.image = input_image new_photo.caption = input_caption new_photo.owner_id = input_owner_id new_photo.save # render({ :template =&gt; &quot;photo_templates/create.html.erb&quot; }) redirect_to(&quot;/photos/&quot; + new_photo.id.to_s) end end {: mark_lines=“16-17”} Try and add some new URLs to the form on your own and watch it work! Time to /git commit. 27.13.1 Text Companion: Create Photo Form "],["video-segment-update-photo-form.html", "27.14 Video Segment: Update Photo Form", " 27.14 Video Segment: Update Photo Form Notes: time stamp 01:36:27 to 01:50:56 moving to the U in CRUD build up form in app/views/photo_templates/show.html.erb RCAV action=\"/update_photo/&lt;%= @the_photo.id %&gt;\" with action update fetch params from path, .save to database One last thing to do! We did read, we did delete, and we now did create. So it’s time to add an update form to our photo page. Right now we should have: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Image&lt;/dt&gt; &lt;dd&gt;&lt;img src=&quot;&lt;%= @the_photo.image %&gt;&quot;&gt;&lt;/dd&gt; &lt;dt&gt;Caption&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.caption %&gt;&lt;/dd&gt; &lt;dt&gt;Owner&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.poster.username %&gt;&lt;/dd&gt; &lt;dt&gt;Posted&lt;/dt&gt; &lt;dd&gt;&lt;%= @the_photo.created_at %&gt;&lt;/dd&gt; &lt;dt&gt;Edit photo&lt;/dt&gt; &lt;dd&gt;Form goes here&lt;/dd&gt; &lt;dt&gt;Delete photo&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;/delete_photo/&lt;%= @the_photo.id %&gt;&quot;&gt;Delete this photo&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; ... So everything is working, but we need to zoom in on the &lt;dd&gt;Form goes here&lt;/dd&gt; tag and place a form for updating the photo right there. We can go to a photo details page in our target and save some time by just viewing the page source (right click, “View source”), then copy-pasting the relevant form into our own view template: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; ... &lt;dt&gt;Edit photo&lt;/dt&gt; &lt;dd&gt; &lt;form action=&quot;/update_photo/777&quot;&gt; &lt;label for=&quot;browser_image&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;browser_image&quot; type=&quot;text&quot; name=&quot;input_image&quot; placeholder=&quot;Enter a URL for the image...&quot; value=&quot;https://robohash.org/dolorehicincidunt.png?size=300x300&amp;amp;set=set1&quot;&gt; &lt;label for=&quot;browser_caption&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;browser_caption&quot; name=&quot;input_caption&quot; placeholder=&quot;Enter a caption for the photo...&quot;&gt;Once you’ve accepted your flaws, no one can use them against you.&lt;/textarea&gt; &lt;button&gt;Update photo&lt;/button&gt; &lt;/form&gt; &lt;/dd&gt; ... {: mark_lines=“5-15”} Now, back in our app, if we visit a photo details page and try to click the “Update photo” link, then we will get a “no route matches” error, because we haven’t defined the action=\"/update_photo/777\", or made it dynamic to change the photo ID in the second segment. Also, we see that there is pre-populated input to the form “Image” and “Caption” fields. These are data taken from our database for whatever image matches the current photo ID (777 in our example). The “Image” field is pre-populated with the value=\"\" attribute to &lt;input&gt;, whereas “Caption” is just pre-populated by placing data between the &lt;textarea&gt;&lt;/textarea&gt; tags. (A weird, archaic HTML inconsistency, since &lt;textarea&gt; doesn’t have a value=\"\" attribute available.) This pre-population also needs to be made dynamic, with information taken from the current photo page that we are on. Let’s do all of that using the embedded Ruby tags and instance variables that we have access to on this page! While we’re at it, we will also rename the copy-pasted name attributes after our previous convention using a leading query_ rather than input_: &lt;!--- app/views/photo_templates/show.html.erb ---&gt; ... &lt;dt&gt;Edit photo&lt;/dt&gt; &lt;dd&gt; &lt;form action=&quot;/update_photo/&lt;%= @the_photo.id %&gt;&quot;&gt; &lt;label for=&quot;browser_image&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;browser_image&quot; type=&quot;text&quot; name=&quot;query_image&quot; placeholder=&quot;Enter a URL for the image...&quot; value=&quot;&lt;%= @the_photo.image %&gt;&quot;&gt; &lt;label for=&quot;browser_caption&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;browser_caption&quot; name=&quot;query_caption&quot; placeholder=&quot;Enter a caption for the photo...&quot;&gt;&lt;%= @the_photo.caption %&gt;&lt;/textarea&gt; &lt;button&gt;Update photo&lt;/button&gt; &lt;/form&gt; &lt;/dd&gt; ... {: mark_lines=“6 8 11”} Refresh a photo details page in your app, and try to visit other photos as well. You will see the form content dynamically updating on each page. Okay, now we can try to fill out a form, maybe by just changing any given caption to “Caption Updated” in the “Caption” field of the form on one of the photo details pages. And when you click “Update photo”, you still get “no route matches”, but at least you get inputs in the ? query string in the new URL. Let’s RCAV it: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users/:path_username&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/photos&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/photos/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/delete_photo/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;delete&quot; })) get(&quot;/insert_photo&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;create&quot; })) get(&quot;/update_photo/:path_id&quot;, { :controller =&gt; &quot;photos&quot;, :action =&gt; &quot;update&quot; })) end {: mark_lines=“12”} # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def update render({ :template =&gt; &quot;photo_templates/update.html.erb&quot; }) end end {: mark_lines=“5-8”} And once we get the form to say “hi” (put that in app/views/photo_templates/update.html.erb), we can get the action to do what we want. First we get the parameters of interest out of the hash, then we find the matching photo with the given ID (part of our dynamic path!), then we update the photo in our database using the form input that we pull from the query string. Additionally, rather than rendering, we will redirect the form back to the current photo page so we can see the update: BENP: at 01:46:00, there is a kinda confusing aside about check boxes and false argument to fetch.. leaving this out # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def update the_id = params.fetch(&quot;path_id&quot;) the_photo = Photo.where({ :id =&gt; the_id }).first image = params.fetch(&quot;query_image&quot;) caption = params.fetch(&quot;query_caption&quot;) the_photo.caption = caption the_photo.image = image the_photo.save # render({ :template =&gt; &quot;photo_templates/update.html.erb&quot; }) redirect_to(&quot;/photos/&quot; + the_photo.id.to_s) end end {: mark_lines=“6-16”} Try and update some captions on your photos. If you see everything working as you expect, then you can do a rails grade to check your work, and a /git commit. You can now CRUD! The remaining tasks you see on the rails grade results page are up to you to complete. 27.14.1 Text Companion: Update Photo Form "],["finish-and-submit-photogram-gui.html", "27.15 Finish and Submit Photogram GUI", " 27.15 Finish and Submit Photogram GUI Notes: copied from README at https://github.com/appdev-projects/photogram-gui#readme 27.15.1 Tasks The required tasks are: /users should display all the users a link to get to details for each user a form to add a new user /users/[USERNAME] should display the username of the user the photos posted by the user /photos should have a form to add a new photo /photos/[ID] should display the details of a photo displays the comments that have been made on the photo have a form to add a comment to the photo 27.15.2 Workflow As often as you like, reset your database with sample data: rails sample_data Start the web server: bin/server Always Be Committing at /git Check out your database visually at /rails/db Run rails grade as often as you like to see how you are doing, but test whatever you’re working on manually first to make sure it matches the target’s behavior. Don’t debug using rails grade; that is a terribly slow feedback loop. 27.15.3 Things to keep in mind I added some validations, rules to try and help prevent bogus data from entering your tables, to your models. If your record is mysteriously not saving, then a validation is failing (or you just forgot to call .save, which I do all the time). Don’t be alarmed by the number of automated tests. Most of them are there as hints to help you structure your forms correctly. It’s okay to View Source on the target to get hints on what HTML we used. When you make forms, don’t forget to add a &lt;label&gt; for every form control (&lt;input&gt;, &lt;textarea&gt;, etc). The &lt;label&gt; should have a for=\"\" attribute that matches the id=\"\" attribute of the input. For example, &lt;label for=&quot;zebra&quot;&gt;Fan&lt;/label&gt; &lt;input id=&quot;zebra&quot; type=&quot;text&quot; name=&quot;qs_fan_id&quot;&gt; "],["must-see-movies-validations.html", "28 Must See Movies Validations", " 28 Must See Movies Validations Un-graded assignment, but there are tests built in Project: https://github.com/appdev-projects/msm-validations Useful chapters: data-integrity-with-validations.md, not yet copied here "],["very-best-debug.html", "29 Very Best Debug", " 29 Very Best Debug Notes: Day 7 video transcription is in very-best-debug-video.md Project (graded): https://github.com/appdev-projects/very-best-debug Target: https://very-best-debug.matchthetarget.com/ BENP: Right now there is a starting from scratch tutorial including draft generators in Day 7 recording from 00:30:00 to 00:50:20. I am not transcribing this yet but can come back for it! See my note in Video Segment: Homepage Debugging in this lesson. This probably needs a dedicated video and to be zipped with the starting from scratch and draft:generator chapters. "],["video-segment-homepage-debugging.html", "29.1 Video Segment: Homepage Debugging", " 29.1 Video Segment: Homepage Debugging -Notes: time stamp 00:02:03 to 00:04:03 RTEM to slowly debug / better_errors page console aside (da=“Explain”) When we open our app in a GitPod browser with bin/server, right away on the / homepage, we are greeted with an error: The action &#39;home&#39; could not be found for UsersController This project is bringing together everything you learned so far in the service of debugging: HTML, Ruby, RCAV, params, instance variables, view templates, .each in the view templates, ActiveRecord for databases, etc. So for the first error I will start by looking at the route in config/routes.rb and see if I can trace the source of the problem: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;home&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;all_users&quot; }) get(&quot;/users/:username&quot;, { :controller =&gt; &quot;user&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/insert_user_record&quot;, { :controller =&gt; &quot;venues&quot;, :action =&gt; &quot;create&quot; }) get(&quot;/update_users/:user_id&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;update&quot; }) ... end {: mark_lines=“5”} We see the route \"/\" that we are interested in fixing, and the error message was telling us that the \"home\" action could not be found in our \"users\" controller. Let’s look at this controller: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def index ... end def show ... end def create ... end def update ... end end And we see there is no home action defined in our controller. Hence the error message. Let’s look at the target homepage at the URL path /. What is the behavior? It looks like this is just a list of users. And what’s the conventional name for an action that just lists things in a Rails app? index! Back to our controller: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def index matching_users = User.all @users = matching_users.order(:created_at) render({ :template =&gt; &quot;users_templates/all_users.html.erb&quot;}) end ... end {: mark_lines=“5-10”} The first action is the one we want. It returns of an array-like object of all users from the database. Easy fix here is to just go back to our routes and change the name of the action to match our controller: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;all_users&quot; }) get(&quot;/users/:username&quot;, { :controller =&gt; &quot;user&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/insert_user_record&quot;, { :controller =&gt; &quot;venues&quot;, :action =&gt; &quot;create&quot; }) get(&quot;/update_users/:user_id&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;update&quot; }) ... end {: mark_lines=“5”} Now back in your app browser, refresh /. The missing action error goes away, but we get a new one: Missing template users_templates/all_users.html.erb BENP: better_errors Page and Starting a New Project, 00:04:03 to 00:06:55. This error page could be introduced elsewhere, earlier in the class I want to point out the error page in our Rails app. We see the error message, but we also see that the specific line of code in our codebase that is causing the error is also shown. I want to emphasize, in this better_errors page, which is a third-party gem that does not come by default with Rails, there is a super useful REPL (Rails console) below the highlighted code error. If you ever need to, you can look at any instance variables or params right from this terminal. The REPL is frozen in time right where that error occurred. So it’s a very useful playground for you find a solution and debug right on this page before you go and change things in the codebase. We have added a lot of third-party gems like this to our Rails app to improve the development experience. When you want to start projects in the future… BENP: this part of the video is just a live walk through of starting-a-rails-project-from-scratch.md (https://chapters.firstdraft.com/chapters/851). It was prompted by a student question. Could just copy-paste from there.. or put this whole section elsewhere. NOTE, right now there is a starting from scratch tutorial including draft generators in Day 7 recording from 00:30:00 to 00:50:20. I am not transcribing this yet but can come back for it! Back to the current error message on /: Missing template users_templates/all_users.html.erb Let’s look in our folder on GitPod for this file. We see right away when we take a look for it that the folder is called user_templates/, whereas we have in our action users_templates/, with an extra s after user. We could change the foldername, or we could change the path for the rendered template in our action. So far our convention has been to use the singular name of the record, so we will change the index action to render({ :template =&gt; \"user_templates/all_users.html.erb\"}). Now when we refresh / in our app’s browser, the page loads without an error. If for some reason you still have an error on the page, you may need to close down the server terminal, and restart it. This is just a bug in GitPod BENP: is this still a bug?. And remember, the database in our new app is empty, so that’s why you may not see any records in your “List of users”. We need to run rails sample_data in a terminal on GitPod to get some toy data. BENP: 00:08:30 to 00:10:55 had to deal with project bug, showing that faker is missing from the gem file. Maybe too advanced to show to class? At this point you go into all this stuff about the GEM file and bundle install. The rest of the debugging is up to you, here are some things to keep in mind BENP: just copy pasted these from README. Probably can be integrated in text: READ THE ERROR MESSAGE When you understand the error message, work to figure out a solution to fix the error so the Route/Controller/Action/View functions like the target. Remember that the error will guide you to the bug and our skills as developers are determined by how many bugs we understand how to fix Refer to the routing chapter if you are stuck on the RCAV Once you have /users working correctly, check the routes file and get each working the same as the target BENP: from here on there is the Very Best Debugging solutions, done interactively with class input 29.1.1 Text Companion: Homepage Debugging "],["video-segment-typos-and-nilclass-bug.html", "29.2 Video Segment: Typos and NilClass Bug", " 29.2 Video Segment: Typos and NilClass Bug -Notes: time stamp 00:11:35 to 00:17:47 RTEM to slowly debug /venues/[ID of venue] tricky bug: undefined method 'address' for nil:NilClass ActiveRecord::Relation single instance .at(0) In our app, let’s try to manually navigate to /venues/1. We are trying to get to a venue details page, like in our target. We get a “no route matches” error. Based on the developer conventions from the Rails community, we were expecting the list of things we are interested in (the index action) to be on a URL with the plural name of the thing of interest, in this case /venues. Also, for the individual venue, it is typical to put the details page at /venues/[ID of venue]. In this case, we tried to get to the details page of the venue from our venues table with the id column value of “1”. We could have named these routes anything we want, like /venue_details. But we don’t because it is usually good to follow conventions. Back to the error, let’s check our route: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/users&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;all_users&quot; }) get(&quot;/users/:username&quot;, { :controller =&gt; &quot;user&quot;, :action =&gt; &quot;show&quot; }) get(&quot;/insert_user_record&quot;, { :controller =&gt; &quot;venues&quot;, :action =&gt; &quot;create&quot; }) get(&quot;/update_users/:user_id&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;update&quot; }) get(&quot;/venues&quot;, { :controller =&gt; &quot;venues&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/insert_venue_record&quot;, { :controller =&gt; &quot;venues&quot;, :action =&gt; &quot;create&quot; }) get(&quot;/venue/:an_id&quot;, { :controller =&gt; &quot;venue&quot;, :action =&gt; &quot;show&quot; }) post(&quot;/update_venue/:the_id&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;update&quot; }) get(&quot;/delete_venue/:id_to_delete&quot;, { :controller =&gt; &quot;venue&quot;, :action =&gt; &quot;destroy&quot; }) get(&quot;/insert_comment_record&quot;, { :controller =&gt; &quot;comments&quot;, :action =&gt; &quot;create&quot; }) end {: mark_lines=“13”} Right away, we can spot that the path and controller \"venue\" should say \"venues\" to match the controller file app/controllers/venues_controller.rb, which is, again by convention, the plural snake_case name of the table. Change these both to \"venues\", and refresh /venues/1. A new error: param is missing or the value is empty: venue_id In the error page, we see the highlighted code is in the app/controllers/venue_controllers.rb file in the show action in the first line: # app/controllers/venue_controllers.rb class VenuesController &lt; ApplicationController ... def show venue_id = params.fetch(&quot;venue_id&quot;) matching_venues = Venue.where({ :id =&gt; venue_id }) the_venue = matching_venues render({ :template =&gt; &quot;venue_templates/details.html.erb&quot; }) end ... end {: mark_lines=“6”} On the error page you can also note that I have the “Request Info” section of the page, where it actually shows me my “Request parameters” hash. We see that in our action we are trying to look up the venue_id from params, but in our params hash (which we can also have a look at in the error page REPL), we have this key as an_id. This is the name we gave it up in our config/routes.rb file, so we can change the name there or in the action: # app/controllers/venue_controllers.rb class VenuesController &lt; ApplicationController ... def show venue_id = params.fetch(&quot;an_id&quot;) matching_venues = Venue.where({ :id =&gt; venue_id }) the_venue = matching_venues render({ :template =&gt; &quot;venue_templates/details.html.erb&quot; }) end ... end {: mark_lines=“6”} And once we have the correct parameter, we can refresh /venues/1, and get another error: undefined method `address&#39; for nil:NilClass It is common to stop after you get to undefined method and go searching for this missing method. But you need to Read The whole Error Message. We can see that the highlighted code where the error occurred is in views/venue_templates/details.html.erb where we try and do @the_venue.address. The problem is that we are calling .address on a nil object. What is the nil object? @the_venue! In our error page REPL, if we type &gt;&gt; @the_venue, indeed we will see the return =&gt; nil. We expected an instance of Venue from our venues table here. Let’s start by looking at our show action above. We are taking an ID from the path (here “1”): venue_id = params.fetch(\"an_id\"). Then we are looking up the matching venues from the table: matching_venues = Venue.where({ :id =&gt; venue_id }). We can see how this looks by going back to our error page REPL and entering &gt;&gt; Venue.where({ :id =&gt; 1 }). And we will see that this returns an ActiveRecord::Relation with one venue in it. Now we want to get just the first venue, because we only want one result and we don’t want the full array-like ActiveRecord::Relation. Right away we see the two errors: we need to call .at(0) or .first, and we also need to make the action variable an instance variable so we can access it in our view template: # app/controllers/venue_controllers.rb class VenuesController &lt; ApplicationController ... def show venue_id = params.fetch(&quot;an_id&quot;) matching_venues = Venue.where({ :id =&gt; venue_id }) @the_venue = matching_venues.at(0) render({ :template =&gt; &quot;venue_templates/details.html.erb&quot; }) end ... end {: mark_lines=“8”} This was tricky, because with instance variables in Ruby, there is no error if the instance variable doesn’t exist. It just returns a nil object. Then when we try and call our defined methods on that object, we begin to get error messages. But the error is not with the methods, but rather with the object they are being called on. If we refresh /venues/1 and get another error message: undefined method `address&#39; for #&lt;Venue:ActiveRecord_Relation:...&gt; again, don’t stop reading after undefined method 'address'. We can now see that the venue object is being returned, so that’s good. But the .address is undefined. But that’s because we are not returning a single instance of Venue, we are getting an ActiveRecord::Relation **BENP: okay, I have been writing :: everywhere, but in the error message it is _, which is correct?**. That means we are trying to call .address on an array-like object, and we forgot the .at(0) in our show action above. 29.2.1 Text Companion: Typos and NilClass Bug "],["video-segment-association-accessor-self.id-bug.html", "29.3 Video Segment: Association Accessor self.id Bug", " 29.3 Video Segment: Association Accessor self.id Bug -Notes: time stamp 00:17:47 to 00:28:35 RTEM to continue debugging /venues/[ID of venue] tricky bug: self.id in Comment#commenter, rather than self.author_id Now, assuming the show bugs have been dealt with, if we refresh /venues/1, then we get the error: undefined method `username&#39; for nil:NilClass And we see the highlighted code in the view template is coming where we try to call comment.commenter.username. From our experience, we know that the comment.commenter is somehow nil. Above this, we see that we are calling .comments on our @the_venue object in order to get a list of comments for looping over and displaying: @the_venue.comments.each do |comment|. Because the .each call didn’t throw an error, we can assume that the .comments method is returning an array-like object ActiveRecord::Relation of the comments associated with that venue ID. But inside of this loop, the comment, or the .commenter method called on it, is nil. Let’s check in our error page REPL. We can start with just &gt;&gt; @the_venue, which should return our instance of Venue. Then we can try &gt;&gt; @the_venue.comments, which should return an array-like object full of comments that match the venue. Good. But where is this .comments method from? It is in the model! Any method that we call on a class from our database is defined in the class file. Let’s go look at that First, in order to get from a Venue to a Comment, we can look at the Comment model to remind us of the names of the columns: # app/models/comment.rb # == Schema Information # # Table name: comments # # id :integer not null, primary key # body :string # created_at :datetime not null # updated_at :datetime not null # author_id :integer # venue_id :integer # ... {: mark_lines=“12”} In the # == Schema Information we see there is a foreign key column called venue_id. So we want to find all of the comments where ID in this column matches my current venue of interest. In the Venue model, we find: # app/models/venue.rb # == Schema Information # # Table name: venues # # id :integer not null, primary key # address :string # name :string # neighborhood :string # created_at :datetime not null # updated_at :datetime not null # class Venue &lt; ApplicationRecord def comments my_id = self.id matching_comments = Comment.where({ :venue_id =&gt; my_id }) return matching_comments end end {: mark_lines=“17-21”} This comments method in an association accessor method. It first says, get the current venue ID (our @the_venue instance variable) using the self.id call. It then searches the venue_id column of the Comment model (which accesses the comments table) for my current ID, and then it returns all of these matching rows. So it looks like in our view template the comments method should be doing the right thing. And we saw this was the case in our error page REPL when we typed &gt;&gt; @the_venue.comments. It returned an array-like object full of comments that match the venue. That brings us to the block variable comment in our .each loop. At the error page REPL, type &gt;&gt; comment. Indeed a single Comment object is return, which is a row from the table comments in our database. Now at the REPL try: &gt;&gt; comment.commenter. It gives us =&gt; nil! How could we replace our code and manually traverse from the comment to the username associated with that comment? If we look at our Comment instance, we can see there is a foreign key column called author_id with a value of “96”. This is the key that we can use in User to look up which user authored a given comment. To write this out: User.where({ :id =&gt; 96 }). Then we can .at(0) and .username on that to get the name we want. At the REPL: &gt;&gt; User.where({ :id =&gt; 96 }).at(0).username should return =&gt; \"jolie\" BENP: are the returns consistent with faker? will it always be “jolie”. So this does work. We can traverse manually to get the username, and comment.commenter is not failing and returning nil because there is no username. This is something you need to start to consider. There may be entries that do have nil values in a given column. Some bugs can be caused by invalid data and not problems in our code. However, here we saw the bug was not caused by invalid data. That means we need to go look in the Comment model at the .commenter method: # app/models/comment.rb # == Schema Information # # Table name: comments # # id :integer not null, primary key # body :string # created_at :datetime not null # updated_at :datetime not null # author_id :integer # venue_id :integer # class Comment &lt; ApplicationRecord def commenter my_id = self.id matching_users = User.where({ :id =&gt; my_id }) the_user = matching_users.at(0) return the_user end end {: mark_lines=“16-21”} BENP: on https://github.com/appdev-projects/very-best-debug/blob/master/app/models/comment.rb the line already is corrected and says my_id = self.author_id. I changed it above to match the video We are taking the self.id! But what we want is the author_id foreign key column not the primary key of the given comment. So change the line to my_id = self.author_id, and refresh /venues/1 once more in our browser. It works! 29.3.1 Text Companion: Association Accessor self.id Bug "],["finish-and-submit-very-best-debug.html", "29.4 Finish and Submit Very Best Debug", " 29.4 Finish and Submit Very Best Debug -Notes: below copied from README: https://github.com/appdev-projects/very-best-debug#readme 29.4.1 Standard Workflow The goal of this assignment is to make the code work by correcting all of the bugs that are contained within Checkout the target to see how your code should function Run rails sample_data to populate your database Start with visiting the route /users You will see an error message, READ THE ERROR MESSAGE When you understand the error message, work to figure out a solution to fix the error so the Route/Controller/Action/View functions like the target. Remember that the error will guide you to the bug and our skills as developers are determined by how many bugs we understand how to fix Refer to the routing chapter if you are stuck on the RCAV Once you have /users working correctly, check the routes file and get each working the same as the target Run rails grade once all the routes are working to see what else still does not match the target As you work, remember to navigate to /git and commit often as you work. Be sure you test the behavior of your app manually to make sure it matches the target’s behavior. Don’t use rails grade to debug. "],["draft-resource-generator.html", "30 draft resource generator", " 30 draft resource generator Notes: just a reading in draft-generators.md this should have dedicated content, see notes in Very Best Debug "],["refactoring-msm-again.html", "31 Refactoring MSM Again", " 31 Refactoring MSM Again Notes: Day 7 video transcription is in refactoring-MSM-queries-again.md Project (graded): https://github.com/appdev-projects/refactoring-msm-queries-2 Target: https://github.com/appdev-projects/refactoring-msm-queries-1 Helper application demo’d in video: https://association-accessors.firstdraft.com/ "],["video-segment-belongs_to.html", "31.1 Video Segment: belongs_to", " 31.1 Video Segment: belongs_to Notes: time stamp 00:51:43 to 01:01:06 refactor 1-N Character#movie, going from the “many” to the “one” why belongs_to is better than previous method definitions aside into .joins at the rails console If we open the model files in our new project, then we will see that the association accessor methods, like Movie#director and Director#filmography, have already been defined in the models. Let’s take a look at two side-by-side: Character#movie and Movie#director: # app/models/character.rb # == Schema Information # # Table name: characters # # id :integer not null, primary key # name :string # created_at :datetime not null # updated_at :datetime not null # actor_id :integer # movie_id :integer # class Character &lt; ApplicationRecord def movie key = self.movie_id matching_set = Movie.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end end # app/models/movie.rb # == Schema Information # # Table name: movies # # id :integer not null, primary key # description :text # duration :integer # image :string # title :string # year :integer # created_at :datetime not null # updated_at :datetime not null # director_id :integer # class Movie &lt; ApplicationRecord def director key = self.director_id matching_set = Director.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end end Both of these methods are from a 1-N association and represent going from the “many” back over to the “one” that it belongs to. If I am a Movie, I contain a foreign key, the director_id column, and I want to take that value, go to the ID column of Director, find the matching record, and return it. The same goes for Character#movie. All of our association accessor methods follow the same pattern! What if we want to define the Character#actor 1-N association? # app/models/character.rb ... class Character &lt; ApplicationRecord def movie key = self.movie_id matching_set = Movie.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end def actor key = self.actor_id matching_set = Actor.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end end {: mark_lines=“15-23”} Compare the movie and actor method. They are almost identical with just a difference in a few names. Defining association accessor methods is incredibely important for a good, maintainable code base. And, because of how formulaic this is, Rails makes it easy to automate! The “Pit of Success” of Rails! BENP: link or define pit of success There are three things that changed between movie and actor: the name of the method, the name of the foreign key column, and the name of the class that we search in. There’s a meta method called belongs_to(), which can be used outside of the method definitions directly in the model. This method will define our association accessor for us if we give it just three arguments: # app/models/character.rb ... class Character &lt; ApplicationRecord belongs_to(:name_that_we_want, { :class_name =&gt; &quot;&quot;, :foreign_key =&gt; &quot;&quot; }) def movie key = self.movie_id matching_set = Movie.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end ... end {: mark_lines=“5”} The first argument is the name of the method we want, then a hash with two key/value pairs containing the name of the class and the foreign key. So if we want a method .movie that we can call on Character, we can just write (and comment out or delete our old code): # app/models/character.rb ... class Character &lt; ApplicationRecord belongs_to(:movie, { :class_name =&gt; &quot;Movie&quot;, :foreign_key =&gt; &quot;movie_id&quot; }) # def movie # key = self.movie_id # matching_set = Movie.where({ :id =&gt; key }) # the_one = matching_set.at(0) # return the_one # end ... end {: mark_lines=“5”} Try this out. Comment or delete the def movie section of the model once you have the belongs_to() filled out. Visit in your app browser an actor details page (did you run rails sample_data yet?). For instance /actors/343. Now if we scroll down to the “Filmography” table, there is a column showing the character name in each movie for the given actor. So everything is still working even though we deleted our previous association accessor method! BENP: Why belongs_to is Better, starting below, from: 01:01:06 to 01:09:14 The def movie that we wrote out line-by-line and the new belongs_to version are producing the same thing. But belongs_to is somewhat shorter, and it reads better (is easier to understand at a glance). Moreover, we can look at an example in our Rails console for why this technique is so good. Open a rails console. What if we asked for all of the characters from movies that are newer than 1994? Until today we couldn’t do that! We can use a new method called .joins, which you give the name of an association that you declared with belongs_to (it must be declared this way for .joins to work). Then you can use .where and the association accessor with another hash that searches over a specific range specified by another column: pry(main)&gt; Character.joins(:movie).where(&quot;movies.year &gt; 1994&quot;) Note here that when using joins, where takes its argument as a string rather than a hash. That will return an ActiveRecord::Relation with all of the movies of interest. It is very common to query one table with the columns of another. And if we look at the SQL issued by the relatively simple Ruby command above, then we see it is getting pretty tricky to write, and ActiveRecord just does that for us. Yet another reason that belongs_to is great, is that we can write: belongs_to(:movie, { :class_name =&gt; &quot;Movie&quot;, :foreign_key =&gt; &quot;movie_id&quot; }) as simply belongs_to(:movie) We can delete most of the code because the method belongs_to will follow a well defined pattern of naming! So as long as the function, table, and foreign key columns share the same name (with only capitalization difference), then we can write a very short, explicit, and clear association accessor method. If you prefer to write out the entire thing, you are welcome to, but this is just another shortcut in your toolbox. 31.1.1 Text Companion: belongs_to "],["video-segment-has_many.html", "31.2 Video Segment: has_many", " 31.2 Video Segment: has_many Notes: time stamp 01:09:14 to 01:13:08 refactor 1-N Movie#characters, going from the “one” to the “many” aside into method syntax for Director#filmography 31.2.1 Text Companion: has_many As opposed to belongs_to(:movie) in Character (Character#movie), we also want to have a Movie#characters method, which is the other side of the relationship, the many to the one. We could define this ourselves like so: # app/models/movie.rb ... class Movie &lt; ApplicationRecord def characters key = self.id the_many = Character.where( {:movie_id =&gt; key }) return the_many end def director key = self.director_id matching_set = Director.where({ :id =&gt; key }) the_one = matching_set.at(0) return the_one end end {: mark_lines=“5-9”} This is a different method compared to the one to the many. Of course, the director method could already be replaced with just belongs_to(:director)! But how can we replace def characters? belongs_to(:characters) won’t work, that will write the wrong method in this case, because our new method does not follow the expected pattern for a one to a many. We need to use the method has_many, which has a similar form: # app/models/movie.rb ... class Movie &lt; ApplicationRecord belongs_to(:director) has_many(:characters, { :class_name =&gt; &quot;Character&quot;, :foreign_key =&gt; &quot;character_id&quot; }) # def characters # key = self.id # the_many = Character.where( {:movie_id =&gt; key }) # return the_many # end ... end {: mark_lines=“6-7”} All we did was provide the method with the three pieces of information that we expect to vary: the name of the method, name of the class, and name of the foreign key. And then has_many writes an association accessor method for us of the form that we put together in def characters. Similar to belongs_to, if the three arguments match, we can write: has_many(:characters, { :class_name =&gt; &quot;Character&quot;, :foreign_key =&gt; &quot;character_id&quot; }) as simply has_many(:characters) This shortcut only works if the names match! For instance, in our Director class, we have an association accessor method called filmography. We could have called this movies, which would have allowed us to write has_many(:movies), but if we wrote has_many(:filmography), then Rails would look for a class called Filmography, and a foreign key column called filmography_id, neither of which exist! So in the case where we selected our own, non-conventional names, then we need to be explicit and write: has_many(:filmography, { :class_name =&gt; &quot;Movie&quot; }) We can still omit the foreign key, because now the method will know to call the foreign key movie_id based on the :class_name. "],["video-segment-other-relationships-and-wizard.html", "31.3 Video Segment: Other Relationships and Wizard", " 31.3 Video Segment: Other Relationships and Wizard Notes: 01:13:08 to 01:26:00 classroom work using https://association-accessors.firstdraft.com/ Define all 6 1-Ns using belongs_to and has_many: Actor#characters, Character#actor, Movie#characters, Character#movie, Director#filmography, Movie#director BENP: the end of the video is classwork and then showing off the app https://association-accessors.firstdraft.com/. This could be a separate video, not going to transcribe this for now. Might be best as just video content? "],["finish-and-submit-refactoring-msm-again.html", "31.4 Finish and Submit Refactoring MSM – Again!", " 31.4 Finish and Submit Refactoring MSM – Again! "],["photogram-associations.html", "32 Photogram Associations", " 32 Photogram Associations Notes: Un-graded, optional assignment, no tests, no rails grade has_many, belongs_to, scope, through using https://association-accessors.firstdraft.com/ (needs a video tutorial, see notes in Refactoring MSM Again two readings: https://guides.rubyonrails.org/association_basics.html stretch goal: https://remimercier.com/scoped-active-record-associations/ Project: https://github.com/appdev-projects/photogram-associations "],["cookies-intro.html", "33 Cookies Intro", " 33 Cookies Intro Notes: Cookies Intro video transcription is in cookies-with-video.md Project (graded): https://github.com/appdev-projects/cookies-intro Target: https://cookies-intro.matchthetarget.com/ Useful chapters: cookies.md cookies-vs-session.md BENP: note that this assignment is not manadatory, so is there even a rails grade? May need to doublde check this in other optional assignments as well "],["video-segment-exploring-browser-cookies.html", "33.1 Video Segment: Exploring Browser Cookies", " 33.1 Video Segment: Exploring Browser Cookies Notes: time stamp 00:00:25 to 00:03:30 in Chrome, visit target, “Inspect” &gt; “Application” &gt; “Cookies”, Name/Value pairs This is much like Omnicalc, but the difference is, when we type in some values and go back to previous pages, it remembers my previous inputs. Somehow this application is storing information between requests. We could have done that with a database and tables, storing the information that was put in the forms. But if we open another browser, navigate to the target, and enter some new calculations, then we can see that it remembers the information only from the current browser. So we are not just storing information in a database and retrieving the most recent record to show to everyone. Each individual user is seeing their own previous calculation. Now with cookies we have the tools to do this. BENP: below is transcription, but really needs a GIF showing it If you open your developer tools in Chrome by right-clicking on an element and selecting “Inspect”, you will will see a tab in the toolbar called “Application”. The “Application” tab has a navigation menu on the left side, where you can find a section called “Cookies”. The cookies are grouped by domain, and you can see all of the cookies that are being stored by the current domain of the target. These values are being stored by Chrome on your own laptop, so they are unique to each of us on different computers! We can see the “Name” column and the “Value” column with things related to our addition, subtraction, multiplication, and division. These are key/value pairs, just like the hashes that we are used to. Each domain is able to store about 50 key/value pairs, with some slight variation in the amount by browser (e.g., Chrome vs. Firefox), and use about 4 kb of space. That’s not much space, but plenty for some basic text information. What if I select a row from my cookies table and delete it? When I go back to the form associated with that cookie, the memory of the key/value pair I entered will be erased. It resets the memory. Useful if you ever want to force signout of a website (using the “Clear all cookies” button). 33.1.1 Text Companion: Exploring Browser Cookies "],["video-segment-cookies-object.html", "33.2 Video Segment: cookies Object", " 33.2 Video Segment: cookies Object Notes: time stamp 00:03:30 to 00:10:23 explore &lt;%= cookies %&gt; on app/views/calculation_templates/addition_form.html.erb cookies.store() in add action and show in view template Let’s see how to implement this in our Rails app. If we open our app browser and try some of the calculation forms and go back, we will see there is no memory of my previous interaction being shown. First, let’s find the form we want to work on. How about addition? We can begin by embedding a variable called cookies, that we haven’t discussed yet. Rails creates this and gives it to us, just like params. It comes pre-defined for us and puts it into this hash-like object: &lt;!--- app/views/calculation_templates/addition_form.html.erb ---&gt; &lt;h1&gt;New addition&lt;/h1&gt; &lt;form action=&quot;/wizard_add&quot;&gt; &lt;label for=&quot;first_field&quot;&gt;Add this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first_field&quot; name=&quot;first_num&quot;&gt; &lt;label for=&quot;second_field&quot;&gt;to this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;second_field&quot; name=&quot;second_num&quot;&gt; &lt;button&gt;Add!&lt;/button&gt; &lt;/form&gt; &lt;%= cookies %&gt; {: mark_lines=“15”} Now we can refresh the “Add” page (at the URL path /muggle_add), and we will see that where we embedded cookies there is a an ActionDispatch::Cookies::CookieJar class. This object behaves just like a hash. So we can do things like .fetch() and .store() key/value pairs in it. If we wanted to store some random pair like apple (key) and banana (value), we could write &lt;%= cookies.store(:apple, \"banana\") %&gt;. If we refresh /muggle_add, then open the dev tools and go to our “Application” tab and then the cookies for the current domain, we will see the “Name” and “Value” column have been added to with “apple” and “banana”, respectively. So this information is now stored in the browser on my laptop. And we could go and .fetch it from cookies elsewhere in the app! But let’s do something more interesting. Let’s store the results of each addition. We know from our addition form, that the action=\"/wizard_add\" is telling us that this is the route the form will send the input to. That route goes to the app/controllers/calculations_controller.rb action called add (check the config/routes.rb file to see that). This is the action that actually parses information from the query string (supplied by the form), does the calculation and renders a template showing the result. Let’s improve this action by also storing the results in our cookies object: # app/controllers/calculations_controller.rb class CalculationsController &lt; ApplicationController ... def add @first_number = params.fetch(&quot;first_num&quot;).to_f @second_number = params.fetch(&quot;second_num&quot;).to_f @result = @first_number.to_f + @second_number.to_f cookies.store(:addition_result, @result) render({ :template =&gt; &quot;calculation_templates/add_results.html.erb&quot; }) end ... {:mark_lines=“11”} Now that we stored it in the cookies hash, if we go back to /muggle_add, and (with our dev tools cookies tab open!) input some data and click “Add!”, then we will see a new “Name”/“Value” pair appear in our table, the “addition_result” with our @result value from the action. And now, back in the form, we can embed the new cookies value using the key that we assigned to it in the action: &lt;!--- app/views/calculation_templates/addition_form.html.erb ---&gt; &lt;h1&gt;New addition&lt;/h1&gt; &lt;form action=&quot;/wizard_add&quot;&gt; &lt;label for=&quot;first_field&quot;&gt;Add this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first_field&quot; name=&quot;first_num&quot;&gt; &lt;label for=&quot;second_field&quot;&gt;to this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;second_field&quot; name=&quot;second_num&quot;&gt; &lt;button&gt;Add!&lt;/button&gt; &lt;/form&gt; &lt;p&gt;Your previous addition was: &lt;%= cookies.fetch(:addition_result) %&gt;&lt;/p&gt; {: mark_lines=“15”} And now if we enter data in the form, click “Add!”, view the results, and then return to /muggle_add, we will see the result of our previous calculation being displayed. We can expand this to match the target by storing the other two numbers and displaying the full calculation string on the addition page: # app/controllers/calculations_controller.rb class CalculationsController &lt; ApplicationController ... def add @first_number = params.fetch(&quot;first_num&quot;).to_f @second_number = params.fetch(&quot;second_num&quot;).to_f @result = @first_number.to_f + @second_number.to_f cookies.store(:addition_result, @result) cookies.store(:addition_first, @first_number) cookies.store(:addition_second, @second_number) render({ :template =&gt; &quot;calculation_templates/add_results.html.erb&quot; }) end ... {:mark_lines=“12-13”} &lt;!--- app/views/calculation_templates/addition_form.html.erb ---&gt; &lt;h1&gt;New addition&lt;/h1&gt; &lt;form action=&quot;/wizard_add&quot;&gt; &lt;label for=&quot;first_field&quot;&gt;Add this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;first_field&quot; name=&quot;first_num&quot;&gt; &lt;label for=&quot;second_field&quot;&gt;to this:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;second_field&quot; name=&quot;second_num&quot;&gt; &lt;button&gt;Add!&lt;/button&gt; &lt;/form&gt; &lt;p&gt; Your previous addition was: &lt;%= cookies.fetch(:addition_first) %&gt; + &lt;%= cookies.fetch(:addition_second) %&gt; = &lt;%= cookies.fetch(:addition_result) %&gt; &lt;/p&gt; {: mark_lines=“15-20”} Now the page /muggle_add should match the target. That’s fundamentally it for cookies! Just a simple key/value object called cookies that we can add to and pull values out of in any action and any view template. The cookies that a user stores on their computer will come back to us everytime they visit our app from the same browser and we can fetch to show the user tailored content. Until they clear their cookies, use a new browser, or use a new computer. 33.2.1 Text Companion: cookies Object "],["finish-and-submit-cookies-intro.html", "33.3 Finish and Submit Cookies Intro", " 33.3 Finish and Submit Cookies Intro see cookies.md for requirements "],["photogram-signin-intro-to-authentication.html", "34 Photogram Signin (Intro to Authentication)", " 34 Photogram Signin (Intro to Authentication) Notes: Cookies Intro video transcription is in photogram-signin.md Project (graded): https://github.com/appdev-projects/photogram-signin Target: https://photogram-signin.matchthetarget.com/ Useful chapters: cookies-vs-session.md BENP: signin vs. sign in vs. sign-in (same for signup, signout, signon, etc.), decide and check doc for consistency BENP: there are no /git commits done in the original video until around 50min when there is all of a sudden an intro to git including branching. This should have come earlier in the class, and git committing should be integrated throughout this doc as it is elsewhere "],["video-segment-intro-and-exploring-our-starting-point.html", "34.1 Video Segment: Intro and Exploring Our Starting Point", " 34.1 Video Segment: Intro and Exploring Our Starting Point Notes: time stamp 00:00:00 to 00:02:00 For this project, we’re just going to use what we learned about cookies and build an industrial-grade signin system supported by some of Rails’ features. This is just being added on top of the Photogram GUI project that we already finished, so, as usual, the starting point of our app is the finishing point of that project. Be sure to run rails sample_data in case your /users homepage is empty when you open the app browser. We’re pretty familiar with the app by now, with it’s list of users, list of photos, and details pages, including photo comments. Right now, when we add a comment, we need to include a valid author ID in the form to get it to work. We’re finally going to evolve this to what it should be. When a user signs up, there there will be an ID number assigned, but they won’t see it, and when a user uploads a photo that photo will be associated with them by the ID numbers. Let’s start to evolve this step-by-step. 34.1.1 Text Companion: Intro and Exploring Our Starting Point "],["video-segment-storing-passwords.html", "34.2 Video Segment: Storing Passwords", " 34.2 Video Segment: Storing Passwords Notes: time stamp 00:02:00 to 00:08:39 migration file: rails g migration AddPasswordDigestToUsers add password_digest Column to User explore db/migrate and rails db:migrate add has_secure_password to app/models/user.rb to get .password and .password_confirmation bcrypt gem First of all, we want to make it so that there is an actual signup page, rather than just the current “Add user” form at the top of the list of users. What we want is for a route like /user_sign_up to exist. Try entering that in your app’s browser, get the familiar error message, and begin debugging. But first, what do we want here? We want this new route to display a form and for that form to have fields for username and password. Now we need a new column that will contain something related to a password. In our domain modeling in class, when we created this column for our users table, we chose to name it “password”. That’s a good first instinct, but it’s not a good idea to store our user’s passwords in plain text in our database. If our database is compromised (e.g., hacked), then anyone can see them. What we do instead is scramble up a user’s password in a deterministic way, so that we can always scramble them in the same way, but it’s hard to go in the opposite direction. This is known as a oneway hashing algorithm. Basically, whatever the user says their password is, we don’t store it, but we are able to authenticate it. “Password digest” is the name that we choose for this scrambled-password column. So we just need to add this column to our users table, which already exists in our project. BENP: at this point in video we use active record chapter as reference to steps We can add a column using our reference. First we need a migration file, just the file because we already have the model. Then we can write a method in there to add or remove a column. At the terminal in our GitPod app, we can first do: rails g migration AddPasswordDigestToUsers Running that just creates a file in the db/migrate/ GitPod workspace folder for me, and gives the file the correct name, like: db/migrate/[TIME OF GENERATION]_add_password_digest_to_users.rb. The timestamp in the filename is important, because this orders the filenames correctly in the db/migrate/ folder. Once we push this code to our production server and run rails db:migrate, it needs to run the migrations in order. For instance, we want the user table to be generated before we try to add a column to it! Now we have this migration file, but we need to add our instructions on how we want to evolve the database. Let’s do that: # db/migrate/[TIME OF GENERATION]_add_password_digest_to_users.rb class AddPasswordDigestToUsers &lt; ActiveRecord::Migration[6.0] def change add_column :users, :password_digest, :string end end {: mark_lines=“5”} The add_column method is saying, create a new column in the users table with the name password_digest and make this column of type string. We could add additional changes of adding or dropping lines on this table or others all within the def change method, but it’s often better to keep the changes in their own respective files, with appropriate filenames. Back at the terminal prompt, we can push our changes to the database by running: rails db:migrate And this command will look in the db/migrate/ folder and see which have files have been run, and which have not been, and it will only run the latter. With that command, we now have added the password_digest column to our app/models/user.rb model (check the # == Schema Information to see the added column). Now we’re ready to store a password in a secure manner. With these steps, we have automatically added two attributes on User: .password and .password_confirmation. So we can call those two methods as if they were columns (even though they are not!), and Rails will make sure they match then scramble the password securely, and store them as a string in the password_digest column. We just need to make one addition to the model: # app/models/user.rb ... class User &lt; ApplicationRecord validates(:username, { :presence =&gt; true, :uniqueness =&gt; { :case_sensitive =&gt; false }, }) has_secure_password def comments ... end ... end {: mark_lines=“11”} This declaration in our active record model, is actually coming from the Gemfile in our GitPod root folder. We haven’t discussed the Gemfile much BENP: see notes in previous videos, it has been brought up a bit, might need early dedicated information, but it’s very important. It contains a list of all the libraries that our application is relying on, including Rails itself: # Gemfile source &#39;https://rubygems.org&#39; git_source(:github) { |repo| &quot;https://github.com/#{repo}.git&quot; } ruby &#39;2.7.3&#39; # Bundle edge Rails instead: gem &#39;rails&#39;, github: &#39;rails/rails&#39; gem &#39;rails&#39;, &#39;~&gt; 6.0.3&#39;, &#39;&gt;= 6.0.3.2&#39; # Use sqlite3 as the database for Active Record # Use Puma as the app server gem &#39;puma&#39;, &#39;~&gt; 4.1&#39; # Use Active Model has_secure_password gem &#39;bcrypt&#39; ... {: mark_lines=“9 16”} gem is Ruby’s name for libraries that we are borrowing from other people, 'rails' being the motherload. One of these gems is also called 'bcrypt', and that’s where we’re getting the has_secure_password method from, which automatically defines the .password and .password_confirmation methods, and scrambles the input password, if you have a column named password_digest. 34.2.1 Text Companion: Storing Passwords "],["video-segment-signup-form.html", "34.3 Video Segment: Signup Form", " 34.3 Video Segment: Signup Form Notes: time stamp 00:08:39 to 00:24:51 add navigation links in app/views/layouts/application.html.erb RCAV /user_sign_up copy and modify add user form found in app/views/users/index.html.erb use type=\"password\" inputs fix create action to use .password and .password_confirmation before .save control flow with :notice or :alert Now we are ready to get /user_sign_up working. This is just a regular CRUD task. BENP: 00:08:40 to 00:09:40 was kind of a flub, deleted this bit of transcription. Let’s follow the usual RCAV, by first defining the route: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/user_sign_up&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_registration_form&quot; }) ... end {: mark_lines=7\"} Then defining the action: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def new_registration_form render({ :template =&gt; &quot;users/signup_form.html.erb&quot; }) end ... end {: mark_lines=“4-6”} And get that view template doing something: &lt;!--- app/views/users/signup_form.html.erb ---&gt; &lt;h1&gt;hi&lt;/h1&gt; Once we have the page working, we’re ready to add a form. Since this is the Photogram project, we actually have form that we can pull from on the index users action view template (app/views/users/index.html.erb), where we had the “Add user” form at the top of the page. So let’s just cut (because we don’t want this form here anymore!) and paste from app/views/users/index.html.erb into our new view template for modification: &lt;!--- app/views/users/signup_form.html.erb ---&gt; &lt;h1&gt;Sign Up&lt;/h1&gt; &lt;form action=&quot;/insert_user_record&quot;&gt; &lt;label for=&quot;browser_username&quot;&gt;Username&lt;/label&gt; &lt;input id=&quot;browser_username&quot; type=&quot;text&quot; name=&quot;input_username&quot; placeholder=&quot;Enter a username...&quot;&gt; &lt;button&gt;Sign up!&lt;/button&gt; &lt;/form&gt; {: mark_lines=“3-10”} This form also has an action associated with it, that is going to do exactly what we want! That’s because we already designed the CRUD steps in our Photogram project. Here we want to create a user in our database, and we can see in our routes and controller file, that these steps are ready for us: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/user_sign_up&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_registration_form&quot; }) # User routes # CREATE get(&quot;/insert_user_record&quot;, {:controller =&gt; &quot;users&quot;, :action =&gt; &quot;create&quot; }) ... end {: mark_lines=“12”} BENP: navbar aside Before we go any farther, let’s add a link to our view template that will get us to the signup form without needing to enter the URL. We can do this by just adding a link in our navbar in the app/views/layouts/application.html.erb wrapper file: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/user_sign_up&quot;&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/users&quot;&gt;Users&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/photos&quot;&gt;Photos&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“10-16”} BENP: beware, the navbar comes empty in the current github project: https://github.com/appdev-projects/photogram-signin/blob/master/app/views/layouts/application.html.erb (but was already filled with some links in this video). Layout page comes up a lot below, so check all of these for consistency. Okay, now in our signup form we still need to modify the form to include password fields: &lt;!--- app/views/users/signup_form.html.erb ---&gt; &lt;h1&gt;Sign Up&lt;/h1&gt; &lt;form action=&quot;/insert_user_record&quot;&gt; &lt;label for=&quot;browser_username&quot;&gt;Username&lt;/label&gt; &lt;input id=&quot;browser_username&quot; type=&quot;text&quot; name=&quot;input_username&quot; placeholder=&quot;Enter a username...&quot;&gt; &lt;label for=&quot;browser_password&quot;&gt;Password&lt;/label&gt; &lt;input id=&quot;browser_password&quot; type=&quot;password&quot; name=&quot;input_password&quot; placeholder=&quot;Enter a password...&quot;&gt; &lt;label for=&quot;browser_password_confirmation&quot;&gt;Password&lt;/label&gt; &lt;input id=&quot;browser_password_confirmation&quot; type=&quot;password&quot; name=&quot;input_password_confirmation&quot; placeholder=&quot;Confirm your password...&quot;&gt; &lt;button&gt;Sign up!&lt;/button&gt; &lt;/form&gt; {: mark_lines=“9-10 12-13”} Note that we changed the type=\"\" attribute from \"text\" to \"password\" so the user’s input is hidden on screen when they fill out the form. And becasue we want the user to be sure of the hidden password, we have them confirm it in the last field. So the /user_sign_up is looking like the target now, with the correct form. If we fill out the form with a new user and password, and click “Sign up!”, then it should call the action create in the controller users_controller.rb, as defined by the action=\"/insert_user_record\" route. This action looks like: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def create user = User.new user.username = params.fetch(&quot;input_username&quot;) user.save redirect_to(&quot;/users/#{user.username}&quot;) end ... end We instantiate a new record, fill in the username, then save the record. We are missing a password here! But does the form work as it is and add a username to the database anyway? Clear the server log in the terminal running bin/server, try to create a new user and password, and click “Sign up!”. We get an error! We do end up on the details pages at least /users/[NEW USER], but I get the error: undefined method `username&#39; for nil:NilClass And this error was occurring when, in the user details view template, we got to: &lt;h1&gt;&lt;%= @user.username %&gt;&lt;/h1&gt;. So @user is nil, which means that in the show action when we looked up a username like: User.where({ :username =&gt; the_username }).at(0), I got nothing back, because there is no user in my database with the username in in the second segment of our path! In other words, the new user is not being added to the database with our sign up form. The validation failed, and if we look in the app/controllers/users_controller.rb file, then we see the only validation is for a username being present and unique. But we also put in the has_secure_password declaration. And this is the line that is preventing the user from being added without a password! Let’s fix our create action. The .save method returns true (if it worked) or false (if it didn’t), so we can store that in a variable and use it to decide the next step in a conditional. To give the user more information about what is going on, we can also use the notice and alert feature, as a second argument to redirect_to. Remember, when the save doesn’t work there is the collection called user.errors.full_messages, which is an array containing everything that went wrong. BENP: when was notice and alert introduced? Could link to here But, most importantly, we need to assign a password field to our new user with our new User methods .password and .password_confirmation: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def create user = User.new user.username = params.fetch(&quot;input_username&quot;) user.password = params.fetch(&quot;input_password&quot;) user.password_confirmation = params.fetch(&quot;input_password_confirmation&quot;) save_status = user.save if save_status == true redirect_to(&quot;/users/#{user.username}&quot;, { :notice =&gt; &quot;Welcome, #{user.username}!&quot;}) else redirect_to(&quot;/user_sign_up&quot;, { :alert =&gt; user.errors.full_messages.to_sentence }) end end ... end {: mark_lines=“9-10 12 14-18”} Remember .password and .password_confirmation are not columns in our table (we only added password_digest). Again, this is because of has_secure_password is doing all of the work of adding these attributes but keeping them hidden and safe (thanks to the bcrypt gem). Now, if the save doesn’t work the user will be redirected back to the form, and if it does work the user will be shown a confirmation message. Before testing, we need to add the notice and alert messages to our show and signup pages (where they are sent): &lt;!--- app/views/users/show.html.erb ---&gt; &lt;div&gt; &lt;%= notice %&gt; &lt;/div&gt; &lt;h1&gt;&lt;%= @user.username %&gt;&lt;/h1&gt; ... {: mark_lines=“3-5”} &lt;!--- app/views/users/signup_form.html.erb ---&gt; &lt;div&gt; &lt;%= alert %&gt; &lt;/div&gt; &lt;h1&gt;Sign Up&lt;/h1&gt; ... {: mark_lines=“3-5”} With all of this done, we can visit /user_sign_up (you can also use the link in our navbar to get there), and test add some new users. Try to add the user with a valid password (takes you to the user details page with the welcome message), and without a valid password (you stay on the form and get an error message detailing what you did wrong). It looks like everything is working! 34.3.1 Text Companion: Signup Form "],["video-segment-notices-and-alerts.html", "34.4 Video Segment: Notices and Alerts", " 34.4 Video Segment: Notices and Alerts Notes: time stamp 00:24:51 to 00:30:21 add notice and alert to app/views/layouts/application.html.erb use if ... present? control flow and style green and red Generally speaking, on every page in the application we are going to want to have the option of showing notices and alerts, so let’s just remove those from the show and signup view templates and put them in my application layout view template: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;div&gt; &lt;%= notice %&gt; &lt;/div&gt; &lt;div&gt; &lt;%= alert %&gt; &lt;/div&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“14-20”} Now these alert and notice messages will appear on any page. Maybe we want to style them a bit though, to make them somewhat more prominent with red and green boxes and text: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;div style=&quot;border: thin green solid; color: green;&quot;&gt; &lt;%= notice %&gt; &lt;/div&gt; &lt;div style=&quot;border: thin red solid; color: red;&quot;&gt; &lt;%= alert %&gt; &lt;/div&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“14 18”} But if we try to use our pages now, we will see the empty box appearing even when ther is not message. So we need to further modify the code to only show the box if a notice or alert is present: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;% if notice.present? %&gt; &lt;div style=&quot;border: thin green solid; color: green;&quot;&gt; &lt;%= notice %&gt; &lt;/div&gt; &lt;% end %&gt; &lt;% if alert.present? %&gt; &lt;div style=&quot;border: thin red solid; color: red;&quot;&gt; &lt;%= alert %&gt; &lt;/div&gt; &lt;% end %&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“14 18 20 24”} This type of conditional is something you write a lot of in your view templates, so get used to it! Once you have a user, you need conditionals to show or not show them content based on who they are and what their privilege levels are. We are using .present?, which is similar to other ways of doing this, like writing != nil. But .present is smarter, because it will look for other versions of missing information besides just nil. BENP: there is a bootstrap aside here at 00:28:39, but I think this should be left out at this point. Bootstrap is the end of the course! 34.4.1 Text Companion: Notices and Alerts "],["video-segment-signout-with-reset_session.html", "34.5 Video Segment: Signout with reset_session", " 34.5 Video Segment: Signout with reset_session Notes: time stamp 00:30:21 to 00:34:03 add session.store(:user_id, user.id) to create action RCAV /user_sign_out with reset_session in toast_cookies action Now that we have our user signed up, we should also allow them to signin. That means we should set the cookie. Back in my action, if the user did successfuly sign up, then let’s add a cookie: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController ... def create user = User.new user.username = params.fetch(&quot;input_username&quot;) user.password = params.fetch(&quot;input_password&quot;) user.password_confirmation = params.fetch(&quot;input_password_confirmation&quot;) save_status = user.save if save_status == true session.store(:user_id, user.id) redirect_to(&quot;/users/#{user.username}&quot;, { :notice =&gt; &quot;Welcome, #{user.username}!&quot;}) else redirect_to(&quot;/user_sign_up&quot;, { :alert =&gt; user.errors.full_messages.to_sentence }) end end ... end {: mark_lines=“15”} Note that we are using session, rather than cookies. These are simliar but session is more secure, and you can read about it here. We use the conventional name for the cookie key, which is user_id, and we assign this key our value of the current user.id. This ID number was assigned as soon as we saved the user to the database with .save above. We can print this new ID number in our layout view template with some embedded Ruby like &lt;%= session.fetch(:user_id) %&gt;, and if we navigate around the site after we signup a new user, we should see the current user ID follow us around on every page. So that works! We also want to give the user a way to signin later. But first, let’s make a “Sign out” link. Let’s add this to our navbar: &lt;!--- app/views/layouts/application.html.erb ---&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/user_sign_up&quot;&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/user_sign_out&quot;&gt;Sign Out&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/users&quot;&gt;Users&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/photos&quot;&gt;Photos&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; ... &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; {: mark_lines=“13”} This route \"/user_sign_out\" just needs an RCAV that will remove all the cookies. We can add this route: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/user_sign_up&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_registration_form&quot; }) get(&quot;/user_sign_out&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;toast_cookies&quot; }) # User routes # CREATE get(&quot;/insert_user_record&quot;, {:controller =&gt; &quot;users&quot;, :action =&gt; &quot;create&quot; }) ... end {: mark_lines=“8”} Then add this action: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def toast_cookies reset_session redirect_to(&quot;/&quot;, { :notice =&gt; &quot;See ya later!&quot; }) end ... end {: mark_lines=“4-7”} We get the method reset_session from Rails, and it just deletes all the cookies in the current session. And we are just having our action redirect the user to the homepage when they signout, and giving them a success notice there. Try to refresh your app browser and click the “Sign out” link, it should work! 34.5.1 Text Companion: Signout with reset_session "],["video-segment-signin-with-post-and-authenticate.html", "34.6 Video Segment: Signin with post and authenticate", " 34.6 Video Segment: Signin with post and authenticate Notes: time stamp 00:34:03 to 00:48:28 RCAV /user_sign_in with new_session_form action signin form with action=\"/verify_credentials\" and method=\"post\" authenticate action using user.authenticate and control flow Now we want to work on our URL path /user_sign_in. If we navigate there, we see that we need to RCAV it: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/user_sign_up&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_registration_form&quot; }) get(&quot;/user_sign_out&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;toast_cookies&quot; }) get(&quot;/user_sign_in&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_session_form&quot; }) # User routes # CREATE get(&quot;/insert_user_record&quot;, {:controller =&gt; &quot;users&quot;, :action =&gt; &quot;create&quot; }) ... end {: mark_lines=“9”} We make an action to just display the signin form: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def toast_cookies ... end def new_registration_form render({ :template =&gt; &quot;users/signup_form.html.erb&quot; }) end def new_session_form render({ :template =&gt; &quot;users/signin_form.html.erb&quot; }) end ... end {: mark_lines=“12-14”} And make the template: &lt;!--- app/views/users/signin_form.html.erb ---&gt; &lt;h1&gt;hi&lt;/h1&gt; Once we have the page working, we’re ready to add a form. We can mostly copy-paste from the signup form, but we will need to modify it: &lt;!--- app/views/users/signin_form.html.erb ---&gt; &lt;h1&gt;Sign In&lt;/h1&gt; &lt;form action=&quot;/verify_credentials&quot;&gt; &lt;label for=&quot;browser_username&quot;&gt;Username&lt;/label&gt; &lt;input id=&quot;browser_username&quot; type=&quot;text&quot; name=&quot;input_username&quot; placeholder=&quot;Enter your username...&quot;&gt; &lt;label for=&quot;browser_password&quot;&gt;Password&lt;/label&gt; &lt;input id=&quot;browser_password&quot; type=&quot;password&quot; name=&quot;input_password&quot; placeholder=&quot;Enter your password...&quot;&gt; &lt;button&gt;Sign in!&lt;/button&gt; &lt;/form&gt; {: mark_lines=“3-13”} We have a new action called \"/verify_credentials\", which is what will happen when they try to sign in. We can test the new form on our app. Enter a username and password for one of the accounts you previously added to the database, and click “Sign in!”. We are now taken to a URL that looks like: /verify_credentials?input_username=[USERNAME]&amp;input_password=[PASSWORD]. That’s no good! We are showing the user’s secure password in the query string! We need to hide that by changing the form attribute method=\"post\": &lt;!--- app/views/users/signin_form.html.erb ---&gt; &lt;h1&gt;Sign In&lt;/h1&gt; &lt;form action=&quot;/verify_credentials&quot; method=&quot;post&quot;&gt; ... &lt;/form&gt; {: mark_lines=“5”} With this more advanced method, the information that we enter in the form will no longer go into a query string, and we will need to use a different route method than get(), as we’ve done. We will instead use post() to build the route in the form action: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;index&quot; }) get(&quot;/user_sign_up&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_registration_form&quot; }) get(&quot;/user_sign_out&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;toast_cookies&quot; }) get(&quot;/user_sign_in&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;new_session_form&quot; }) post(&quot;/verify_credentials&quot;, { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;authenticate&quot; }) # User routes # CREATE get(&quot;/insert_user_record&quot;, {:controller =&gt; &quot;users&quot;, :action =&gt; &quot;create&quot; }) ... end {: mark_lines=“10”} The form method and the route method must match, or Rails won’t find it. get() is the default form method, so we don’t need to write it as the attribute. Now we define \"authenticate\": # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def authenticate render({ :plain =&gt; &quot;hi&quot; }) end ... end {: mark_lines=“4-6”} Now if we refresh /user_sign_in, re-enter some login information, and click the button, then we will be taken to “hi” and there will be none of the form inputs in a query string at that URL. We need to actually make the authenticate action actually work now, by signing in the user (set the cookie with their ID number), if they put in the correct password. In pseudo-code: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def authenticate # get the username from params # get the password from params # lookup the record from the db matching username # if there&#39;s no record, redirect to signin form # if there is a record, check to see if password matches # if so, set the cookie and redirect to homepage # if not, redirect back to sign in form render({ :plain =&gt; &quot;hi&quot; }) end ... end {: mark_lines=“5-13”} Let’s do all of that now: # app/controllers/users_controller.rb class UsersController &lt; ApplicationController def authenticate un = params.fetch(&quot;input_username&quot;) pw = params.fetch(&quot;input_password&quot;) # lookup the record from the db matching username user = User.where({ :username =&gt; un }).at(0) # if there&#39;s no record, redirect to signin form if user == nil redirect_to(&quot;/user_sign_in&quot;, { :alert =&gt; &quot;No one by that name &#39;round these parts&quot; }) else # if there is a record, check to see if password matches if user.authenticate(pw) # if so, set the cookie and redirect to homepage session.store(:user_id, user.id) redirect_to(&quot;/&quot;, { :notice =&gt; &quot;Welcome back #{user.username}!&quot; }) else # if not, redirect back to sign in form redirect_to(&quot;/user_sign_in&quot;, { :alert =&gt; &quot;Nice try&quot; }) end end end ... end {: mark_lines=“5-25”} Because we used has_secure_password in out app/models/user.rb model, we get the awesome method .authenticate, which we used on our instance of User above to do the oneway encryption on the input password to see if it matches that user’s encrypted password in the database. If the authentication passes, then user.authenticate(pw) returns the record, which, for the purposes of a conditional, counts as true (“truthy”, actually), and we can use it to decide the next step. With all this new code, try to play with the signin form now at /user_sign_in. Try with the right username, but wrong password, vice versa, and with no password. Finally try with everything correct. It should all work now! We now have a robust signin-signout system built with Rails. 34.6.1 Text Companion: Signin with post and authenticate "],["video-segment-git.html", "34.7 Video Segment: git", " 34.7 Video Segment: git Notes: time stamp 00:48:28 to 00:52:09 BENP: I am not transcribing this part of the video yet. Isn’t there /git stuff way earlier in the class? Needs to be zipped with that and have its own dedicated content 34.7.1 Text Companion: git "],["video-segment-remove-user-facing-ids.html", "34.8 Video Segment: Remove User-Facing IDs", " 34.8 Video Segment: Remove User-Facing IDs Notes: time stamp 00:52:09 to 00:59:53 put photo.owner_id = session.fetch(:user_id) and comment.author_id = session.fetch(:user_id) in backend create actions of add photo and add comment forms Another thing we don’t want in our app is the requirement of users to enter valid ID numbers when they want to post photos or comments, like in the “Owner ID” field in the form at the top of the /photos index page. We can go into the photo index page, find that form, and modify it: BENP: why is this called all_photos.html.erb and not index.html.erb? &lt;!--- app/views/photos/all_photos.html.erb ---&gt; &lt;h1&gt;List of photos&lt;/h1&gt; &lt;form action=&quot;/insert_photo_record&quot;&gt; &lt;label for=&quot;browser_input&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;browser_input&quot; type=&quot;text&quot; name=&quot;input_image&quot; placeholder=&quot;Enter a URL for the image...&quot;&gt; &lt;label for=&quot;browser_caption&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;browser_caption&quot; name=&quot;input_caption&quot; placeholder=&quot;Enter a caption for the photo...&quot;&gt;&lt;/textarea&gt; &lt;label for=&quot;browser_user_id&quot;&gt;Owner ID&lt;/label&gt; &lt;input id=&quot;browser_user_id&quot; type=&quot;text&quot; name=&quot;input_owner_id&quot; placeholder=&quot;Enter an ID of a User&quot;&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; ... We could change the type=\"text\" attribute to type=\"hidden\" on the “Owner ID” and pre-populate the value with the current user ID. But instead, we are just going to get rid of that field entirely: &lt;!--- app/views/photos/all_photos.html.erb ---&gt; &lt;h1&gt;List of photos&lt;/h1&gt; &lt;form action=&quot;/insert_photo_record&quot;&gt; &lt;label for=&quot;browser_input&quot;&gt;Image&lt;/label&gt; &lt;input id=&quot;browser_input&quot; type=&quot;text&quot; name=&quot;input_image&quot; placeholder=&quot;Enter a URL for the image...&quot;&gt; &lt;label for=&quot;browser_caption&quot;&gt;Caption&lt;/label&gt; &lt;textarea id=&quot;browser_caption&quot; name=&quot;input_caption&quot; placeholder=&quot;Enter a caption for the photo...&quot;&gt;&lt;/textarea&gt; &lt;button&gt;Add photo&lt;/button&gt; &lt;/form&gt; ... {: mark_lines=“11”} And now in the backend, when the photo is submitted an the route \"/insert_photo_record\" is called, it goes to the create action in app/controllers/photos_controller.rb. We can change the user ID, which we used to fetch from the params hash as input to the form, to come from the cookies in the session hash: # app/controllers/photos_controller.rb class PhotosController &lt; ApplicationController ... def create # user_id = params.fetch(&quot;input_owner_id&quot;) user_id = session.fetch(:user_id) image = params.fetch(&quot;input_image&quot;) caption = params.fetch(&quot;input_caption&quot;) photo = Photo.new photo.owner_id = user_id photo.image = image photo.caption = caption photo.save redirect_to(&quot;/photos/#{photo.id}&quot;) end ... end {: mark_lines=“6-7”} We set this cookie when the user signed in, so it is available in all of our controller actions! No more need for user input of their ID prior to adding a photo. Try it yourself by finding a photo URL online and adding it to the table (assuming you are signed in as a Photogram user). BENP: 00:54:10 to 00:57:00, we are getting a lecture about git committing now… probably not necessary at this point in the class. Also going into branching off and branch names. We can also go through this exact same process on the “Photo ID” and “Author ID” fields in the comment section of the photo details page. Now that we have cookies, we never want to show any ID numbers from our database to the users. BENP: why is this called details.html.erb and not show.html.erb? &lt;!--- app/views/photos/details.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; ... &lt;h3&gt;Add a new comment&lt;/h3&gt; &lt;form action=&quot;/insert_comment_record&quot;&gt; &lt;label for=&quot;browser_photo_id&quot;&gt;Photo ID&lt;/label&gt; &lt;input id=&quot;browser_photo_id&quot; type=&quot;text&quot; value=&quot;&lt;%= @photo.id %&gt;&quot; name=&quot;input_photo_id&quot;&gt; &lt;label for=&quot;browser_author_id&quot;&gt;Author ID&lt;/label&gt; &lt;input id=&quot;browser_author_id&quot; type=&quot;text&quot; name=&quot;input_author_id&quot;&gt; &lt;label for=&quot;browser_comment&quot;&gt;Comment&lt;/label&gt; &lt;textarea id=&quot;browser_comment&quot; name=&quot;input_body&quot; placeholder=&quot;Enter a comment...&quot;&gt;&lt;/textarea&gt; &lt;button&gt;Add comment&lt;/button&gt; &lt;/form&gt; This isn’t so bad, because at least the “Photo ID” is being pre-populated with the ID of the current photo whose page we are on, but the user shouldn’t have to see it. So we can change that type to \"hidden\". We still need the photo ID, because when we click “Add comment” and call the action at the end of \"/insert_comment_record\", this ID will be added to the comment record in a foreign key column that associates comments to photos. We can also get rid of the label for this hidden input. Finally, we can also once more, remove the “Author ID” field: &lt;!--- app/views/photos/details.html.erb ---&gt; &lt;h1&gt;Photo Details&lt;/h1&gt; ... &lt;h3&gt;Add a new comment&lt;/h3&gt; &lt;form action=&quot;/insert_comment_record&quot;&gt; &lt;input id=&quot;browser_photo_id&quot; type=&quot;hidden&quot; value=&quot;&lt;%= @photo.id %&gt;&quot; name=&quot;input_photo_id&quot;&gt; &lt;label for=&quot;browser_comment&quot;&gt;Comment&lt;/label&gt; &lt;textarea id=&quot;browser_comment&quot; name=&quot;input_body&quot; placeholder=&quot;Enter a comment...&quot;&gt;&lt;/textarea&gt; &lt;button&gt;Add comment&lt;/button&gt; &lt;/form&gt; {: mark_lines=“9-10”} And now we need to add this ID from our cookies into the action: BENP: the code in the video and the code available on github at https://github.com/appdev-projects/photogram-signin/blob/master/app/controllers/comments_controller.rb for this controller look very different # app/controllers/comments_controller.rb class CommentsController &lt; ApplicationController def create comment = Comment.new # comment.author_id = params.fetch(&quot;input_author_id&quot;) comment.author_id = session.fetch(:user_id) comment.photo_id = params.fetch(&quot;input_photo_id&quot;) comment.body = params.fetch(&quot;input_body&quot;) comment.save redirect_to(&quot;/photos/#{comment.photo_id}&quot;) end end {: mark_lines=“7-8”} Now if we try to add a comment as a signed in user, it works, and there is only the one field to enter the comment. Now that we have authentication under our belts, there is nothing left to learn for building CRUD backed applications. Everything from an AirBnB to a social network, you have all the tools! 34.8.1 Text Companion: Remove User-Facing IDs "],["finish-and-submit-photogram-signin.html", "34.9 Finish and Submit Photogram Signin", " 34.9 Finish and Submit Photogram Signin "],["starting-from-scratch-with-generators.html", "35 Starting from Scratch with Generators", " 35 Starting from Scratch with Generators Notes: Day 8 Short Video Recording, which is not transcribed, additional materials (see “Todo”: https://github.com/orgs/firstdraft/projects/11/views/1) Some of these steps are also done in the MSM signin video at the beginning. This can be a review. Useful chapters: starting-a-rails-project-from-scratch.md active-record.md draft-generators.md draft-account.md ideas.firstdraft.com generators with co-pilot "],["video-segment-starting-from-scratch-with-generators.html", "35.1 Video Segment: Starting from Scratch with Generators", " 35.1 Video Segment: Starting from Scratch with Generators 35.1.1 Text Companion: Starting from Scratch with Generators "],["terminology-technical-reference.html", "A Terminology Technical Reference", " A Terminology Technical Reference "],["ruby-technical-reference.html", "B Ruby Technical Reference", " B Ruby Technical Reference "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
