[["string.html", "1.3 String", " 1.3 String Let’s start by getting a more formal introduction to our friend, String. First of all, notice that when I refer to Ruby classes, I capitalize the first letter. The only time we use capital letters when we’re programming is when we refer to Ruby classes. All other times — variable names, file names, etc — we’re going to use lowercase letters only (other than when we’re writing some copy inside a string, of course). 1.3.1 Creating strings We’ve actually been taking a shortcut this whole time when we’ve been saying something like s = &quot;Hello, world!&quot; In Ruby, the formal way to create a new object is to use the .new method on the parent class: s = String.new This will, however, just give us back an empty string \"\". We would then have to add each character to it one by one. One way to do so is by using the .concat method, which accepts a number as an argument, interprets it as an ASCII code, translates it into a single character, and adds it on to the end of the original string. Make the invisible visible in GitPod ✏️ Exercise: Let’s practice making the invisible visible. We will spend a moment getting a GitPod workspace set up, and then running Ruby programs from the terminal there. We will alternate between using REPLs for quick sandbox exercises, and GitPod for graded exercises. BENP: As a template use 00:00:00 to 00:06:15 of string video to transcribe and then re-record an exercise where you first open the helloruby project, create howdy.rb, run it, then add another invisible_to_visible.rb exercise like below: # One-by-one, uncomment the p statements # below and rerun the code s = String.new # p s s = &quot;Hello, world!&quot; # p s s = s.upcase # p s ASCII Codes What’s an ASCII code? At the hardware level, computers only store integers (specifically, in binary form — using only 0s and 1s); so all other datatypes need to be encoded somehow as a number. ASCII, or American Standard Code for Information Interchange, was one scheme that was developed in the early days of computing to store English characters as integers1 Nowadays we use much more sophisticated encoding schemes such as Unicode that supports glyphs from many more languages, and even emojis  Fortunately, Ruby handles most of this low-level stuff for us behind the scenes, so we never really have to worry about it anymore.. The codes are as follows: ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character ASCII Code Character 32 (space) 48 0 64 @ 80 P 96 ` 112 p 33 ! 49 1 65 A 81 Q 97 a 113 q 34 \" 50 2 66 B 82 R 98 b 114 r 35 # 51 3 67 C 83 S 99 c 115 s 36 $ 52 4 68 D 84 T 100 d 116 t 37 % 53 5 69 E 85 U 101 e 117 u 38 &amp; 54 6 70 F 86 V 102 f 118 v 39 ' 55 7 71 G 87 W 103 g 119 w 40 ( 56 8 72 H 88 X 104 h 120 x 41 ) 57 9 73 I 89 Y 105 i 121 y 42 * 58 : 74 J 90 Z 106 j 122 z 43 + 59 ; 75 K 91 [ 107 k 123 { 44 , 60 &lt; 76 L 92 \\ 108 l 124 | 45 - 61 = 77 M 93 ] 109 m 125 } 46 . 62 &gt; 78 N 94 ^ 110 n 126 ~ 47 / 63 ? 79 O 95 _ 111 o Given those ASCII codes, we can now build up a new string from scratch like so: my_string = String.new p my_string my_string.concat(72) my_string.concat(101) my_string.concat(108) my_string.concat(108) my_string.concat(111) my_string.concat(44) p my_string my_string.concat(32) my_string.concat(119) my_string.concat(111) my_string.concat(114) my_string.concat(108) my_string.concat(100) my_string.concat(33) p my_string Click here for a REPL to try it. String literals BENP: possibly shorten section, is it necessary? What a pain! Now that we’ve shown that, under the hood, even creating a string follows the syntax of noun.verb — let’s never do it again. From now on, we’ll use the shortcut of creating string “literals” in place by typing the characters we want within quotes: \"Thank goodness!\" These kinds of exceptions to the regular grammar in order to make life easier are known as “syntactic sugar”. 1.3.2 Methods Next, let’s familiarize ourselves with some of the String class’s methods. For each method below, we’ve provided some REPLs. They are there for you to experiment with the code, click “run ▶”, or use irband see how the methods work. Keep these methods in mind when working on the assignment in Gitpod. String addition, a.k.a. + We’ve already met the .concat method. .concat can accept an integer as an argument, which it interprets as an ASCII code, translates into a single character, and adds to the original string: &quot;hi&quot;.concat(33) # =&gt; &quot;hi!&quot; .concat can also accept a string literal as an argument, in which case it just adds the whole thing to the end of the original string. &quot;hi&quot;.concat(&quot; there&quot;) # =&gt; &quot;hi there&quot; There’s also a shorthand for .concat: .+.2 This is not quite true. The + method is not just an alias for concat — they do slightly different things. But they’re close enough, for our purposes. That may look a little funny, but it’s nothing special, really; it’s just a method with a very short (one letter long) name: &quot;hi&quot;.+(&quot; there&quot;) # =&gt; &quot;hi there&quot; But here’s where it gets interesting; Ruby has another bit of nice syntactic sugar for us. If a class has a method named +, then you are allowed to drop the . before the method name when you call it, and just say: BENP: this seems like a long-winded way to say you can just add strings, but I guess + comes up in other classes besides strings and integers? Is that something students can learn later in their programming life. Always trying to reduce information at the early stages here…maybe dropping the stuff about “.” in this and following section. &quot;hi&quot; +(&quot; there&quot;) # =&gt; &quot;hi there&quot; Wild! And, as we learned earlier when we were introduced to the p method, Ruby also allows you to omit the parentheses around arguments if you want to; so this can be further shortened to: &quot;hi&quot; + &quot; there&quot; # =&gt; &quot;hi there&quot; Now this is really starting to look familiar! It’s a lot like the calculator language, actually. Developer happiness, indeed. a = &quot;Hello&quot; b = &quot;World&quot; p a + b # You can add strings together Click here for a REPL to try it. String multiplication, a.k.a * Strings can be multiplied by numbers using the * method3 More syntactic sugar here, like with the + method above; you can say \"Ya\" * 5 rather than \"Ya\".*(5).: &quot;Ya&quot; * 5 # =&gt; &quot;YaYaYaYaYa&quot; This sort of makes sense, if you think about multiplication as being repeated addition. p &quot;Hello&quot; * 3 Click here for a REPL to try it. The order matters, though. See what happens when you try: 3 * &quot;Hello&quot; Read The Error Message (RTEM)! Does this make sense? \"Hello\" * 3 is calling the String method * with an argument of 3, which kinda makes sense (add \"Hello\" to itself 3 times). But 3 * \"Hello\" is calling the Integer method * with an argument of \"Hello\", which doesn’t make much sense (what would it mean to add 3 to itself \"Hello\" times?). Thus, we can see why the String version of * and the Integer version of * both need an integer argument. Again, the bottom line is — at all times as you are writing Ruby, you should be thinking: “What class is this object? What methods does this class have available?” Even when there’s some syntactic sugar making things look unconventional, don’t forget your basics! It’s still noun.verb under the hood. upcase The upcase method returns a copy of the String with all lowercase letters replaced with their uppercase counterparts. p &quot;hello&quot;.upcase Click here for a REPL to try it. downcase The downcase method returns a copy of the String with all uppercase letters replaced with their lowercase counterparts. p &quot;I&#39;M NOT YELLING AT YOU&quot;.downcase Click here for a REPL to try it. BENP: maybe overkill on the REPLs here, can we combine all these string methods (below as well) into one? swapcase The swapcase method returns a copy of the String with all uppercase letters replaced with their lowercase counterparts, and vice versa. p &quot;FaMiLy&quot;.swapcase # =&gt; &quot;fAmIlY reverse The reverse method returns a new String with the characters from the String in reverse order. p &quot;I can speak in backwords words&quot;.reverse Click here for a REPL to try it. length The length method returns the number of characters (as an Integer) that a String has. p &quot;Supercalifragilisticexpialidocious&quot;.length Click here for a REPL to try it. chomp The chomp method is mostly used to remove the \"\\n\" (newline) character from the end of a string, if it is present: &quot;Raghu\\n&quot;.chomp # =&gt; &quot;Raghu&quot; &quot;Raghu&quot;.chomp # =&gt; &quot;Raghu&quot; This seemingly strange task is very common due to the way that getting user input works; usually someone has to type something at a prompt and then they press return to submit it, and that adds a newline to the end of the string that they typed. Typically, we want to chomp that off the end of their input before we do anything further with it. chomp can also remove other specified character(s) from the end of the string, if they are provided as an argument: &quot;1 apples&quot;.chomp(&quot;s&quot;) # =&gt; &quot;1 apple&quot; &quot;1 apple&quot;.chomp(&quot;s&quot;) # =&gt; &quot;1 apple&quot; Click here for a REPL to try it. gsub The gsub method returns a copy of the String it was called on with all occurrences of the first argument substituted for the second argument. a = &quot;Hello&quot; p a.gsub(&quot;ll&quot;, &quot;ww&quot;) # =&gt; &quot;Hewwo&quot; Click here for a REPL to try it. Advanced gsub techniques BENP: This is pretty advanced and could be confusing to throw in here; maybe Regexp doesn’t appear here? gsub also supports accepting a regular expression as its first argument. We won’t get into regular expressions in detail right now, but all languages (C, C++, Python, etc) include a way to write regular expressions and they are a very powerful way to check whether input strings match certain patterns. In Ruby, we work with regular expressions the way we work with everything else — via a class, Regexp. We create Regexp literals with forward slashes (like we use quotes to create String literals), and then put the pattern that we’re trying to match between the slashes. For now, we’re just going to copy-paste a few simple regexes4 If your project requires scanning text for patterns, then RegexOne is a good resource for learning more. Rubular is handy for quickly testing your regular expressions against some example strings. that come in handy with gsub, in particular: /\\s+/ matches all whitespace, so we can use it with gsub to remove all whitespace: &quot;Hello there,\\nfriend&quot;.gsub(/\\s+/, &quot;&quot;) # =&gt; &quot;Hellothere,friend&quot; /[^0-9]/ matches everything except numeric digits, so we can use it with gsub to remove everything except digits: &quot;March 29th!&quot;.gsub(/[^0-9]/, &quot;&quot;) # =&gt; &quot;29&quot; /[^a-z]/i matches everything except letters (case-insensitively), so we can use it with gsub to remove everything except letters: BENP: where is the i from in the above expression – case-insensitive? ```ruby &quot;March 29th!&quot;.gsub(/[^a-z]/i, &quot;&quot;) # =&gt; &quot;Marchth&quot; ``` /[^a-z0-9\\s]/i matches everything except letters, digits, and whitespace, so we can use it to remove everything except for those: &quot;March 29th!&quot;.gsub(/[^a-z0-9\\s]/i, &quot;&quot;) # =&gt; &quot;March 29th&quot; to_i Sometimes you have a string that contains a number, usually input from a user, and want to do math on it. to_i will attempt to convert a String object into an Integer object. p &quot;8&quot;.to_i Click here for a REPL to try it. strip strip removes all leading and trailing whitespace. p &quot; This has a lot of space on the outside &quot;.strip Click here for a REPL to try it. capitalize capitalize returns a String with the first character converted to uppercase and the remainder to lowercase. p &quot;beginning&quot;.capitalize Click here for a REPL to try it. split This transforms the String into an Array (a list), which we’ll read more about later. If you provide no argument, the string is split upon whitespace, which is handy for e.g. turning a sentence into a list of words: sentence = &quot;Hi I&#39;d like to learn how to program please!&quot; words = sentence.split p words Click here for a REPL to try it. If you do provide an argument to .split, then the string will be chopped up wherever that argument occurs instead of whitespace — for example, use \"4,8,15,16,23,42\".split(\",\") to split on commas. BENP: Below is maybe best left off, introduces arrays and array indexing a bit early You can also split with the empty string, \"\", as an argument in order to turn a string into an Array of its individual characters: a = &quot;Hello!&quot;.split(&quot;&quot;) # =&gt; [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;!&quot;] a.at(0) # =&gt; &quot;H&quot; a.at(-1) # =&gt; &quot;!&quot; include? include? takes a String argument and returns true or false if the argument exists in the String that include? is called on. p &quot;Happy Days&quot;.include?(&quot;H&quot;) p &quot;Happy Days&quot;.include?(&quot;Z&quot;) Click here for a REPL to try it. 1.3.3 More on adding strings together We spend a lot of time composing strings of output for our users, so let’s see a few more examples. Try this: number = 6 * 7 message = &quot;Your lucky number for today is &quot; + number + &quot;.&quot; Click here for a REPL to try it. You’ll see that Ruby gets confused (RTEM!), because we are trying to add an integer to a string and it doesn’t feel comfortable with that. The solution is to tell the Integer to convert itself to a String first using the method called .to_s, or “to string”. Try this instead: number = 6 * 7 message = &quot;Your lucky number for today is &quot; + number.to_s + &quot;.&quot; The above technique for composing strings, adding them together with +, is called string addition. There’s another technique for composing strings that I personally find a bit easier; it’s called string interpolation. Try this instead: number = 6 * 7 message = &quot;Your lucky number for today is #{number}.&quot; Basically, inside the string, you place #{} where you eventually want your value to go. Inside the curly braces, you can write any Ruby expression without worrying about whether it is a string or not. The expression will be evaluated, converted to a string, and added to the string right in that spot. You can interpolate as many expressions as you want into a single string. Pretty neat! If you find interpolation confusing, feel free to just use addition. 1.3.4 Getting strings from users with gets We can make our programs much more interesting if we allow the users of the program to interact with them by supplying input. We can do this with the gets method (pronounced “get S”, short for “get string”), which will pause the program and wait for the user to type something in the terminal and press return. The return value of the gets method will be a String containing what the user typed, which we can store in a variable and then process further like any other String. For example, rather than saying “Hello, world!”, let’s have the computer say hello to the user by name instead. When you run this program, it will pause after saying \"What's your name?\" and you will have to type something in and press return. Click on the terminal to put focus there, and then you’ll be able to type into it: p &quot;What&#39;s your name?&quot; their_name = gets p &quot;Hello, &quot; + their_name + &quot;!&quot; Click here for a REPL to try it. Great! Our first user input. However, you’ll notice a couple of things. First of all, there’s a \\n sneaking into the input. \\n represents a newline character, and it’s in there because of the return that is pressed to submit the input. puts If you want to see the newline in action, we can use a different printing method called Kernel.puts (pronounced “put S”, short for “put string”). puts is actually the printing method that is used most when crafting the final output of command-line programs; as opposed to Kernel.p, which is used most for making the invisible visible while debugging. Try switching p &quot;Hello, &quot; + their_name + &quot;!&quot; to puts &quot;Hello, &quot; + their_name + &quot;!&quot; and see how the output is different. You can see that the quotes around the string are removed, which makes sense if you’re actually displaying output to a user and not debugging — users should not know or care about the quotes around Ruby string literals. And the newline character causes a line break when a string is printed with puts, as it should. Most of the time, we’ll stick with p, since it provides more details while debugging; but it’s good to know that puts exists. gets.chomp We almost never want to keep the \\n that results from the return keypress that submits the user’s input. Fortunately, the handy .chomp method does exactly what we need — if there’s a \\n at the end of a string, it will remove it; if there isn’t, it does nothing. So, in practice, when we call gets we almost always tack a .chomp on to it immediately. Try modifying the program to: their_name = gets.chomp and see how it’s different. 1.3.5 Conclusion That’s about all we’ll need to know about strings to do most anything related to web applications! Next, we’ll take a look at numbers, starting with Integer. "],["ruby-practice-string.html", "1.4 Ruby Practice: String", " 1.4 Ruby Practice: String Notes: Copied from project README: https://github.com/appdev-projects/string-chapter There is an un-transcribed video associated with String that serves as review of the [Technical Setup][Technical Setup]. This video should be integrated here. Run your Ruby file by typing ruby and then the name of the file you want to run in the Terminal. If we want to run string_multiplication.rb, we can write the command: ruby string_multiplication.rb To re-run this command, you can use the UP and DOWN arrow keys to look at the history of commands you’ve run in a Terminal. 1.4.1 string_multiplication.rb Should output: &quot;HoHoHo&quot; using String multiplication. (Don’t just print the String literal \"HoHoHo\") 1.4.2 string_case.rb Should output: &quot;HELLO friends AnD FaMiLy&quot; using a combination of the upcase, downcase, and swapcase methods. 1.4.3 string_chomp.rb Shoud output: &quot;Hello!&quot; using the given starting variable. 1.4.4 string_gsub.rb Should output: &quot;put spaces in between these words&quot; using the given starting variable. 1.4.5 string_strip.rb Should output exactly &quot;remove the outside spaces&quot; using the given starting variable. 1.4.6 string_gets.rb Write a program that gets a name (e.g. “alice”) from the user, capitalizes it, and then says “Hello, Alice!” Should work similarly to the following: &quot;What&#39;s your name?&quot; jelani &quot;Hello, Jelani!&quot; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
