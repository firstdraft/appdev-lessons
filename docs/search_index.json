[["index.html", "AD1 Preface", " AD1 Ben + Raghu 2023-01-13 Preface This document is originally based on a chronological outline of the AppDev course content, from the Canvas material for “BUSN 36110 81 (Summer 2022) Application Development”. "],["planned-lms.html", "Planned LMS", " Planned LMS This is the basic outline of a “Lesson” in the planned LMS app, including the syntax for LTI placement and quiz questions class Person attr_accessor :first_name, :last_name def full_name &quot;#{first_name} #{last_name}&quot; end end Bullets More bullets A paragraph. LTI{Launch the tool}(https://lti-provider-example.herokuapp.com/lti_tool)[test]{secret}(20)[foo]{400} Bullets More bullets LTI{ }(https://lti-provider-example.herokuapp.com/lti_tool)[test]{secret}(10)[bar] Choose one First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option This is not correct because of xyz reason {: .choose_best #bin points=“30” answer=“3” } Choose all that apply First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option That’s right! Because of xyz reason {: .choose_all #baz points=“30” answer=“[3, 4]” } "],["outline-notes.html", "1 Outline Notes", " 1 Outline Notes Although originally based on the chronological assignments on Canvas in “BUSN 36110 81 (Summer 2022) Application Development”, this book has some re-ordering. "],["updated-diátaxis.html", "1.1 Updated Diátaxis", " 1.1 Updated Diátaxis Update: in the original outline, sections were tagged with the type. We don’t need to be so strict, but we should adhere to some rules of thumb Terminology and code syntax should be collected in technical reference glossaries Video tutorials should not digress too much into explanations and generalizations How-to written guides and accompaniments to videos should be concise, with code that can be copy-pasted Explanations are room to expand on ideas and digress 1.1.1 Original Outline Diátaxis In an effort towards Diátaxis, the content is identified by small chunks of material with tags: da=“Tutorial” pratical-study quadrant practical guided tutorials that produce meaningful results avoid abstraction, generalization, explanation, choices da=“HowTo” pratical-work quadrant similar to tutorial, but more concise with no digression or teaching da=“Explain” theoretical-study quadrant understanding-oriented discussions referring to big-picture topics include concepts, connections, abstraction, generalzation, alternatives, optional readings da=“TechRef” theoretical-work quadrant indexes, glossaries, dictionaries pure information, concise, no ambiguity, provide examples da=“Exercise” our own this is not part of the cannon, but we add it The “TechRef” (glossaries) and “Exercise” (quizzes + projects) tags are obvious, so content in these categories is not explicitly labelled in the outline. Note, the difference between “Tutorials” and “HowTo” here. They are distinguished by the user needs: study (“Tutorial”) vs. work (“HowTo”). Tutorials provide a learning experience, how-to-guides help the user accomplish a task. Any video walkthroughs are “Tutorials” and their written accompaniments are “HowTos”. How-to-guides should never be videos, because a user should be able to quickly refer to what they need, without buffering or scrubbing. "],["technical-references-code-vs.-terminology.html", "1.2 Technical References: Code vs. Terminology", " 1.2 Technical References: Code vs. Terminology There are two types of technical references. One is for terms, the terminology reference, which can be related to specific programming languages, however, any examples of HTML tags, Ruby methods, etc. should go into the code reference. There is one code reference for each subject area: HTML+CSS, Ruby, etc. Both of these glossaries could be built up through the class, meaning the students would only see the most recent terms and those introduced previously. By the end, this is a long glossary sectioned by course units. These code references already exist: Ruby: Ruby Foundations Slides the-one-reference.md optional-syntaxes-in-ruby.md HTML + CSS: HTML + CSS Recap Slides html-reference.md html-cheatsheet.md classbook.md "],["whats-missing.html", "1.3 What’s missing?", " 1.3 What’s missing? Running list of things TODO: The location(s) of the technical references (“TechRef”), and how they are built up, currently found in glossaries. Command-line basics could just be a short “Tutorial” video along with a “TechRef” of all the commands shown in the course place to explain directory structure and filepaths Dedicated video + text content of technical setup. Gitpod and github accounts, opening gitpod workspace, tab organization, /git commiting, rails grade, etc. Can be done with “RPS HTML” or “String” as example. See [Gitpod Technical Setup]. Dedicated video + text content of gems and Gemfile (and maybe bundle). This is found throughout content right now. CSS reference, there is some here: classbook.md Text doc with “keyboard magic” commands (e.g., TAB completion, opening/clearing terminal). Dedicated video + text for ideas.firstdraft.com with domain model for OfferUp. See [Domain Modeling] Video tutorial for https://association-accessors.firstdraft.com/. This is in the last 10 minutes of Day 7 recording right now. Maybe a dedicated chapter for belongs_to, has_many, scope, through, and use of .joins() for queries. Dedicated video + text content for starting from scratch, generator resources, and migration. This is spread across videos (e.g., Day 7 video, Day 8 short video, Photogram and MSM signin), chapters (e.g., active-record.md, draft-generators.md, draft-account.md), classroom examples (Day 8 recordings). See [Starting from Scratch with Generators] API videos for Mailgun, Twilio, etc. Print stylesheet applied to any lesson to make hard copies (pdf) Heroku alternative video / writeup "],["course-overview.html", "2 Course Overview", " 2 Course Overview Notes: Non-transcribed video: Day 1 Recording Video content: Bird’s Eye View Slides Each slide section could be a separate video+text 01-09: Course intro 10-15: What does it mean to know how to code? 16-21: SaaS 22-26: URLs 27-33: Raghu’s journey 34-40: How learning SaaS has evolved 41-46: Ruby on Rails, Play the whole game 47-49: Teaching team 50-79: Record keeping (history, tables, databases, domain modeling, CRUD) 80-88: Must See Movies example relational database tables "],["course-intro.html", "2.1 Course intro", " 2.1 Course intro "],["what-does-it-mean-to-know-how-to-code.html", "2.2 What does it mean to know how to code?", " 2.2 What does it mean to know how to code? "],["saas.html", "2.3 SaaS", " 2.3 SaaS "],["urls.html", "2.4 URLs", " 2.4 URLs "],["etc.-from-slides.html", "2.5 etc. from slides", " 2.5 etc. from slides "],["technical-setup.html", "3 Technical Setup", " 3 Technical Setup Notes: These steps are done in the RPS HTML content (original video), and String exercise (original video) This is a place to collect dedicated how-to-guides to refer students back to Dedicated video tutorials would be helpful here as well Project: N/A Target: N/A Useful chapters: day-2-notes.md getting-started-with-gitpod.md rails-grade.md fixing-your-organization-permissions.md gitpod-snapshot.md hard-reload.md using-git-to-experiement-and-save-work.md tips-and-tricks.md "],["setting-up-accounts.html", "3.1 Setting Up Accounts", " 3.1 Setting Up Accounts Notes: sections from day-2-notes.md 3.1.1 Get a GitHub account Sign up for a free GitHub account at github.com/join I recommend using your .edu email address, as that will qualify you for some discounts and coupons that you might want to use later. Remember to verify your email address after signing up. If you already have a GitHub account, I recommend making a new one for this class, because some of the tools that we use will ask for permission to view all of your repositories. If you have access to e.g. private work repositories, then you should make a new account and keep things separate. 3.1.2 Get a Heroku account Sign up for a free Heroku account at signup.heroku.com If asked what your primary development language is, say Ruby. You can use any one of your email addresses, but remember to verify it. 3.1.3 GitHub and Heroku readings While you’re waiting for everyone to finish creating accounts, read up on GitHub and Heroku. Think of question: Read about GitHub: http://bit.ly/2skLlYx Read about Heroku: http://bit.ly/2uLVTAP "],["gitpod.html", "3.2 GitPod", " 3.2 GitPod Notes: sections from getting-started-with-gitpod.md, tips-and-tricks.md, and hard-reload.md can use RPS HTML as example should include forking, workspace layout, bin/server, tab management could be chance to talk about file structures and terminal 3.2.1 Getting Started With Gitpod One of the most painful parts of learning how to program, in the old days, was simply setting up your computer to be able to write and run code. At a minimum, we needed to install: An application to write your code with. Something like Microsoft Word is not be ideal for writing code, since code needs to be plain text (just a series of characters in a file, nothing else) for the computer to understand it. Word is designed to write rich text (for humans) with fonts, colors, sizes, margins, layouts, etc. Computers come bundled with some plain text editors (Notepad, TextEdit, etc) but they are very basic. We would instead prefer to use powerful tools specifically designed for writing code with like Microsoft’s VSCode or JetBrains’ RubyMine. Ruby itself. Writing code is not useful on its own if we don’t have something to run it with; just like we need a browser installed to interpret .html files we need Excel installed to interpret .xls files, and we need Photoshop installed to interpret .ps files, we need Ruby installed in order to interpret the .rb files that we write. Not only that, we need the correct version installed. If your computer happened to come with an older version, upgrading to a newer version could be complicated — especially if some other application you use depends on the older version. There are so many different combinations of hardware, operating systems, previously installed software, permission levels (for example if you are using a work-owned computer), that just getting these things installed would often stop you before you started writing your first program. We can’t allow that! Instead, we’re going to use a write our code using a cloud computer. “Cloud” just means that it’s a computer that’s sitting in someone’s warehouse1 somewhere, and we rent it from them. It already has all of the software that we need installed on it, and we access it through our browsers. No muss, no fuss! Gitpod.io is a great new service that provides instantaneous, full-fledged cloud development environments from any codebase that is on GitHub.com — which is great, because we (and 98% of other teams) use GitHub to store all of our projects, homeworks, etc. The text editor they provide is based on Microsoft’s VSCode — my editor of choice. It will have the exact right version of Ruby, Rails, and everything else we need. And they have a very generous free tier. Great! Sign up for a Gitpod.io account. It will ask you to sign in using your GitHub account. We will create a workspace for each project that we work on. Each workspace is based on a GitHub repository (i.e., a folder with some code in it). For example, here is a repository: https://github.com/appdev-projects/helloruby To create a Gitpod workspace based on a repo, in the address bar of your browser enter https://gitpod.io/# and then the URL of the repo. For example, https://gitpod.io/#https://github.com/appdev-projects/helloruby To make that process easier, Gitpod has a browser extension that you can install if you want to. Typically, we will assign you a project in Canvas. The assignment will include a button that says “Load assignment in a new window”. When you click on that button, it will create a fork (i.e. a copy) of the repository (i.e. the folder of code) on your own GitHub account. You will then create a Gitpod workspace2 based on your fork, so that you can save the work that you do back to your own GitHub account. A button to create your Gitpod workspace will appear within the assignment, so usually all you need to do is click on it after clicking “Load assignment in a new window”. And then you can get right to work, with the exact right version of all of the project’s dependencies ready to go! 3.2.2 Forcing Chrome to “Hard” Refresh Sometimes, when we update a CSS stylesheet, our page appears not to change. This is especially frequent when we’re working on static HTML files in the public/ folder. The cause is usually Chrome’s aggressive “caching”, i.e. re-using static assets that it has already downloaded (for performance reasons). If we refresh an HTML page that we’ve updated, Chrome won’t necessarily also refresh all &lt;link&gt;ed CSS files — unless we ask it to by “hard” refreshing. To do so: Open the Dev Tools… from the View &gt; Developer menu or right-click on any element and Inspect or press F12 or Ctrl+Shift+J (on Windows) or Option+Command+J (on Mac) Right-click on the refresh button. Select “Empty cache and hard reload”. Open Dev Tools: With Dev Tools open, “hard” refresh: Your HTML document should now have the latest CSS and any other linked assets (like images or javascripts). 3.2.3 Gitpod keyboard shortcuts and other productivity tips 3.2.3.1 Important Terminal keystrokes to know 3.2.3.1.1 Jump to beginning of line You can’t use your mouse at the command line, so it’s important to know how to move around quickly so you’re not restricted to just using your arrows. Jump back to the beginning of the line with Ctrl + A: 3.2.3.1.2 Jump to end of line Mac OS, Windows: Ctrl + E 3.2.3.1.3 Up and down arrows to scroll through your history Use your up and down arrows to scroll through your command history so that you don’t have to re-type your commands over and over. 3.2.3.1.4 Clear Terminal Mac OS: Command + K Windows: Disabled by default3 From the menu open Preferences and select Keyboard shortcuts. Then search for “terminal clear” in the search bar and click the plus icon to the left of it. Finally, type ctrl + k and Enter to confirm. 3.2.3.1.5 Interrupt command If something goes wrong with a terminal program (i.e. you made a typo, a program gets stuck in an infinite loop, etc), you can generally interrupt it with Ctrl + C: 3.2.3.1.6 Q to exit When the output of a terminal command is too tall for a terminal tab to display at once, it paginates. Press Space to step through it one page at a time, or Q to quit and get back to the terminal prompt so that you can execute your next command. Mac OS, Windows: Q 3.2.3.2 Editor keyboard shortcuts 3.2.3.2.1 Command Palette The most important thing to memorize is how to open the Command Palette, which will allow you to fuzzy search within for all other commands. If the command has a keyboard shortcut mapped to it, the shortcut will be displayed to the right. This is the best way to learn the keyboard shortcuts for the commands that you use most frequently. Mac OS: Command + Shift + P Windows: Ctrl + Shift + P 3.2.3.2.2 Quick open file To quickly jump to a file: Mac OS: Command + P Windows: Ctrl + P And then fuzzily search for its name. For example, you could type “phco” to get to photos_controller.rb and the list would quickly narrow to bring that file to the top of the list. 3.2.3.2.3 Toggle Code Comment To quickly comment a line of code, put your cursor on that line and then: Mac OS: Command + / Windows: Ctrl + / You can also highlight multiple lines of code and comment/uncomment all of them at once. 3.2.3.2.4 Find (and replace) Mac OS: Command + F Windows: Ctrl + F 3.2.3.2.5 Find Next Selection Mac OS: Command + D Windows: Ctrl + D If you go too far by mistake, you can step backwards with Command + U or Ctrl + U. 3.2.3.2.6 Move line Mac OS: Option + ⬇ Windows: Alt + ⬇ 3.2.3.2.7 Duplicate line Mac OS: Shift + Option + ⬇ Windows: Shift + Alt + ⬇ 3.2.3.2.8 Add/Remove Tab spaces for multiple lines Mac OS: (Shift) + Tab Windows: (Shift) + Tab 3.2.3.2.9 Add More Cursors Mac OS: Option + Click Windows: Alt + Click 3.2.3.2.10 Embedded Ruby (ERB) Tag Toggle Mac OS, Windows: Ctrl + Shift + ` 3.2.3.2.11 Toggle Terminal Panel Mac OS: Command + J Windows: Ctrl + J 3.2.3.2.12 Open New Terminal Mac OS: Ctrl + ~ (i.e. Ctrl + Shift + `) Windows: Ctrl + ~ (i.e. Ctrl + Shift + `) A warehouse full of computers that people rent and connect to via the internet is called a “data center”. Some data centers have their own power plants, and some are even earthquake-proofed.↩︎ Gitpod will delete an inactive workspace after 14 days. If you want to save the changes you’ve made for longer, you can “pin” a workspace in Gitpod which will prevent it from being deleted. Even better, you can push your changes to Github.↩︎ A recent Gitpod update removed this keyboard shortcut for Windows, so you’ll need to configure it yourself.↩︎ "],["git.html", "3.3 Git", " 3.3 Git Notes: sections from using-git-to-experiement-and-save-work.md 3.3.1 What Git is Git is an extremely powerful version-control system created by Linus Torvalds in 2005 for development of the Linux kernel, which is one of the largest open-source software projects in existence. It makes it possible for large numbers of contributors to work on various features, all within a single codebase (which could be comprised of hundreds or thousands of files). Bitbucket, GitLab, and especially GitHub (all private companies) rode the rise of Git (the protocol) to become the center of the software development universe. All of these companies basically offer cloud-based storage for codebases using Git for version-control (we refer to these codebases as repositories), as well as a web-based interface for collaborating on them — following, commenting, etc. 3.3.2 Why we care In this course, we’re going to use one simple but effective Git-based workflow to save versions of our work. This will allow us to freely experiment with different approaches, while never having to throw away code. In all of our Rails apps, after you start the server, you can navigate to the address /git in your live application. If you’re using Gitpod, the URL will look like: https://[YOUR GITPOD WORKSPACE URL].gitpod.io/git That will open a page that looks like this: As soon as you make any changes to any of the code in the project, and refresh this page, the lines that you changed will appear: On the left, you see the code as it was previously; on the right, you see the new code. Lines added are highlighted in green, lines removed are highlighted in red. Below, there are two things you can do: commit your changes on the left, and switch to a new branch on the right. When you hear the word “commit”, think “snapshot”. When you hear the word “branch”, think “version”. A Git commit is a snapshot of all of the folders and files in your project at a particular time. Since our files of code are all interdependent, it doesn’t make sense to save versions of individual files — we need to know the entire state of the project for a version to be useful. Each branch (“version”) is a series of commits (“snapshots”). The most important thing for you to remember is simple: commit early and commit often. As long as you are taking snapshots of your work at various points, it will always be easy to get back to a previous state in case you want to start over and explore a different approach. To commit, enter a title for the snapshot (required), and, optionally, a longer description: After you commit, you will no longer have any pending changes: If you edit your code again, then you can make further commits. Fundamentally, that’s all you need to worry about: just make lots of commits as you work. The best time to commit is right after you just got something to work, before you start on your next experiment. Remember: ABC: Always Be Committing. 3.3.3 Jumping back in time In the History dialog at the bottom, you can see a list of all of the commits you’ve made. If you want to jump back in time to one of them, copy the 7 letter code (known as the “hash” of the commit; it is a unique identifier) in front of it into the “Branch off of” field above. Pick a name for a new version, and click “Create a new branch off of…”. It will snap all of the files in the project back to that point in time, and you can now make further commits along a new path — while still retaining all of your old commits on the old path. You can easily jump to any commit from any branch at any time — so feel free to experiment! Make a commit to save your current work, then jump back to a previous commit to try a different approach. 3.3.4 Switch to a Different Branch Have you gone back in time and decided your first attempt was better? Turn your attention to the “Existing Branches” panel on the right. This will list any branches your project has— master is the default starting branch. To switch to a different branch, click the blue double arrow button next to the name of the branch you want to switch to. If you’re ever unsure of what branch you’re on, the top of the page should list “On branch ___”. 3.3.5 Push to GitHub Gitpod workspaces are not permanent. Even if we make git commits, if the workspace is deleted so is all of our work! This is where GitHub comes in. We can push all of the commits we’ve made to our repository on GitHub where it will live forever. If our Gitpod workspace gets destroyed we can just re-create another one from the latest commit on GitHub! Before you can push to GitHub, you need to give Gitpod access. Head over to the Integrations under your account settings in Gitpod and make sure you check “public repos” and click “Update”. This should open a GitHub authorization dialogue. Make sure to click “Grant” next to the GitHub organization you created for class Now you should be all set to push your commits to GitHub! "],["rails-grade.html", "3.4 rails grade", " 3.4 rails grade Notes: sections from rails-grade.md, fixing-your-organization-permissions.md, and gitpod-snapshot.md kind of awkward placement, this video and text could go early in RPS HTML video manually checking work, rails grade, git commiting 3.4.1 Getting automated feedback with rails grade 3.4.1.1 Join GitHub If you haven’t already, sign up for a free GitHub account (or sign in to yours if you already have one): In this example screenshot, I chose a username of demolearner1 — remember yours. Also, don’t forget to check your email and verify the address you entered. For now, think of GitHub like Dropbox-for-programmers; it’s where we’re going to store all of our code. 3.4.1.2 Create GitHub organization To keep things organized, we’re going to create a separate GitHub organization account for you to store your AppDev projects under (to keep them separate from the personal projects that you’ll hopefully be building soon!). Click the + on the right side of the navbar and select “New organization”: Choose any name for the organization; most students choose [YOUR USERNAME]-appdev. In this example screenshot, I chose demolearner1-appdev: You can “Skip” or “Finish” the rest of the screens: 3.4.1.3 Login to Canvas Open up the Assignments tab and make sure they’re sorted by type. Scroll down to the assignment you want to start and click the link that says ‘Load [your assignment name] in a new window’ (the name of the project will vary). Before you click “Authorize”, make sure to click the “Grant” button next to the organization that you created earlier. Only then, click authorize to allow the firstdraft Grades application to access your account. Select the name of your GitHub organization and submit the form. The next screen will ask you to accept an invitation to a GitHub team. You can click the link on that screen to accept, or you’ll have an invitation in your email inbox as well. Once you’ve joined, you should see feedback that you’re now a member of appdev-projects: 3.4.1.4 Daily workflow The stuff above about setting up your organization and permissions was just a one-time thing. From now on, you’ll just head to Canvas and click “Load assignment in a new tab”. You should see something like the following (the name of the project will vary): We will automatically make a copy (a “fork”, in GitHub parlance) of the repository under your new GitHub organization. Then, you can choose to either “Create new workspace in Gitpod” or head to your “Gitpod Dashboard” to view existing workspaces. Either way, once you’re in the workspace, we can get the project loaded up and try out the feedback feature. After the bin/setup script is done running, start working on the project to do whatever the instructions tell you. When you’re ready for feedback, try a new command at a new Terminal prompt: rails grade You’ll be asked for your access token; copy-paste it carefully from the grades.firstdraft.com page that you loaded from Canvas. You should see output that looks like: Copy-paste the Results URL into a new tab, or click on it (but make sure it isn’t truncated). (Some projects aren’t graded; in that case there may only be one dummy test listed.) You can click on one of the tests to get more feedback on what might have gone wrong: In this case, the test expected to find an element with a class of word_count that contains the number 10, but instead it only found the content “Replace this string with your answer”. You can click the “Examine Test” button to read the actual Ruby of the automated test; it’s surprisingly readable. Ruby’s testing libraries use method names that are supposed to make tests readable even for non-technical managers and clients. You can see specifically what flow is being tested and what inputs are being used and what the expected output is, and try to reproduce the issue in your own app manually using the same inputs. You can run rails grade in your Terminal as many times as you want, and you will get a new updated build report each time. It will only report your highest score back to Canvas. Remember that your first job is always to make your app work as described and test it manually yourself. You should not rely exclusively on the automated tests; they are a terrible way to debug. 3.4.2 Fixing your organization permissions Once upon a time, we all created our own GitHub organizations to keep our classwork separate from our personal projects. Since then, whenever we gave permission to a third-party (like Gitpod or grades.firstdraft.com) to access our GitHub accounts, we were supposed to remember to grant access to our organization too. If you forgot to click “Grant” next to the organization that you created before you clicked “Authorize”, you’re going to run into problems. Let’s fix it. Go to GitHub and sign in. In this example, I am signed in as the user demolearner1. Click on the user icon in the top-right and find “Settings”: Next, click on “Organizations” in the left sidebar: Find the organization that you created. You likely picked a name like [YOUR USERNAME]-appdev: Next, go to the Settings of the organization: In the left sidebar, find “Third-party access”: If it says that you approved both, then you are good to go and you can go to the next section. If neither Cloud9 nor Grades appears in this list, click the “Remove restrictions” button instead and you can go to the next section. If it says that access is Denied next to Cloud9 or Grades, then proceed. Click on whichever one you denied and Grant Access: You should see a message confirming that access has been granted: Repeat for the other third-party app if necessary. 3.4.2.1 Make sure that you’ve accepted your team invitation Visit this page and make sure that you don’t have a banner across the top asking you to accept our team invitation. (This invitation was sent a while ago via email; if you’ve already accepted it, the banner won’t appear.) 3.4.2.2 Launch an assignment from within Canvas Head back to Canvas and click on whichever assignment you want to work on again (don’t just refresh it if you already had it up). You might be asked to enter your organization name — be sure to enter your organization name, the one you created; not appdev-projects. 3.4.2.3 Resetting OAuth permissions to square one If for some reason you need to make a single-sign-on provider (like GitHub, Twitter, or Facebook) “forget” that you ever authorized a third-party app, maybe because you don’t use it anymore or maybe because you want to change the permissions that you gave it, you need to delete or revoke the “access token” that you previously issued to it. In the case of GitHub, go to your personal settings: Find “Applications” in the left sidebar: Click the “Authorized OAuth Apps” tab and then click “Revoke” next to whichever one you want to “forget”: Then, return to the third-party app and “Sign in with…” again to start over from scratch. In our case, click on an assignment from within Canvas again to re-start the authorization process — and this time don’t forget to grant access to the organization that you created. 3.4.3 Sharing a Gitpod Snapshot It’s often helpful to share a snapshot of the state of your entire Gitpod workspace with someone else. 3.4.3.1 Take the snapshot From the hamburger menu in the top-left corner of your IDE, select Gitpod: Share Workspace Snapshot: 3.4.3.2 Copy the snapshot URL It will take a moment to create the snapshot. Then a dialog will pop up in the bottom-right corner that will give you the URL to copy and share: 3.4.3.2.1 The correct URL looks like this The URL that you share should look something like this: https://gitpod.io#snapshot/5a47e40d-e279-44e5-96bc-ae33cd48f151 Note the #snapshot fragment of the URL. That means you have the right one. 3.4.3.2.2 Not this The URL should not look something like this: https://ac1bde40-34e8-421d-a102-6425971fb9db.ws-eu38.gitpod.io/ That is the URL of your own IDE, which no one else can access. 3.4.3.2.3 Or this The URL should not look something like this: https://3000-ac1bde40-34e8-421d-a102-6425971fb9db.ws-eu38.gitpod.io Note the 3000- at the start. That is the URL of the live preview of your app. 3.4.3.3 Snapshots are completely independent When someone clicks on the snapshot URL, they will get their own private copy of your workspace in the state that it was in when you took the snapshot. Any changes they make to their copy will not affect your workspace. Similarly, any changes you make to your workspace won’t affect their snapshot. So you can keep trying to resolve the problem on your own, or work on the next task, without interfering with their snapshot. "],["rock-paper-scissors-html.html", "4 Rock, Paper, Scissors HTML", " 4 Rock, Paper, Scissors HTML Notes: The video is not yet transcribed and may change GitPod setup is contained in the video. This is an applied example and the Technical Setup chapter can be referred to as a how-to guide. Project (graded): https://github.com/appdev-projects/rps-html Target: https://rps-html.matchthetarget.com Useful chapters: html-reference.md html-cheatsheet.md "],["video-segment-1st-bite-size-chunk-of-rps-html.html", "4.1 Video Segment: 1st bite-size chunk of RPS HTML", " 4.1 Video Segment: 1st bite-size chunk of RPS HTML 4.1.1 Text Companion: 1st bite-size chunk of RPS HTML "],["video-segment-nth-bite-size-chunk-of-rps-html.html", "4.2 Video Segment: Nth bite-size chunk of RPS HTML", " 4.2 Video Segment: Nth bite-size chunk of RPS HTML Notes: The pattern repeats 4.2.1 Text Companion: Nth bite-size chunk of RPS HTML "],["finish-and-submit-rps-html.html", "4.3 Finish and Submit RPS HTML", " 4.3 Finish and Submit RPS HTML Notes: Refer students to rails grade, git, and Sharing a Gitpod Snapshot sections for how to get help "],["deploying-to-heroku.html", "5 Deploying to Heroku", " 5 Deploying to Heroku Notes: This could be a sub-section in Technical Setup The video is not yet transcribed and may change Project: N/A Target: N/A Useful chapters: deploying-to-heroku.md See Canvas "],["rock-paper-scissors-css.html", "6 Rock, Paper, Scissors CSS", " 6 Rock, Paper, Scissors CSS Notes: The video is not yet transcribed and may change Project (ungraded): https://github.com/appdev-projects/rps-css Target: https://rps-css.matchthetarget.com/rock Useful chapters: classbook.md#styling-with-css, but this is outdated? "],["video-segment-1st-bite-size-chunk-of-rps-css.html", "6.1 Video Segment: 1st bite-size chunk of RPS CSS", " 6.1 Video Segment: 1st bite-size chunk of RPS CSS 6.1.1 Text Companion: 1st bite-size chunk of RPS CSS "],["video-segment-nth-bite-size-chunk-of-rps-css.html", "6.2 Video Segment: Nth bite-size chunk of RPS CSS", " 6.2 Video Segment: Nth bite-size chunk of RPS CSS The pattern repeats 6.2.1 Text Companion: Nth bite-size chunk of RPS CSS "],["relationships.html", "7 Relationships", " 7 Relationships Notes: This was in-class work from the un-transcribed Day 2 recording Records and Relationships Slides 01: Get to know each other 02: Types of associations "],["practice-identifying-relationships.html", "7.1 Practice Identifying Relationships", " 7.1 Practice Identifying Relationships Notes: Records and Relationships Slides 03-25: Practice identifying relationship 26: ERD &amp; Ideas Slides (but this doesn’t actually come next) "],["html-css-stylesheets-and-design-recap.html", "8 HTML, CSS, Stylesheets, and Design Recap", " 8 HTML, CSS, Stylesheets, and Design Recap Notes: This was in-class work from the un-transcribed Day 2 recording Project (ungraded): Replits HTML and CSS Recap Slides "],["html-recap-and-replits.html", "8.1 HTML Recap and Replits", " 8.1 HTML Recap and Replits Notes: this could all just be in the technical reference for HTML, with Replit exercises following the review Useful chapters: html-reference.md html-cheatsheet.md HTML and CSS Recap Slides 01-05: HTML basics 05-07: HTML Replits "],["css-recap-and-replits.html", "8.2 CSS Recap and Replits", " 8.2 CSS Recap and Replits Notes: this could all just be in the technical reference for CSS, with Replit exercises following the review Useful chapters: classbook.md#styling-with-css, but this is outdated? HTML and CSS Recap Slides 09-13: CSS Fundamentals 14: CSS Fundamentals Replit 15: External style sheets 16: External style sheets Replit "],["stylesheets-recap-and-replits.html", "8.3 Stylesheets Recap and Replits", " 8.3 Stylesheets Recap and Replits Notes: HTML and CSS Recap Slides 20-23, 25-26: Borrowing style sheets 24: Google Fonts Replit 27: Font Awesome Replit 28: Bootstrap "],["design-resources.html", "8.4 Design Resources", " 8.4 Design Resources Notes: HTML and CSS Recap Slides 29: Readings 31-34: Basic rules (mixed in with some Replits) sections from design-resources.md As you go about designing and coding your application’s screens, here are a few things that you may find useful. 8.4.1 Readings I’ve placed them in rough order of my opinion of their value/length ratio. Butterick’s Typography In Ten Minutes 7 Rules for Creating Gorgeous UI - and part 2 Web Design in 4 minutes 8.4.2 Resources 8.4.2.1 Bootstrap Official Bootstrap documentation Everything in one place Bootstrap 5 cheatsheet — Since the official docs are really spread out, this cheatsheet can be easier to look through quickly. Bootswatch - Cheating! Great for quick styles while prototyping. The previews are also great for looking through quickly for useful components, almost like the Cheat Sheet above. Shoelace.io - A tool to help you create your Bootstrap grid layout. Premium Bootstrap themes Bootstrap.build Generate your own Bootswatch, essentially. If you don’t have your own brand identity created yet, you can practice by making a UChicago branded theme; see pages 38-41 of the Identity Guidelines. 8.4.2.2 Other design systems Bootstrap isn’t the only design framework in town. Here are a few more, just to give you an idea: Tailwind CSS — Imagine if Bootstrap only had utility classes, like the ones for spacing and shadows, but had a lot more than it does; and no components per se. That’s Tailwind — you’re expected to assemble your own cards, alerts, etc, out of the utility classes. Many people like it because it’s “lighter” than Bootstrap — it gives you the tools to build up your own, custom framework; but you’re still not starting from scratch. GOV.UK Design System and U.S. Web Design System — Government design systems, with accessibility and consistency as paramount concerns. Bulma and Foundation — More direct analogs to Bootstrap. 8.4.2.3 Fonts Font Awesome - Free, CSS-customizable, perfectly scalable icons for almost everything. Google Web Fonts - You’ll want this after reading Butterick’s. Google Web Font pairing inspiration: Typographic Project Beautiful Web Type FontPair Ultimate Google Web Font Pairings 8.4.2.4 Games to get good at CSS CSS Diner — Become a pro at CSS selectors. Useful if you plan to do a lot of web scraping. Flexbox Froggy — Get a better understanding of Flexbox, the reason that positioning things on the web is no longer a nightmare. 8.4.2.5 Stock images Unsplash Stock Up - A search engine for free stock photos. Subtle Patterns - A library of free, tileable, subtle background images. 8.4.2.6 HTML &amp; CSS references HTML validator The CSS Cascade — Learn how CSS specificity rules actually determine which one of competing rules gets applied to an element. HTML5 Element List - An excellent, categorized list of HTML elements. CSS Properties Reference 8.4.2.7 Generators CSS3 Generator - Generate CSS box shadows, text shadows, and gradients. Ultimate CSS Gradient Generator 8.4.2.8 Colors Defining colors in CSS Duo — Curated color pairings Adobe Color - Generate complementary colors. 8.4.3 Quick links to assets BootstrapCDN helpfully host bootstrap.css (and Bootswatches) on their own server. Ultimately, a quick and easy way to get all of Bootstrap and Font Awesome is to include the following in the &lt;head&gt; of your document: &lt;!-- Expand the number of characters we can use in the document beyond basic ASCII  --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- Make it responsive --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- Connect Bootstrap CSS --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;!-- Connect Bootstrap JavaScript and its dependencies --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;!-- Connect Font Awesome --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js&quot;&gt;&lt;/script&gt; You can use a Bootswatch or your own customized bootstrap.css instead as the href, if you like. Have fun! "],["linkinbio.html", "9 Linkinbio", " 9 Linkinbio Notes: No video for this, only chapter Project (graded, submit a link): https://github.com/appdev-projects/linkinbio Target: https://rag.hu/04-layout Useful chapters copied in below: linkinbio.md Some social media apps, in particular Instagram, do not allow you to include links to other pages in posts. The only place you can include a URL is in your bio, and you can only include one. This soon led to a trend of people promoting something with a post, but including “Link in bio!” in the caption. They would then update the solitary link in their bio to the latest thing they wanted to promote. Soon, a bunch of services cropped up that allow people to manage multiple links in a single, mobile-friendly page; and include a link to that page in their bio. The most popular of these is Linktree, but there are many others. Linktree has many users, from media companies to celebrities to, most likely, some of your friends — and maybe even you? Here are some examples: HBO’s Instagram bio: And HBO’s list of links: Katy Perry’s Instagram bio: And Katy Perry’s list of links: In this project, we’re going to build our own mobile-friendly list of links that we can include in our social media profiles or anywhere else that we like. Here’s mine: There are several benefits to writing our own rather than using a service like Linktree: We can use our own custom domain name for it; rather than linktree.com/raghubetina, notice that my URL is simply rag.hu. We don’t have to pay. Linktree has a free tier with limited design options, but if you want access to the fun themes, analytics, or to remove the Linktree branding, you have to subscribe to their $5/mo or $9/mo plan. We have all the power of CSS at our fingerprints to customize the design. Linktree, like all “no code” tools, limits you to a set of pre-defined constraints that you have to work within. Not so if you’re writing the code yourself. For example, if you click through to mine, you’ll notice a lot of touches that aren’t available options even on the paid Linktree plans: an animated background, a “frosted glass” effect on the links, etc. It’s just plain fun! Let’s get started. "],["getting-started.html", "9.1 Getting started", " 9.1 Getting started We’re going to start our projects a little differently this time. Rather than clicking the “Load [assignment] in a new window” button in Canvas, which usually will automatically create your copy of the repository on your organization, you will manually create your own blank Rails app (the same steps you can follow any time you want to build your own, non-assigned projects): Visit our appdev-projects/base-rails repository and click the “Use this template” button. Then select “Create new repository” from the dropdown. On the next screen, leave the “Owner” dropdown alone. For “Repository name”, enter “your-username.github.io”. Substitute your own, real username for your-username. So, for example, my repo name is “raghubetina.github.io”. Make sure to include the “.github.io” part in the repo name. E.g.: Click “Create new repository from template”. Create a new Gitpod workspace based on your brand new repository: In a new tab’s address bar, type “gitpod.io/#”. Then copy-paste the URL of your new repository after that. The URL should look something like gitpod.io/#https://github.com/your-username/your-username.github.io Press return to visit that URL and Gitpod will automatically start creating a new workspace for you. Once you’re in to your new workspace, bin/server at a terminal tab as usual to start up your web server. Open your app preview in a new tab. Create a file called index.html in the public/ folder. Add “hello, world” and make sure that it shows up when you refresh your app preview. "],["first-things-first-the-content.html", "9.2 First things first — the content", " 9.2 First things first — the content To start with, we need content. You’ll probably want to gather: A profile picture for the top of the page. This doesn’t have to be an image of you; it can be anything. Unsplash is a great resource for high quality stock images if you don’t want to use an image of yourself. The URLs of your social media profiles. I used my GitHub, LinkedIn, Instagram, and Twitter pages. A list of links you want to share. I used a handful of essays and short stories that I find myself sharing with people often. Here are some examples that you can peruse for inspiration. A thumbnail image for each link. I used a few strategies to find an image for each link: Search Google images and look for one hosted on wikimedia.org. Searched Unsplash for a relevant image. Generate an image with AI. I downloaded the image and then uploaded it to my Gitpod workspace by drag-and-dropping it into the public/ folder. If you want to, you can use fake placeholder images and links for everything, but I encourage you to gather real content. It’ll be more fun, you’ll end up with a page that you can actually use on your social media profiles, and you’ll have a good piece for your portfolio. "],["basic-html-structure.html", "9.3 Basic HTML Structure", " 9.3 Basic HTML Structure Let’s add our images, copy, and links. I wrapped each block of content in a &lt;div&gt; for now, to create some separation. I also gave each &lt;div&gt; a class=\"\" attribute; since we haven’t written any CSS yet, they don’t do anything, but they help me remember what each &lt;div&gt; represents. Something like this: &lt;div class=&quot;banner&quot;&gt; &lt;img src=&quot;profile-pic.jpg&quot; alt=&quot;Raghu Betina headshot&quot;&gt; &lt;/div&gt; &lt;div class=&quot;name&quot;&gt; Raghu Betina &lt;/div&gt; &lt;div class=&quot;social-icons&quot;&gt; &lt;a href=&quot;https://github.com/raghubetina&quot; target=&quot;_blank&quot;&gt; GitHub &lt;/a&gt; &lt;a href=&quot;https://www.linkedin.com/in/raghubetina/&quot; target=&quot;_blank&quot;&gt; LinkedIn &lt;/a&gt; &lt;a href=&quot;https://www.instagram.com/raghubetina/&quot; target=&quot;_blank&quot;&gt; Instagram &lt;/a&gt; &lt;a href=&quot;https://twitter.com/raghubetina&quot; target=&quot;_blank&quot;&gt; Twitter &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;https://www.ycombinator.com/assets/ycdc/yc-og-image-0cfa80cac837d64d9b4f0705950000b66906ac032791376bd721f246fafcc7b4.png&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://paulgraham.com/startupideas.html&quot;&gt;How to Get Startup Ideas — Paul Graham&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;/thumbnails/typography.jpg&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://practicaltypography.com/typography-in-ten-minutes.html&quot;&gt;Typography in ten minutes — Matthew Butterick&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;link&quot;&gt; &lt;img src=&quot;https://media.newyorker.com/photos/59096d451c7a8e33fb38e4ca/16:9/w_1280,c_limit/071210_r16884_p646.jpg&quot;&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://www.newyorker.com/magazine/2007/12/10/the-checklist/&quot;&gt;A Life-Saving Checklist — The New Yorker&lt;/a&gt; &lt;/div&gt; &lt;!-- Etc, for as many links as you want --&gt; Of course, I also have the standard HTML boilerplate (&lt;html&gt;, &lt;head&gt;, &lt;body, etc) in order to make it a valid document. Two things to notice: I’m using the target=\"_blank\" attribute on any links that I want to open in a new tab. For images that I am serving from my own public/ folder: I created a subfolder called thumbnails to help keep things organized, and moved the images there. When referencing the URL of the image in a src=\"\" attribute, I start with a leading slash — e.g.: &lt;img src=&quot;/thumbnails/typography.jpg&quot;&gt; I do not include /public in the URL. At this stage, your page technically serves its purpose — a collection of links people can click on — but it probably looks terrible, like this. "],["html-validator.html", "9.4 HTML Validator", " 9.4 HTML Validator If at any point your HTML breaks, or you suspect you e.g. forgot a closing tag but can’t find it, the W3C HTML Validator might come in handy. Paste in your entire HTML document and click “Check”, and it will give you a list of feedback. Some of them are yellow warnings and can be safely ignored for now, but any critical mistakes (like missing closing tags or quotation marks) will show up as red errors. For example, if you run your HTML through the validator right now (try it), it will display a bunch of errors because we don’t have alt=\"\" attributes on our &lt;img&gt;s. These are important to include for accessibility reasons, and just in case the image breaks for some reason (i.e. the URL changes). We should add descriptive alternative text for each image. "],["view-source.html", "9.5 View Source", " 9.5 View Source You should try to type out your page yourself — avoid copy-pasting. Making mistakes, fixing them, and developing your own muscle memory is important. That said, after you’ve attempted it yourself, you can View Source (Windows: Ctrl+U or Mac: Command+Option+U) on any of my example intermediate pages to see my code. "],["sizing-images.html", "9.6 Sizing images", " 9.6 Sizing images Now, let’s start to make the page look better. Let’s add a &lt;style&gt; element inside the &lt;head&gt; of the document so that we can begin applying CSS. We won’t use an external stylesheet for now, since we’re only planning to apply this CSS to a single page. Maybe we can start by giving the body some breathing room with top and bottom padding: &lt;style&gt; body { padding-top: 40px; padding-bottom: 40px; } &lt;/style&gt; Let’s start by sizing the profile picture. We need to give it a class so that we can apply CSS rules to it — let’s call it banner-image: &lt;div class=&quot;banner&quot;&gt; &lt;img src=&quot;profile-pic.jpg&quot; alt=&quot;Raghu Betina headshot&quot; class=&quot;banner-image&quot;&gt; &lt;/div&gt; Then, let’s make the banner image 128 pixels by 128 pixels: &lt;style&gt; .banner-image { width: 128px; height: 128px; } &lt;/style&gt; Unless your original image was exactly square, this probably will look squished when you check out the results. To solve this problem, we can use the object-fit property: .banner-image { width: 128px; height: 128px; object-fit: cover; } It’s quite common to see circular profile pictures. If you want to, set a large border-radius to achieve that: .banner-image { width: 128px; height: 128px; object-fit: cover; border-radius: 128px; } I didn’t use one on my profile picture, but you should feel free to get creative with borders, as well. Similarly, let’s size all of the thumbnail images as 48px by 48px: .thumbnail { width: 48px; height: 48px; border-radius: 48px; object-fit: cover; } Don’t forget to add the class to the relevant &lt;img&gt; elements. Now, your page should look something like this — much better. "],["basic-colors.html", "9.7 Basic colors", " 9.7 Basic colors Let’s add some color to make it easier to see how much space each element is occupying. We’ll, at a minimum, need a color for the background of the entire page and for each link. You can come up with your own palette, or you can use Happy Hues, a nice set of curated color palettes. I used this palette. I used the background color, headline color, button color, and button text color like this: body { background-color: #004643; } .name { color: #fffffe; } .social-icons a { color: #fffffe; text-decoration: none; } .link { background-color: #f9bc60; } .link a { color: #001e1d; text-decoration: none; } As you can see, I also removed the underlines from links with text-decoration: none. Notice that I used the descendant combinator: .link a { /* ... */ } This selector targets only &lt;a&gt; elements that are descendants of elements with class link. This is a handy alternative to adding a new class to all of the elements I’m interested in targeting.4 My page now looks like this. If you want to become a pro at writing CSS selectors, I recommend an interactive tutorial/game called CSS Diner. If you make it through all 32 levels, you’ll be better than most front-end developers at writing advanced CSS selectors. In addition to making it easier to style your own pages, knowing how to write advanced selectors will pay dividends if you’re interested in doing any web scraping.↩︎ "],["layout.html", "9.8 Layout", " 9.8 Layout Now, for the interesting part — laying out the elements where we want them on the page. 9.8.1 Overall page layout Since this is a relatively simple, single-column layout, we could stay in the normal flow mode and achieve most of the positioning that we want with margin and padding. But let’s use display: flex instead. It will make it much easier to do things like vertically center the text within each link’s box. First, I’ll wrap all of our content — the div.banner, the div.name, the div.social-icons, and all of the div.links — within a new parent &lt;div&gt; with a class called items. This will make it easier for me to position and size everything uniformly. Then I will switch the layout mode of the new div.items from the default normal flow to flex: .items { display: flex; } If you try that and refresh your page, you’ll see that all of the elements are now horizontally side-by-side. This is because the default flex-direction is row. Let’s switch the flex-direction to column to lay them out vertically again: .items { display: flex; flex-direction: column; } If you refresh, you’ll see the layout is vertical again. When we’re using display: flex mode, we can use the gap property to provide some breathing room between each child element, rather than having to add margin: .items { display: flex; flex-direction: column; gap: 30px; } On laptop screens, the buttons are running all the way to the edge of the screen, which isn’t very attractive. Let’s set a max-width of around 640px (you choose a value that looks good to you): .items { display: flex; flex-direction: column; gap: 30px; max-width: 640px; } 9.8.2 Layout for each link Within each link, it would be nice if: The thumbnail and text were vertically centered within the box. The text was horizontally centered in the space remaining next to the thumbnail. display: flex to the rescue! 9.8.2.1 Vertically centering with align-items We can vertically center child elements with the align-items property: .link { background-color: #f9bc60; display: flex; align-items: center; } If you refresh, the thumbnails should be lined up nicely with the link text. 9.8.2.2 flex-grow Next, let’s center the text of each link. I’m going to expand the existing rule that we have for .link a. Can we simply add text-align: center and call it a day? .link a { color: #001e1d; text-decoration: none; text-align: center; } If you refresh, you’ll see that didn’t work. Why? To make it easier to see things while I am working on layouts, I often use the following hack: * { border: thin red solid; } This puts a thin red border around every element. Your page should now look something like this: We can see that the &lt;a&gt; elements are only just wide enough to fit their content, so centering within them isn’t doing anything. Instead, we want the &lt;a&gt; element to occupy all of the available space to the right of the thumbnail. To achieve, this we can use the flex-grow property: .link a { color: #001e1d; text-decoration: none; text-align: center; flex-grow: 1; } Now the &lt;a&gt; element grows to fill any available space, while the &lt;img&gt; element stays the same size (it still has the default value for flex-grow, which is 0). And our text should be nicely centered since we already added the text-align. 9.8.2.3 justify-content Now let’s take care of centering the profile picture and name, as well as putting some breathing room between the social links. Flexbox has a wonderful property called justify-content that will help with all of these things: .name { color: #fffffe; display: flex; justify-content: center; } .banner { display: flex; justify-content: center; } .social-icons { display: flex; justify-content: space-around; } You could also use the same technique to center the div.items within the &lt;body&gt;: body { display: flex; justify-content: center; } But then we again need to tell the child elements to grow to take up all available space with flex-grow: .items { display: flex; flex-direction: column; gap: 30px; max-width: 640px; flex-grow: 1; } Our page layout should now look solid! Let’s add a little bit of padding inside our div.links: .link { background-color: #f9bc60; display: flex; align-items: center; padding: 5px; } It should now be safe to remove the * { border: thin red solid; } hack, unless you want to continue playing with layout, padding, etc. Our page now looks something like this. "],["deploy.html", "9.9 Deploy!", " 9.9 Deploy! We’ve made a lot of progress, and our list of links is functional and looking pretty solid! We can and will spend more time fine-tuning, but this seems like a great time to deploy our app to industrial-grade hosting so that we can actually link to it in our bios! Sadly, after over a decade, Heroku’s free tier was eliminated as of November 28th, 2022. There are some silver linings — they have launched a new discount through GitHub Student, and they created a couple of new, less expensive plans (Eco, Basic, Mini). For full-stack, dynamic, interactive, database-backed apps, I plan to still use Heroku. However, Heroku is no longer a good choice for hosting static HTML websites. There are several other free and fast options for that (e.g. Netlify and Vercel). Today, I want to show you GitHub’s offering for hosting static websites: GitHub Pages. We will deploy our Link In Bio via GitHub Pages. This will have several benefits: It’s free. It is tightly integrated with GitHub repositories (obviously), so all we need to do to deploy is what we do anyway — make a commit and push to GitHub . It doesn’t have any of Heroku’s old free tier’s restrictions. It will be up 24/7/365. It automatically includes SSL for custom domains (important if you’re using a top-level domain that requires https, like .dev). GitHub Pages sites are automatically assigned a subdomain under .github.io. This carries some developer cred. Or you can easily use your own domain. Here’s what to do to get your first GitHub Pages site going: Visit /git. Make a commit and then push the changes you’ve made so far to your GitHub repository. That’s it! In a few minutes, your site should be live at https://your-username.github.io! Eventually, consider adding some other pages to your site besides just index.html — a list of projects that you’ve built, for example. If you want to use a custom domain name like yourname.com rather than something like your-username.github.io, then you’ll first have to purchase a domain. I recommend Porkbun, or, for more exotic top-level domains, Gandi.net. Here is a guide to adding your own domain to your Pages site. Let me know if you get stuck. You can create as many GitHub Pages sites as you want — one per repo. Read more about GitHub Pages here. "],["this-is-the-end-of-the-required-portion.html", "9.10 This is the end of the required portion", " 9.10 This is the end of the required portion This is the end of the required portion of this assignment. In Canvas, submit the URL of your deployed app (something.github.io, not your GitPod preview). If you are willing to share your creation, please also include “Add me to the showcase” in the submission text area. "],["make-it-your-own.html", "9.11 Make it your own", " 9.11 Make it your own Now that we have the basics up and running, it’s time for you to get creative and make it your own! You can continue to make changes, commit, and push them to deploy. We aren’t grading for anything particular, so just have fun with it. Here are a bunch of resources for you to explore: 9.11.1 Fun design resources The following are a collection of neat tools that will help you create interesting backgrounds, generate gradients and shadows, find font pairings, etc. Glance at each one and pick one or two to integrate into your design. If you want to bounce ideas on things you can integrate, chat with an instructor. Once you’ve picked something to add, try to figure out how to integrate it on your own; ask lots of questions when you get stuck. 9.11.1.1 Icons To use Font Awesome icons (for example, for your LinkedIn/GitHub/Twitter/etc links), first include this in the &lt;head&gt; of your document: &lt;!-- Connect Font Awesome --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/js/all.min.js&quot;&gt;&lt;/script&gt; Then peruse the icon list and copy-paste the code examples into your HTML. 9.11.1.2 Fonts The Ultimate Collection of Google Font Pairings (Displayed Beautifully with Classic Art) Reading: Typography in Ten Minutes 9.11.1.3 Images Unsplash: Search engine for free stock images. Dezgo: AI image generation. Image Optimizer: Reduce your images’ filesize in case they’re taking too long to load. Clippy: Create geometric masks for your images. 9.11.1.4 Color palettes Happy Hues 9.11.1.5 Shadow generators CSS Shadow Palette Generator 9.11.1.6 Gradient generators Vivid Gradient Generator Easing Gradients 9.11.1.7 Patterns CSS Background Patterns Repper Pocoloco 9.11.1.8 Generative art Silk Haikei Tabbied 9.11.1.9 Filters https://css-tricks.com/almanac/properties/b/backdrop-filter/ https://css-tricks.com/almanac/properties/f/filter/ 9.11.2 Always be committing Be sure to make lots of git commits along the way as you work! Have fun ☺️ "],["intro-to-ruby.html", "10 Intro to Ruby", " 10 Intro to Ruby Notes: These are all the pre-class Ruby homework assignments consisting of a reading with Replits, potentially followed by a GitPod exercise. The chapter and project repository is listed in each sub-section. The README from the project repository needs to be integrated here. There is an un-transcribed video associated with String that serves as review of the Technical Setup. Useful chapters: the-one-reference.md "],["nouns-verbs-and-grammar.html", "10.1 Nouns, Verbs, and Grammar", " 10.1 Nouns, Verbs, and Grammar Notes: nouns-verbs-and-grammar.md "],["program-notes.html", "10.2 Program Notes", " 10.2 Program Notes Notes: program-notes.md "],["string.html", "10.3 String", " 10.3 String Notes: string.md setup video Project: https://github.com/appdev-projects/string-chapter "],["integer.html", "10.4 Integer", " 10.4 Integer Notes: integer.md Project: https://github.com/appdev-projects/integer-chapter "],["float.html", "10.5 Float", " 10.5 Float Notes: float.md Project: https://github.com/appdev-projects/float-chapter more-on-floats.md "],["date.html", "10.6 Date", " 10.6 Date Notes: date.md Project: https://github.com/appdev-projects/date-chapter "],["array.html", "10.7 Array", " 10.7 Array Notes: array.md Project: https://github.com/appdev-projects/array-chapter "],["conditionals.html", "10.8 Conditionals", " 10.8 Conditionals Notes: conditionals.md Project: https://github.com/appdev-projects/if-statements-chapter "],["loops.html", "10.9 Loops", " 10.9 Loops Notes: loops.md Project: https://github.com/appdev-projects/loops-chapter "],["each.html", "10.10 Each", " 10.10 Each Notes: each.md Project: https://github.com/appdev-projects/each-chapter "],["hash.html", "10.11 Hash", " 10.11 Hash Notes: hash.md Project: https://github.com/appdev-projects/hash-chapter "],["our-own-classes.html", "10.12 Our own classes", " 10.12 Our own classes Notes: our-own-classes.md Project: https://github.com/appdev-projects/our-own-classes-chapter "],["ruby-gym.html", "11 Ruby Gym", " 11 Ruby Gym Notes: Un-transcribed Day 3 recording contains the following Ruby Foundations Slides: 01-06: Basic recap Here is the Google-Fu Note Ruby Foundations Slides: 07-08: We Are Inventors, Google-Fu Useful chapters: the-one-reference.md Project (graded): https://checkins.firstdraft.com/exercises/1/student "],["optional-ruby-practice.html", "11.1 Optional Ruby Practice", " 11.1 Optional Ruby Practice Notes: See Canvas, links to Treehouse and CodeCademy "],["rock-paper-scissors-rcav.html", "12 Rock, Paper, Scissors RCAV", " 12 Rock, Paper, Scissors RCAV Notes: Original video transcription is in adding-routes-RPS-RCAV.md Project (graded): https://github.com/appdev-projects/rps-rcav Target: https://rps-rcav.matchthetarget.com Useful chapters: adding-routes.md rcav-flowchart.md, not actually zipped in here yet Routing - RCAV Slides "],["video-segment-dynamic-web-applications-and-urls.html", "12.1 Video Segment: Dynamic Web Applications and URLs", " 12.1 Video Segment: Dynamic Web Applications and URLs Notes: time stamp 00:00:00 to 00:03:30 request lifecycle of Route, Controller, Action, View web interface and URLs actions render and redirect We have worked hard and learned HTML, CSS, and Ruby. We’re now especially proficient in writing Ruby programs, especially with the aid of gems and APIs. BENP: have we discussed gems and APIs up to this point though? However, if we (the developers) are the only ones that can run these programs (from the command line through the ruby interpreter), then they aren’t much use. It’s time to start adding a web interface on top of our Ruby programs so that external users can interact with and benefit from them. We already have all the tools to build our first dynamic web application. BENP: need to clearly define RCAV early in any video or document now so we aren’t left wondering, added next sentence. Before we begin building, we need to understand the URL request lifecycle of Route, Controller, Action, View (RCAV). Let’s recall that Software as a Service (SaaS) has eaten the world. What does this mean? For an application that runs on a server and transmits information across the internet, the interface consists of a set of URLs that a user can visit. People can type in a URL, click a link, or submit a form, and then get back some information relevant and valuable to them. Each URL will either display a page with some information (“get” in HTTP terminology) trigger the storing of some information (“post” in HTTP terminology) trigger the deleting of some information (“delete” in HTTP terminology) trigger the updating of some information (“patch” in HTTP terminology) forward to another URL or some combination of the above Our goal was to demistify what happens between the user action and the return of information. Now we have the vocabulary to talk about this. The world turns around the humble Uniform Resource Locator, or URL. Most obviously, the user might be visiting the URLs in their browser by typing into the address bar or clicking on links. Or, more and more commonly, users might be visiting from native iPhone or Android apps without even knowing that, behind the scenes, they are visiting URLs to store and retrieve the information they need. When somebody puts that URL into the address bar, and something happens between the URL and the page being rendered, we now can say what that is. When a user visits a URL, they are actually triggering a specific Ruby method. But make no mistake: if there is information being stored in a central database, then there’s a web server running somewhere and URLs are being visited with each action a user takes. In the background somewhere, there is an object and method and somebody is saying Something.something, and that method is actually going to do the work of drawing the correct page of information with exactly the right information for that user and outputting it in the right format (almost alway HTML). So our job is to write those Ruby methods (called “actions”) and allow users to trigger those methods when they visit each URL. So we can write any Ruby we want in those action methods. We can generate random numbers, read from APIs, calculate things, send text messages, and more. But every action must do one of two things: Render a response, by sending back some HTML and displaying a new page Redirect, or forward the user onward to another URL. And that’s everything that happens between the user visiting a URL and getting a response, and it is now a complete Route + Controller + Action + Response request lifecycle. We map every URL to one Ruby method that we write in advance and then we wire everything together so that Rails will listen for user visits and when someone visits a particular URL, then Rails will call the method we prepared that will handle getting the database information and wrapping it in bootstrapped markup and sending the HTML to the user’s browser. You can fully specify a web application by listing out the URLs that users can visit, and what happens when each URL is visited. For example, let’s say we wanted to build an interactive game of Rock, Paper, Scissors. The complete specifications (or specs, for short) for this app might look like this: http://[OUR APP DOMAIN]/rock — Should display “You played rock.”, a random move by the computer, and the outcome. http://[OUR APP DOMAIN]/paper — Should display “You played paper.”, a random move by the computer, and the outcome. http://[OUR APP DOMAIN]/scissors — Should display “You played scissors.”, a random move by the computer, and the outcome . http://[OUR APP DOMAIN]/ — A welcome page that displays “Happy Monday!” (or whatever day it is). The rules of the game. For example, Happy Tuesday! Rock beats Scissors, Paper beats Rock, Scissors beats Paper. Point your browser at /rock, /paper, or /scissors to play the game. Now — how do we get our web server to perform the above tasks when users visit the above URLs? 12.1.1 Potential Quiz Question First bullet point is the question itself? First option This is not correct because of xyz reason Second option This is not correct because of xyz reason Also not correct because of abc reason Third option That’s right! Because of xyz reason Fourth option This is not correct because of xyz reason {: .choose_best #bin points=“30” answer=“3” } 12.1.2 Text Companion: Dynamic Web Applications and URLs "],["video-segment-route.html", "12.2 Video Segment: Route", " 12.2 Video Segment: Route Notes: time stamp 00:03:30 to 00:07:10 all about routing and config/routes.rb get() The key thing is routes. Routes are how to connect a URL to an action. The very important file config/routes.rb contains all of our routes. This is a list of everything our application can do. We’re moving out of our public/ and tasks/ folder, and using more of our Rails application, by working in the app/ folder, where most of our code goes, and with this one file routes.rb that is in the config/ folder. The super important config/routes.rb file included in every Rails app says all the URLs (routes) that a user can visit and when someone visits the URL we say which class and which method Rails should execute to handle the request. Here is an example of a route: # config/routes.rb self.get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) The method here is get5 and there are parentheses for its two arguments: - The first argument to get is a String: the path that we want users to be able to visit (the path is the portion of the URL that comes after the domain name). Here it is \"/rock\" - The second argument to get is a Hash: this is where we tell Rails which method to call when a user visits the path in the first argument. (We’ll have to actually write this method in the next step, after we write the route.) The `Hash` must have two key/value pairs: - `:controller`: The value for this key is what we&#39;re going to name the _class_ that contains the method we want Rails to call when the user visits the path. For now we&#39;re going to default this value to `&quot;application&quot;` — you&#39;ll see why in a minute. - `:action`: The value for this key is the what we&#39;re going to name the method itself. &quot;Action&quot; is the term used to refer to Ruby methods that are triggered by users visiting URLs. - The `Hash` is saying: &quot;Use a `Class` (controller) called `application_controller`, and in that `Class` use a `method` (action) called `play_rock` to generate a response for the user.&quot; Don’t be confused by the key names :controller and :action, these are equivalent to a Ruby Class and method. They just have special names in the lingo of web applications. The get method is inherited, we don’t need to build this method ourselves, which saves us a lot of time. We get the plumbing for free and we just need to tell Rails how we want each request to be handled by declaring our routes. 12.2.1 Text Companion: Route Later we’ll use other methods, post(), etc, if we want to support requests using the other HTTP verbs.↩︎ "],["video-segment-controller-action-view.html", "12.3 Video Segment: Controller, Action, View", " 12.3 Video Segment: Controller, Action, View Notes: time stamp 00:07:10 to 00:08:30 all about app/controllers/ ApplicationController inheritance All of our controller classes will be in the app/controllers/ folder. There’s already one controller that comes with every Rails app out-of-the-box: ApplicationController, found in app/controllers/application_controller.rb. This is the controller that the above route is referring to. We will just use this controller for now. Later we will make separate controllers to keep our code organized. An example of an action looks like this: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def play_rock self.redirect_to(&quot;https://www.wikipedia.org&quot;) end end We get the first line class definition for “free”: class ApplicationController &lt; ActionController::Base It comes with Rails. It inherits &lt; from the Base class which is inside the Rails gem, so we would need to go into the Rails gem on GitHub to actually look at it. BENP: gem has maybe not be defined or discussed yet. possible footnote here. Also this is our first time talking about inheritence, so may need some expansion Then we define a method: def play_rock And inside of that we could write whatever steps we want (like calls to GoogleMaps or weather services from DarkSky BENP: I don’t think either of these have been presented at this point in the class). At the end of the day, the job of an action is to send back a response to the user. A response can be either: Rendering some data, in any one of many formats: Plain text. JSON for an application to consume — we’ve seen JSON before (in APIs), and consumed it ourselves with our Ruby scripts. HTML for their browser to draw — we’ll learn this soon. Less commonly, any other format: CSV, PDF, XML, etc. Or, the action can forward the user to another URL. This is known as redirecting. We get a method for each of these two: render for the first, and redirect_to for the second. In this case, we redirect to another URL: self.redirect_to(&quot;https://www.wikipedia.org&quot;) As you can see, the argument to redirect_to is a String which contains some URL that you want the user to simply be forwarded to. This will come in handy later when, for example, we want to send the user directly back to a list of all photos after they’ve deleted a photo. 12.3.1 Text Companion: Controller, Action, View "],["video-segment-dropping-self..html", "12.4 Video Segment: Dropping self.", " 12.4 Video Segment: Dropping self. Notes: time stamp 00:08:30 to 00:11:00 why we drop self. Just to get something out of the way: Usually we always call object.method, and we are using the self keyword above because we are calling these methods on the instance of the class (ApplicationController) that we are defining the method (play_rock) for. Kind of like when we learned about the Person class and there is first_name and last_name, and if we wanted a full_name method we called self.first_name + self.last_name. In this case we’re defining play_rock and we want use the method redirect which already exists on ApplicationController, since it’s inherited via &lt; ActionController::Base. The point is, we are using a method that already exists to build our new method, hence self.redirect_to. In Ruby, when you’re calling a method on self, you can drop the self., and Ruby will figure it out, so we can rewrite the route, controller, action steps to: # config/routes.rb get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) {: mark_lines=“3” } and # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def play_rock redirect_to(&quot;https://www.wikipedia.org&quot;) end end {: mark_lines=“5” } 12.4.1 Text Companion: Dropping .self "],["video-segment-starting-our-gitpod-workspace.html", "12.5 Video Segment: Starting Our GitPod Workspace", " 12.5 Video Segment: Starting Our GitPod Workspace Notes: time stamp 00:11:00 to 00:13:30 these are common steps that should be done first in any project maybe link to Technical Setup Let’s spin up a workspace and open the RPS-RCAV GitPod so we can visualize the steps and see some results. We’ll finally make our Rock Paper Scissors game work, by having the computer opponent randomly choose a move rather than always playing paper. We will then be able to compute outcomes based on the computer’s move. Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project here, looks similar to what we have produced, but the key is that the computer plays different moves, and the application is finally dynamic. So how do we get here? 12.5.1 Text Companion: Starting Our GitPod Workspace "],["video-segment-our-first-rcav.html", "12.6 Video Segment: Our First RCAV", " 12.6 Video Segment: Our First RCAV Notes: time stamp 00:13:30 to 00:18:40 debugging an RCAV for /rock RTEM ends with redirect_to Our workflow for a dynamic web application is always the same: Route, Controller, Action, View (RCAV). Remember, the world is ruled by URLs. So we will always start with what URL we want to build and get it to work. If we begin by navigating to the route /rock in our Rails browser: http://[YOUR APP DOMAIN]/rock, then we get an error message: No route matches [GET] “/rock”. We need to Read The Error Message (RTEM) and define the first route that will allow us to support a request of the form for our users. Let’s open the file config/routes.rb and define the route by adding the following code: # config/routes.rb Rails.application.routes.draw do get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) end {: mark_lines=“5” } (All of our routes must be contained within the block following Rails.application.routes.draw. A new Rails app will already come with this code pre-written in routes.rb.) Again, we have our route \"/rock\" and our key/value pairs for the :controller (or Class) and :action (or method). We need to choose values for the :controller that Rails will use and the :action within the controller that will be called. For now we are just using the app/controllers/application_controller.rb for the controller, and we will define our action play_rock in there. We now need to open app/controllers/application_controller.rb to add some code. Note that Rails is smart and will add _controller.rb to our :controller argument in get, and within that controller file you will see the class has the underscores removed and is capitalized as ApplicationController. These are helpful conventions, and are best followed. BENP: is that last thing a fair statment? In this file we will add the following: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock end end {: mark_lines=“9-10”} We need our action to exactly match what we wrote in the config/routes.rb file, here play_rock. Between the def play_rock and end that we added, we could put whatever and however much code we would like to execute in that action for the user. In the end we will need to either render some HTML back to the user or redirect the user to another place. Let’s begin by just redirecting to some other URL: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here redirect_to(&quot;https://www.wikipedia.org&quot;) end end {: mark_lines=“10-12”} And we just created a full RCAV request lifecycle. If we go back to the browser and refresh the URL: http://[YOUR APP DOMAIN]/rock, then we will end up on Wikipedia. If I go back to GitPod and look in my server log (use Cmd + J to open and close the log, Cmd + K to clear the log), then I will see something like: We can see exactly what happened. Someone tried to GET \"/rock\" from a given IP address at a given time, we found a route with instructions to use ApplicationController#play_rock (where the Something#something is Ruby shorthand for Class.method, with the . exchanged for a #), calling this controller-action pair resulted in a redirect to the given URL (https://www.wikipedia.org), and the entire request lifecycle completed in the stated time with no errors. 12.6.1 Text Companion: Our First RCAV "],["video-segment-render-html.html", "12.7 Video Segment: Render HTML", " 12.7 Video Segment: Render HTML Notes: time stamp 00:18:40 to 00:26:38 from render({ :plain =&gt; \"Hello, world!\" }) to render({ :template =&gt; \"game_templates/user_rock.html.erb\" }) .html vs. .html.erb app/views/ view templates rather than public/ We’ve written our first functional action, which just forwards someone to a new page. Now let’s try to render some of our own HTML, rather than redirecting to Wikipedia. We can change the previous code in app/controllers/application_controller.rb to: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :plain =&gt; &quot;Hello, world!&quot; }) end end {: mark_lines=“12-14”} Rather than using redirect_to(), which we inherited &lt; from the Rails Base class, we’ll use another inherited method to complete the request lifecycle: render(). This method, takes a Hash as an argument with a key/value pair. The key has many options, here we will use :plain, which will just send back plain text. A boring response, but good to start with. Now if I pretend I’m a user and visit http://[YOUR APP DOMAIN]/rock, then I get a page with my \"Hello, world!\" rendered. Congratulations! You’ve wired up a route; prepare to do it a million more times, because all developers do all day is pick the next spec , wire up the route for the URL so that a user can visit it, and then implement the logic to send back the correct information. Remember, we did not create and send a file, we are using Ruby to generate this reponse, opening a world of possibilities. For instance, what if we instead rendered a random number: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :plain =&gt; rand(100) }) end end {: mark_lines=“14”} Now everytime we refresh http://[YOUR APP DOMAIN]/rock, we get a different random number, generated automatically by Ruby. This is a dynamic response, not just a static page that we placed in the public folder. This is a simple example, but fundamentally that’s it. We connected a URL to a method that can do anything. It can call APIs, parse CSVs, compute whatever you want, run machine learning models. With this we can do anything. Of course, there is a lot more to learn, but fundamentally this is it. Now let’s send back some actual HTML: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) end end {: mark_lines=“14”} The :html key to render() allows us to place whatever HTML we want in a string that will be shown on the page. We need the .html_safe on the end of the string, which is a bit of Rails security to make sure that one user can’t inject malicious HTML into another user’s browser, in case we were getting the given HTML string from another user (e.g., from a &lt;form&gt;). Don’t worry about this, we will see a better way of doing this in a moment. If we refresh http://[YOUR APP DOMAIN]/rock, then we will see our HTML. We could go crazy and put our entire HTML document in that string. But a much, much better way to to write what’s called an embedded Ruby template. # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end end {: mark_lines=“16”} The :template key to render() allows us to assign a template to render. We specify the name of a folder game_templates/ and file user_rock.html.erb that will contain all of our HTML. This is an .erb for embedded Ruby template file, rather than a plain old .html file. We create this file in the existing app/views/ folder, which is a way better place than public/, because users do not have access to all of its contents. We will keep things organized and put different templates in different sub-folders. Do not put the .html.erb file in the app/views/layouts/ folder that already exists, first make a new folder in app/views/ called game_templates/ then make the new file in this folder called user_rock.html.erb. BENP: insert image(s) (gifs? would be better here; cf. video 00:25:20) of new folder and new file steps in GitPod You can call the game_templates/user_rock.html.erb folder and file whatever you want. The user will not see the folder or the file, they will only see \"/rock\", the specified route. Now you can enter in your new user_rock.html.erb file some HTML to render: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; Don’t forget to save the file changes if you haven’t done so. And now when we refresh http://[YOUR APP DOMAIN]/rock, we get the text from our file rendered in HTML. So after all of that we have an HTML page that basically does what we could have done quickly if we made a file called rock.html in the public/ folder. 12.7.1 Text Companion: Render HTML "],["video-segment-embedded-ruby-tags.html", "12.8 Video Segment: Embedded Ruby Tags", " 12.8 Video Segment: Embedded Ruby Tags Notes: time stamp 00:26:38 to 00:31:37 all about &lt;% %&gt; and &lt;%= %&gt; in a view template But we can do something way better with this new system. Let’s add the following to our embedded Ruby file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;h2&gt; They played &lt;%= %&gt;! &lt;/h2&gt; {: mark_lines=“5-7”} Now we created a new tag that looks like HTML, but contains a doorway to Ruby: &lt;%= %&gt;. We can write any Ruby we want in that embedded Ruby tag, and this is what makes the whole effort of RCAV worthwhile. For instance we can write: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;h2&gt; They played &lt;%= 6 * 7 %&gt;! &lt;/h2&gt; {: mark_lines=“6”} And we will see the result of this computation when we refresh http://[YOUR APP DOMAIN]/rock. But if we go to view source in the browser, we won’t see the Ruby code. We only see the result 42. The browser only understands HTML and has no idea of the code that allows us to make the web application dynamic. So rails is processing all of the embedded Ruby tags and injecting them in the document before it sends the plain HTML file to the browser. We could also do something like &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= 6 * 7 %&gt;! &lt;/h2&gt; {: mark_lines=“5”} Here, we used a slightly different embedded Ruby tag: &lt;% %&gt;. We left off the = sign, which means the output of this Ruby code will be hidden in the final HTML. But, the variable comp_move (which is the result of randomly sampling an array of three possble string values) is still available and we can render it by changing the file again: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; {: mark_lines=“8”} Such that our calculated variable comp_move is now rendered in the final HTML output, because it is in a &lt;%= %&gt; tag, with the = sign. And we will see the result of this computation when we refresh http://[YOUR APP DOMAIN]/rock. View the source code here and you won’t see any sign of the comp_move variable computation from the &lt;% %&gt; tag. BENP: Now could be time for a screenshot or better GIF of refreshing /rock a couple of times to see the output and showing the source code. Alright, we are now finally building dynamic web applications. We are able to render a template, we are able to write some HTML, and we able use embedded Ruby tags: &lt;% %&gt; for hidden content, and &lt;%= %&gt; for rendered content that the user will see. 12.8.1 Text Companion: Embedded Ruby Tags "],["video-segment-control-flow-with-embedded-ruby.html", "12.9 Video Segment: Control Flow with Embedded Ruby", " 12.9 Video Segment: Control Flow with Embedded Ruby Notes: time stamp 00:31:37 to 00:37:10 conditionals all about &lt;% if ... %&gt; Now we can actually compute who won or lost our Rock Paper Scissors match. Let’s add this long if-else Ruby code to our game_templates/ file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;% if comp_move == &quot;rock&quot; %&gt; &lt;h2&gt;We tied!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We lost!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We won!&lt;/h2&gt; &lt;% end %&gt; {: mark_lines=“11-17”} Above, we used hidden &lt;% %&gt; embedded Ruby tags in our control flow on each line we wanted to hide, so none of this will be rendered to the user. Only the result of this control flow &lt;h2&gt;We tied!&lt;/h2&gt;, &lt;h2&gt;We lost!&lt;/h2&gt;, &lt;h2&gt;We won!&lt;/h2&gt; will be rendered, depending on the randomly sampled comp_move variable. Refresh http://[YOUR APP DOMAIN]/rock to see. And now would be a good time to run rails grade at the GitPod console to check our progress. And remember to Always Be Committing, by making a /git commit. We have a lot done, but we still have a lot to do. 12.9.1 Text Companion: Control Flow with Embedded Ruby "],["video-segment-homepage.html", "12.10 Video Segment: Homepage", " 12.10 Video Segment: Homepage Notes: time stamp 00:37:10 to 00:40:18 RCAV with render for / The target has a homepage at the root URL, /. In the old days, we would create a file in public/ called index.html, but now we are pretty much done with public/ except maybe for static assets like images or css files, but we won’t put any more user-facing URL pages there. Those will be connected up with routes from here on. Let’s go to our config/routes.rb and add a homepage route: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) end {: mark_lines=“5” } We are adding the \"/\" homepage route, we are using the application_controller.rb file, and we are using the action (or the method within the ApplicationController) that we call homepage. Now if I refresh the http://[YOUR APP DOMAIN]/ page, I get an error message that the homepage action cannot be found in ApplicationController: The action &#39;play_rock&#39; could not be found for ApplicationController This is good! That means we defined the route correctly. If you still see a “No route matches” error, then double-check your route syntax and get that error to go away before you proceed further. The error occurs because we did not yet define the action. So we need to go to our app/controllers/application_controller.rb file and add: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end end {: mark_lines=“9-11”} And now we can create that new file game_templates/rules.html.erb, and add to it: &lt;!-- app/views/game_templates/rules.html.erb --&gt; &lt;h1&gt;Welcome to RPS&lt;/h1&gt; Now when we refresh http://[YOUR APP DOMAIN]/, there is no error and our HTML template is rendered. And we did not put any HTML in the public folder! You will almost always want some kind of dynamic behavior on every page. So our new workflow is always RCAV: Define a route, assign a controller, create an action in that controller, and view the result. 12.10.1 Text Companion: Homepage "],["video-segment-reinforce-rcav-with-paper.html", "12.11 Video Segment: Reinforce RCAV with /paper", " 12.11 Video Segment: Reinforce RCAV with /paper Notes: time stamp 00:40:18 to 00:44:27 RCAV with render for /paper Let’s start with the /paper route, for when we play paper. First we define the route in config/routes.rb with a controller: # config/routes.rb Rails.application.routes.draw do get(&quot;/&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;homepage&quot; }) get(&quot;/rock&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_rock&quot; }) get(&quot;/paper&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;play_paper&quot; }) end {: mark_lines=“9” } Again, we use the application_controller.rb. If we pretend we are a user now and go to http://[YOUR APP DOMAIN]/paper, we again get the “action not found” error. The helpful error message (RTEM!) tells us we need to define another method for the action in our controller called play_paper. We are in our Route, Controller, Action, View sequence that makes Rails so useful! It’s the same flow, over and over again. All we need to do is keep visiting the route and RTEM to find the next step. Ok, let’s define the action in our app/controllers/application_controller.rb: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23-26”} Now we can pretend we are a user and again refresh http://[YOUR APP DOMAIN]/paper. And we’ll get a new error message that tells us we are missing the view template: If you cannot figure out what your typo is and why an error message keeps coming up, then delete what you wrote and try to type it again from scratch (or talk to your rubber duck). We RTEM above and that tells us to go and make the new game_templates/user_paper.html.erb file that will be rendered to the user: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; And now our view at http://[YOUR APP DOMAIN]/paper renders content with no error message. A successful RCAV! 12.11.1 Text Companion: Reinforce RCAV with /paper "],["video-segment-embedded-ruby-in-the-controller-with-instance-variables.html", "12.12 Video Segment: Embedded Ruby in the Controller with Instance Variables", " 12.12 Video Segment: Embedded Ruby in the Controller with Instance Variables Notes: time stamp 00:44:27 to 00:54:20 moving conditional control flow &lt;% if ... %&gt; from /rock into the ApplicationController action play_rock local variables vs. instance variables with @-notation Now that we are RCAV pros, let me show you another (perhaps better, depending on your taste) way of writing our embedded Ruby code. Let’s return to the game_templates/user_rock.html.erb file: &lt;!-- app/views/game_templates/user_rock.html.erb --&gt; &lt;h2&gt;We played rock!&lt;/h2&gt; &lt;% comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample %&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;% if comp_move == &quot;rock&quot; %&gt; &lt;h2&gt;We tied!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We lost!&lt;/h2&gt; &lt;% elsif comp_move == &quot;paper&quot; %&gt; &lt;h2&gt;We won!&lt;/h2&gt; &lt;% end %&gt; {: mark_lines=“5”} The highlighted code &lt;% comp_move = [\"rock\", \"paper\", \"scissors\"].sample %&gt; is okay, but you could imagine that in a real application there may be dozens of lines of code to prepare the information that we actually want to show the user. Our example is trivial. In reality we may lookup data from a database, doing math on it, finding API data, and more. Think of our “take your umbrella” example BENP: insert link to this DarkSky API example; but wait, has it even been presented up to this point?, which took around 30 lines of Ruby code to produce. We want somewhere other than the HTML template to put this code. We can in fact do that! Let’s go back to the game_templates/user_paper.html.erb file, since we didn’t get as far there and see how we can make this modification. We would like our file to look like this: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= outcome %&gt;! &lt;/h2&gt; {: mark_lines=“7-13”} We wish we could just do this and avoid all the lines of embedded Ruby that are in the previous user_rock.html.erb view template. The responsibility for these computations really don’t belong here, the view templates should be given some data and then the job should just be to format and present it beautifuly and usably to the user. In the backend the responsibility should be marshalling the correct data and sending it to the view template. We can return to our app/controllers/application_controller.rb controller file and do the following: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample if comp_move == &quot;rock&quot; outcome = &quot;won&quot; elsif comp_move == &quot;paper&quot; outcome = &quot;tied&quot; elsif comp_move == &quot;scissors&quot; outcome = &quot;lost&quot; end render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23-31”} In the above highlighted code we have removed all of the embedded Ruby tags (&lt;% %&gt; and &lt;%= %&gt;) from the code we had in the .html.erb view template. Now when a user visits the route http://[YOUR APP DOMAIN]/paper, the action play_paper in the controller ApplicationController will be triggered, and the code will be run before the template is rendered. So let’s try to visit http://[YOUR APP DOMAIN]/paper again. Oops, we get this error: In our game_templates/user_paper.html.erb view template, when we get to the first embedded Ruby tag: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= outcome %&gt;! &lt;/h2&gt; {: mark_lines=“8”} That local variable comp_move is undefined! A local variable only exists in the scope it was defined. If I create a local variable in a loop, it will only exist in that loop. If I want some variable available outside the loop, then I would need to create it outside the loop and modify it in the loop. So there’s a scope to local variables and I can’t just use it in my template if I created it in the play_paper method (action). The variable is effectively “dead” after play_paper executes. So how do we make the controller variables available in the view template? Let’s modify our app/controllers/application_controller.rb: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(false) # Add your actions below this line # ================================ def homepage render({ :template =&gt; &quot;game_templates/rules.html.erb&quot; }) end def play_rock # write your code here # redirect_to(&quot;https://www.wikipedia.org&quot;) # render({ :html =&gt; &quot;&lt;h1&gt;Hellow, world!&lt;/h1&gt;&quot;.html_safe }) render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot; }) end def play_paper @comp_move = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;].sample if @comp_move == &quot;rock&quot; @outcome = &quot;won&quot; elsif @comp_move == &quot;paper&quot; @outcome = &quot;tied&quot; elsif @comp_move == &quot;scissors&quot; @outcome = &quot;lost&quot; end render({ :template =&gt; &quot;game_templates/user_paper.html.erb&quot; }) end end {: mark_lines=“23 25-30”} All we did was place an @ symbol before any variable that we want access to in our view template. This is a new kind of variable called an instance variable. This type of variable will survive as long as the instance the object in which its created survives BENP: last sentence a bit confusing. In this case when someone visits /paper, Rails is going to create an instance of the ApplicationController class and then run the play_paper method. So as long as the ApplicationController instance is alive (Rails keeps it until the response is sent to the user), the variables produced by play_paper will exist. When someone visits /paper, we now have @comp_move and @outcome available for our template. We just need to make sure those instance variables are also properly referenced in game_templates/user_paper.html.erb: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= @comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= @outcome %&gt;! &lt;/h2&gt; {: mark_lines=“8 12”} Again, we just use the leading @ symbols on our variables to tie them to the instance variables in the controller. And if we visit the /paper URL, it works! And we have a much improved organization. Most computation work like this should go in the controller as we have done it here. We will have cases where embedded Ruby goes in the template (e.g., rendering database records with each loops, if statements to check if a user is allowed to see something, other conditional statements). If it can happen in the controller, it should happen there. Time for a rails grade and a /git commit! 12.12.1 Text Companion: Embedded Ruby in the Controller with Instance Variables "],["video-segment-linking-pages-with-layouts.html", "12.13 Video Segment: Linking Pages with Layouts", " 12.13 Video Segment: Linking Pages with Layouts Notes: time stamp 00:54:20 to 01:00:49 all about app/views/layouts/wrapper.html.erb to get some headers, footers, and navigation links layout(\"wrapper.html.erb\") in ApplicationController :layout argument for render() It would now be nice to add some links so we don’t need to type in the URL addresses, like in our target. Let’s start with our game_templates/user_paper.html.erb: &lt;!-- app/views/game_templates/user_paper.html.erb --&gt; &lt;div&gt; &lt;a href=&quot;/rock&quot;&gt;Play Rock&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/paper&quot;&gt;Play Paper&lt;/a&gt; &lt;/div&gt; &lt;h2&gt; We played paper! &lt;/h2&gt; &lt;h2&gt; They played &lt;%= @comp_move %&gt;! &lt;/h2&gt; &lt;h2&gt; We &lt;%= @outcome %&gt;! &lt;/h2&gt; {: mark_lines=“3-8”} And now if we visit our /paper URL, then we have the links. But if we click on “Play Rock” here, and we are taken to the /rock URL, then the links are not there, because we only put them in the game_templates/user_paper.html.erb file, and not in the game_templates/user_rock.html.erb file, which is what visiting the /rock URL will render. BENP: In the below example, we use the app/views/layouts/wrapper.html.erb file that we create, but in all other class work we use app/views/layouts/application.html.erb to place our headers and footers. Maybe we change the below section to just do it with that, which also I think allows us to omit the layout(\"wrapper.html.erb)\" call? How can we avoid repeating these HTML navigation links in all of our view templates? Well, here is one of the great benefits of working in Rails instead of HTML. We are dynamically generating responses rather than hard-coding into a bunch of files. If there is common stuff we want on every page, like a nav-bar or footer, then we can make a special file in app/views/layouts/ and call it whatever we like. Let’s create a file in that folder called wrapper.html.erb and let’s fill our new app/views/layouts/wrapper.html.erb file with: &lt;!-- app/view/layouts/wrapper.html.erb --&gt; &lt;div&gt; &lt;a href=&quot;/rock&quot;&gt;Play Rock&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/paper&quot;&gt;Play Paper&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;/scissors&quot;&gt;Play Scissors&lt;/a&gt; &lt;/div&gt; &lt;%= yield %&gt; &lt;div&gt; &lt;a href=&quot;/&quot;&gt;Rules&lt;/a&gt; &lt;/div&gt; Copyright, Appdev 2022. All rights reserved. {: mark_lines=“13”} Now every page that we visit will have all of its contents placed where the above highlighted code says &lt;%= yield %&gt;. We just need to also change our application_controller.rb file to note this and have it take effect: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base layout(&quot;wrapper.html.erb&quot;) {: mark_lines=“4”} This layout method takes one argument and it already knows to look in the folder app/views/layouts/ for the file that we created. After this change, try visiting your pages using the links on every page. It should work (except for /scissors because we haven’t done the RCAV for that page yet). If we only wanted the layout to apply on a per-page basis we could also leave layout(false) in the previous code, and we could in the play_rock method (action) change our render statement to: render({ :template =&gt; &quot;game_templates/user_rock.html.erb&quot;, :layout =&gt; &quot;wrapper.html.erb&quot; }) This additional :layout argument would then only put the nav-bar and footer in wrapper.html.erb on the /rock route. Time for a rails grade and a /git commit! The rest of the project is up to you to finish. Visit the specs and wire them all up. You have all the tools now. 12.13.1 Text Companion: Linking Pages with Layouts "],["finish-and-submit-rps-rcav.html", "12.14 Finish and Submit RPS RCAV", " 12.14 Finish and Submit RPS RCAV Notes: Refer students to rails grade, git, and Sharing a Gitpod Snapshot sections for how to get help "],["rcav-addendums.html", "12.15 RCAV Addendums", " 12.15 RCAV Addendums Notes: Stuff that I did not zip in from the chapter adding-routes.md: 12.15.1 Addendum: Rendering JSON Imagine that we wanted to build a native iPhone app that asked our server for some information; in this simple example, for a random computer move and an outcome, but in the real-world things like the local weather given a latitude and a longitude. Rather than rendering a pre-defined message in plain text, it’s usually more helpful to the iPhone developer to render the data in JSON format, so that they can parse it, easily fetch whichever values they need, and assemble their own interface. Here is some JSON that would be convenient for an external application to parse: { &quot;player_move&quot;:&quot;rock&quot;, &quot;comp_move&quot;:&quot;paper&quot;, &quot;outcome&quot;:&quot;lost&quot; } Notice that JSON uses strings as keys — this is because JavaScript doesn’t have the equivalent of Ruby’s Symbol class. Also, there are no hash rockets; JSON just uses colons to separate keys and values. Fortunately, just as it was easy for us to convert a String containing JSON into Ruby Arrays/Hashes using the JSON.parse method, it is also easy for us to go in the other direction: both Array and Hash have methods called .to_json. Let’s create a Ruby Hash that resembles the JSON above: response_hash = { :player_move =&gt; &quot;rock&quot;, :comp_move =&gt; &quot;paper&quot;, :outcome =&gt; &quot;lost&quot; } We can then convert this into a String in JSON format with .to_json: response_hash.to_json returns: &quot;{\\&quot;player_move\\&quot;:\\&quot;rock\\&quot;,\\&quot;comp_move\\&quot;:\\&quot;paper\\&quot;,\\&quot;outcome\\&quot;:\\&quot;lost\\&quot;}&quot; The \\\" represents double-quotes; we need the backslash, known as an “escape”, because we’re already within a double-quoted string and don’t want to terminate it. You can puts the string to see it formatted: puts response_hash.to_json displays: {&quot;player_move&quot;:&quot;rock&quot;,&quot;comp_move&quot;:&quot;paper&quot;,&quot;outcome&quot;:&quot;lost&quot;} Great! That means we can update our action if we want to send back JSON instead: class ApplicationController &lt; ActionController::Base def play_rock moves = [&quot;rock&quot;, &quot;paper&quot;, &quot;scissors&quot;] comp_move = moves.sample if comp_move == &quot;rock&quot; outcome = &quot;tied&quot; elsif comp_move == &quot;paper&quot; outcome = &quot;lost&quot; elsif comp_move == &quot;scissors&quot; outcome = &quot;won&quot; end response_hash = { :player_move =&gt; &quot;rock&quot;, :comp_move =&gt; &quot;paper&quot;, :outcome =&gt; &quot;lost&quot; } render({ :plain =&gt; response_hash.to_json }) end end Congratulations — you just built your first API endpoint!  12.15.2 Addendum: Custom Controller Files We don’t have to put all of our actions within the default ApplicationController file that comes included with any Rails app; we can add our own controllers, if we want to organize things a bit more. With an app of any non-trivial size, you’ll end up with hundreds of actions, and it can get unwieldy to put them all in one gigantic application_controller.rb. Instead, we can change our route for /rock to this: get(&quot;/rock&quot;, { :controller =&gt; &quot;game&quot;, :action =&gt; &quot;play_rock&quot; }) Now when a user visits /rock, they will see an error uninitialized constant GameController. As we know, when Ruby says “uninitialized constant” it means “I can’t find that class”. So, what’s going on here? When we said :controller =&gt; \"game\" in the route, we told Rails to look for a class called GameController when someone visits /rock. All of the controller class names will end in ...Controller, and they will begin with whatever value we provided for the key :controller in the route. Like all Ruby classes, the name must be CamelCase (not snake_case or Some_Hybrid). So in this case, it will be GameController. The class must be defined in a Ruby file that is the snake_cased version of its name. Rails will itself use the .underscore method to figure out the name; we can try it ourselves in rails console: [2] pry(main)&gt; &quot;GameController&quot;.underscore =&gt; &quot;game_controller&quot; The Ruby file must be placed within the app/controllers/ folder. So, in this case, we create a file called app/controllers/game_controller.rb (don’t forget the .rb file extension). Finally, within this file, we define the class: class GameController &lt; ApplicationController end We inherit from ApplicationController, which in turn inherits from ActionController::Base; much like our models inherited from ActiveRecord::Base via ApplicationRecord. Our models inherited .save, .where, and a bunch of other awesome database-related methods from ActiveRecord::Base; whereas our controllers are going to inherit a bunch of methods like render, redirect_to, and a bunch of other awesome interface-related methods from ActionController::Base. Don’t forget the end that goes with the class; type it before you forget it. Move your play_rock action over from application_controller.rb into this new class. Now, when a user visits the path /rock, the “uninitialized constant” error should go away and you should see a response as before. If you still see the “unitialized constant” error, then: You named your class wrong; it must exactly match the value in routes.rb, followed by Controller (singular), and CamelCase. You named the file wrong. Try doing .underscore on a string containing the class name in rails console to figure out the correct filename. You put the file in the wrong folder. It has to be within app/controllers/. Not within, for example, app/ or app/controllers/concerns/. You forgot the .rb file extension. If you can’t find which of the above it is, try deleting what you did and paving over your work again from scratch. Sometimes you just can’t spot your own typos, and paving over is the best approach. You can make as many controllers as you like; in general, a rule of thumb is to have one controller per database table. "],["omnicalc-1.html", "13 Omnicalc 1", " 13 Omnicalc 1 Notes: Forms and Query Strings Original video transcription is in forms-query-strings-and-params-Omnicalc-Part1.md Project (graded): https://github.com/appdev-projects/omnicalc-1 Target: https://omnicalc-1.matchthetarget.com/ Useful chapters: forms-query-strings-and-params.md not BENP: Would be useful here to show the “layouts” folder that is providing the wrapper with the table of buttons. But I am confused because now the wrapper is not pointed out in the application_controller.rb file as in RPS RCAV. In any case, the layouts/application.html.erb is finally brought up in relation to the nav bar in the Day 4 video @ 28’30\" for the fortune teller app. Probably good to bring this up earlier. Also because this is where all the html header stuff went that is missing from our .html.erb view templates. "],["video-segment-intro-to-forms-and-exploring-the-target.html", "13.1 Video Segment: Intro to Forms and Exploring the Target", " 13.1 Video Segment: Intro to Forms and Exploring the Target Notes: time stamp 00:00:00 to 00:02:26 we want forms to get information what is a query string open gitpod explore the target Our users don’t want to type input into the address bar; they want to type into forms! Let’s practice building forms. Forms are incredibly important to us. That is the primary way in which users give us information that we will eventually be storing in our databases, the heart of our applications as we have talked about since day 1. For now we don’t have a database, but we will be doing some calculations, sending text messages, even doing some pretty cool API work with that information. Geocoding it, machine learning, all kinds of stuff. Next week we will have databases to store that information as well. We have a project called Omnicalc Part 1 to work on this, so we’ll create a GitPod workspace for it. BENP: Starting Our GitPod Workspace, 00:00:44 to 00:01:05 BENP: this setup is also occurring some more around 4 minutes in the midst of the first RCAV Here is the assignment. As usual: Start the web server by running bin/server. Navigate to your live application preview. As you work, remember to navigate to /git and Always Be Committing. Organize your workspace tabs. BENP: Added this step! Run rails grade as often as you like to see how you are doing, but make sure you test your app manually first to make sure it matches the target’s behavior. BENP: possible image(s) (better, GIFs?) of starting a workspace, opening /git, organizing tabs, noting the target favicon. But these are probably in a different chapter. The target for this project is here. BENP: Exploring the Target, 00:01:05 to 00:02:26 This is a very simple application we will build today, to get our feet wet with forms. There are four forms that users can type into. This first one at the URL path /square/new there is a very simple single input form, where I can type in a number where I can type in a number like “42”, click the button and it gives me the square. The second URL /square_root/new let’s me enter a number, again “42”, and then I end up at the URL /square_root/results?user_number=42. There’s a query string starting at the ? there: ?user_number=42. There is also the URL path /payment/new with three inputs, and finally there is /random/new with two inputs. So let’s make these four links (URL paths) work. In doing so, we’ll see the fundamental pieces in making all forms work, and that is fundamentally how we get all of our user input. 13.1.1 Text Companion: Intro to Forms and Exploring the Target "],["video-segment-squarenew-rcav.html", "13.2 Video Segment: /square/new RCAV", " 13.2 Video Segment: /square/new RCAV Notes: time stamp 00:02:26 to 00:11:25 RCAV with RTEM for /square/new debugging Okay, so here is how this is gonna go. First and foremost, as always, it’s going to be a question of RCAV: Route, Controller, Action, View. That comes first, before anything. We need to identify the URLs users can visit, make up a route, and then first of all just make the page say something (anything) just to make sure we connected the RCAV dots correctly. Then we can figure out what do we actually need to show them, what, if any, Ruby do we need to write to make the page dynamic and all that other stuff. So let us first begin with let’s say the form at /square/new. We need to define this URL and then make it display a form to match the target. Pretty simple, there is nothing dynamic going on here, it’s just a static HTML page. Actually we could probably achieve this in the /public folder, but from now on we won’t do anything in there, we will always do RCAV, just to give us the flexibility of later embedding Ruby if we want to. My workflow is: pretend I’m a user, navigate to a URL I want to start supporting, and start debugging it one step at a time. Let’s begin by navigating (typing into the address bar) in our new Rails app http://[YOUR APP DOMAIN]/square/new. And in my staring point I will see: Routing Error No route matches [GET] &quot;/square/new&quot; BENP: in RPS-RCAV I added screenshots for error messages, probably fine to just do as here with code blocks So step one is opening config/routes.rb in our GitPod workspace, and add some code to it: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) end {: mark_lines=“5” } BENP: in the video at 00:05:14, the routes.rb file has some additional content not on the GitHub starting point. devise_for blah blah blah. We can maybe leave this code out from above? The first argument is the String defining the path that the user can visit, and the second argument defines the class (:controller) and method (:action) that are activated when someone visits the path. We decided on a method name called \"blank_square_form\", since the job of it is just to show a form for the user to type into when the user wants to calculate the square of a number. We decided we will put this method in the controller that comes with Rails out of the box: \"application\", which is found in the app/controllers/application_controller.rb file and has the class name ApplicationController when we open that file: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base end In our config/routes.rb, we tell Rails to look in this controller for our method whenever someone visits the route /square/new. Later when we have larger applications, and we begin having more actions, we’ll break it into multiple controllers. Now if pretend to be users in our running application and try to visit that route we get a new error: The action &#39;blank_square_form&#39; could not be found for ApplicationController The routing error is gone, which tells me I put the route in the right place, and didn’t have any typos. The new error message is saying that it found the route and controller, but the method (action) is missing. We still need to add our method to the app/controllers/application_controller.rb controller file: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end end {: mark_lines=“4-7” } I made up a name for a folder to but the templates in to keep things organized and I named the file. So we now need to go into our app/views/ folder, create a new folder called calculation_templates (do not create this folder or file in the layouts/ subfolder!) and then create a new file in that folder called square_form.html.erb. We can right away add something to that file, just to make sure that it works: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; Now we can go back to our Rails app browser tab and refresh the /square/new URL. When we refresh, we see “howdy” and know that our RCAV is complete. Note that I don’t try to type everything at once, work in very small steps and give yourself feedback (view) as early as you possibly can to make sure the code that you typed is doing what you think it is. If you see an error message up to this point then go back and be sure to RTEM! Let the error message help you. If it says “No route matches”, you might have typed in the URL in the address bar wrong (try to visit /squarre/new and see that happen), or you might have a typo in your config/routes.rb file in the get() call. Use the error messages and debug. It is very deterministic and will do exactly what you tell it to do. Rails is looking at this in a clear order. You visit a route, then it looks for the controller in the app/controllers/ folder and if that file is found, then it looks inside the file and looks for a class with the same name as the file (but capitalized and with underscores removed), then it looks for the action (method) in that class called whatever we defined it as in get(), then it will run that method. At every step, if something isn’t found, you will get a clear error message pointing out where the problem occurred and it is up to you to go back and correct. If you can’t spot the problem often the easiest thing to do is comment out your code and start from scratch typing everything. It’s quicker sometimes to pave over the typo, when they are hard to spot. 13.2.1 Text Companion: /square/new RCAV "],["video-segment-squarenew-form.html", "13.3 Video Segment: /square/new Form", " 13.3 Video Segment: /square/new Form Notes: time stamp 00:11:25 to 00:14:12 building a form in the /square/new view template &lt;form&gt;&lt;/form&gt;, &lt;label&gt;&lt;/label&gt;, &lt;input&gt;, &lt;button&gt;&lt;/button&gt; valid forms with for=\"\" and id=\"\" Now that we have the /square/new form saying something, we need to think about what it should actually do. It needs to have a form with a label and one text input and a button. Alright, if we refresh our memories and go back to the slides from the essential HTML review, there is a slide about forms, which we looked at in class. BENP: link here? Probably not necessary. I could not find this slide. Better to just link form chapter content. We can go into our view template for the current form and do the following: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label&gt;&lt;/label&gt; &lt;input&gt; &lt;button&gt;&lt;/button&gt; &lt;/form&gt; {: mark_lines=“5-10”} We have an opening and closing tag (&lt;form&gt;&lt;/form&gt;) to bracket the form, then a label tag (&lt;label&gt;&lt;/label&gt;), then an input tag (&lt;input&gt;, no closing necessary), then a button tag (&lt;button&gt;&lt;/button&gt;). These are the essential form elements. Now what about the copy? Let’s have a look at our target URL so we can get the copy right, because rails grade will be looking for it – you have to build to the spec that you’ve been “hired” to build. You can just make up your own copy willy nilly. Once we have the copy, we go back to our view template and add some more: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label&gt;Enter a number&lt;/label&gt; &lt;input&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“6 9”} Now that we have the copy, we need to make this form proper by adding the following: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“6-7”} We always need to associate inputs and labels with an id and a for. Every form control must always have an id and be labelled with a unique string. It doesn’t matter what the value is, it just needs to match for accessibility and for machines to understand the form. We just picked something random. It doesn’t matter so we just used \"giraffe\" for both. BENP: this use of random id and for is a little confusing because it’s not how we would do it later in the course or in reality. I’m in favor of using realistic form associations from this point already In addition, we added the type as \"text\" for the input, which is the default and would be used anyway even if we left it out. We also added a placeholder to add the gray text from our target: \"What number do you want to square?\". We can return to our Rails app and refresh /square/new to see our form. Great! 13.3.1 Text Companion: /square/new Form "],["video-segment-query-string-and-parameters-hash.html", "13.4 Video Segment: Query String and Parameters Hash", " 13.4 Video Segment: Query String and Parameters Hash Notes: time stamp 00:14:12 to 00:16:36 everything after ? from /square/new form and the Parameters Hash If I type in “42” and hit calculate, my form is terrible, it doesn’t really do anything. At least when I click the label “Enter a number” it puts the focus on the input box, so my association is wired up correctly. But when I click the button it doesn’t take me anywhere. Forms are like links, when you click on them they are supposed to take you to another URL, not keep you on the same page. The form is also supposed to put whatever I typed into the address bar after the ? symbol. One of the key problems I have is not naming my input, so let’s do that in our form: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot; name=&quot;elephant&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“7”} Just to be silly BENP: again, maybe use realistic for, id, name from this point already we named the input \"elephant\". And now when I refresh (the back arrow won’t change anything) the form at /square/new, and enter in 42 again then hit the calculate button, I will see a new URL string: /square/new?elephant=42. Now even though the form isn’t taking me to another place, at least the value I typed is getting preserved in the query string in the URL. And because of the way that Rails work, that value, if it’s in a query string, Rails is going to parse it and put it in a very special Hash. We can view that Hash in our GitPod terminal (Cmd + J to open or close it): This Hash with the name Parameters is now available in our entire app: in the view template, the action, we can use it anywhere. That is the crux of how we get information out of forms. All we need to do is name an input in the form, and that will capture the variable in our query string and Rails will put it in a hash that we can access. After all the API work that we’ve done BENP: wait, did we do API work up to this point? we are pros at capturing things out of hashes. Time for a /git commit (perhaps with the title message “Square form looking pretty good, doesn’t work yet” or something along those lines), and maybe even a rails grade to see what’s left to do. 13.4.1 Text Companion: Query String and Parameters Hash "],["video-segment-squareresults-rcav.html", "13.5 Video Segment: /square/results RCAV", " 13.5 Video Segment: /square/results RCAV Notes: time stamp 00:16:36 to 00:23:48 building the /square/results RCAV and form more on query strings If we look at how the target works, when we enter a number (why not…“42”?) to square and click calculate, then we end up at another URL /square/results?number=42. I started at /square/new and when I click, it takes me to /square/results, a page with different markup and different content from the starting point. Let’s send the user there in our app. We will need to start by going through our RCAV steps. Remember to work in small steps and refresh the view often. Keep Reading the Error Message and slowly debugging. Get used to this process, we will be doing it over and over again! Route, Controller, Action, View! First, the route. Go to your app’s browser and manually navigate to /square/new. RTEM. Time to add a route: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) get(&quot;/square/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_square&quot; }) end {: mark_lines=“7” } Since this is when the user is actually calculating (as opposed to requesting a blank form with \"blank_square_form\"), we call the action \"calculate_square\". Now refresh the browser again and RTEM. The route should be set, and it’s time to add an action (method) in our controller (class): # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“9-12” } We keep using the same calculation_templates/ folder. Now if we refresh again and RTEM, we see the action was found, but now we need to make a new file in app/views/calculation_templates/ called square_results.html.erb. Once we create that file and enter some quick copy to view (why not…&lt;h1&gt;hi&lt;/h1&gt;?), we refresh once more to see our completed, error-free RCAV cylce (assuming you don’t have any typos). Now let’s get the result page doing what we actually want. We begin by adding some formatting and HTML to our view template in app/views/calculation_templates/square_results.html.erb: &lt;!-- app/views/calculation_templates/square_results.html.erb --&gt; &lt;h1&gt;Square Results&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Number&lt;/dt&gt; &lt;dd&gt;something&lt;/dd&gt; &lt;dt&gt;Square&lt;/dt&gt; &lt;dd&gt;something squared&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“3-11”} We use a description list (&lt;dl&gt;) containing description terms (&lt;dt&gt;) and data (&lt;dd&gt;), as per the copy (remember to right click and “View Source”) in the target. Refresh out app, and everything should look okay on this page. But we just put in some placeholders for the result. Let’s actually make it dynamic. We need to put the original number in the first something and calculate the square to put the result in something squared. If I add a query string on the end of any URL in Rails (e.g., I can go to my app and add /square/results?user_number=42), and then I hit return, it doesn’t change anything. For the purposes of routing anything after the ? in a query string is ignored, but in the server log (GitPod terminal where we ran bin/server), we saw previously that everything after the ? is added as key/value pairs in the Parameters Hash: Parameters: {&quot;user_number&quot; =&gt; &quot;42&quot;} We could add a bunch of variables to our query string with &amp; and all of them would be separated in the Parameters. If we typed into our address bar /square/results?user_number=42&amp;zebra=12&amp;giraffe=82, hit enter, and return to our server log on GitPod, we would find: Parameters: {&quot;user_number&quot; =&gt; &quot;42&quot;, &quot;zebra&quot; =&gt; &quot;12&quot;, &quot;giraffe&quot; =&gt; &quot;82&quot;} So the query string is just a Hash! 13.5.1 Text Companion: /square/results RCAV "],["video-segment-form-action-and-params.html", "13.6 Video Segment: Form Action and params", " 13.6 Video Segment: Form Action and params Notes: time stamp 00:23:48 to 00:31:46 adding action=\"/square/results\" to the /square/new form using params Hash in the /square/results action to fetch from query string, calculate, and display Now if we go back to our form in our app at /square/new, enter “42”, and hit calculate, then it puts the query string together, but stays in the same place: /square/new?elephant=42. Remember we defined the name of the variable in our view template form as elephant. A bit silly, but we can roll with it. BENP: See what I mean? If we eliminate elephant above then we save on the awkward name here So this means we need to add a redirect action to our form, pull out the query string data, and do a calculation. So here’s the magic. Let’s open the view template at app/views/calculation_templates/square_form.html.erb: &lt;!-- app/views/calculation_templates/square_form.html.erb --&gt; &lt;h1&gt;howdy!&lt;/h1&gt; &lt;form action=&quot;/square/results&quot;&gt; &lt;label for=&quot;giraffe&quot;&gt;Enter a number&lt;/label&gt; &lt;input id=&quot;giraffe&quot; type=&quot;text&quot; placeholder=&quot;What number do you want to square?&quot; name=&quot;elephant&quot;&gt; &lt;button&gt;Calculate square&lt;/button&gt; &lt;/form&gt; {: mark_lines=“5”} The action attribute to the &lt;form&gt; is equivalent to the href in a link like &lt;a href=\"https://www.wikipedia.org\"&gt;Go to wikipedia&lt;/a&gt;. Putting \"https://www.wikipedia.org\" after action= would cause the form to redirect to WikiPedia after we click the button, you can try it yourself. Be sure to refresh the page, back buttons will not reload the code and the action will not work. Instead of redirecting away from our app though, we want our button click to send the user to /square/results, and that is what we specified above, and where the form will now go. Refresh /square/new, enter a number, click the button, and see for yourself. Again, if you tried the WikiPedia example, remember to refresh the page or your new action will not take effect. What happened? We entered “42”, we hit calculate, the form routed us to /square/results, Rails called the get() for this route, which used the controller and action to render our view template for this page, and on the end of our URL we have our input preserved: /square/results?elephant=42. And this input is also preserved in our Parameters Hash. Let’s pull out this data from the hash and use it in our action (contained in our controller) that was triggered when we were routed to the URL /square/results by our form: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;) @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“10-13” } From our server log, we copy-pasted in our hash and put this in a comment with the assigned variable params. This is for our own reference (it is in a comment #), but the variable params exists in every Rails app to store this hash. Hence we use it in the subsequent lines with our familiar Hash method .fetch() to pull out the key/value pair of interest. In this case we pull the user input (which we named elephant in our form) to an instance variable @num (because an instance variable will be accessible in our rendered view template \"calculation_templates/square_results.html.erb\"), and we calculate another instance variable @square_of_num to store our result for rendering. Let’s put these instance variables into that view template with embedded Ruby tags: &lt;!-- app/views/calculation_templates/square_results.html.erb --&gt; &lt;h1&gt;Square Results&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Number&lt;/dt&gt; &lt;dd&gt;&lt;%= @num %&gt;&lt;/dd&gt; &lt;dt&gt;Square&lt;/dt&gt; &lt;dd&gt;&lt;%= @square_of_num %&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;a href=&quot;/square/new&quot;&gt;Calculate another square&lt;/a&gt; {: mark_lines=“7 10 13”} Note that we also added a link at the bottom (as per the target app) to return to the form and make another calculation. Now we can refresh the /square/new, enter data, and submit again… but wait! Another error message: undefined method `**&#39; for &quot;42&quot;:String Oops, the query string puts the data into the params Hash as a String object, but we need it as a float or integer to do math on it. Let’s return to our controller action and: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end end {: mark_lines=“12” } We use a .to_f, since we want a float so the user can enter a decimal number (like “42.01”) and get the exact (not integer rounded) result. Now we can try once more, and everything should be up and running. Time for a /git commit (perhaps with the title message “Square form and calculation done” or something along those lines), and a rails grade to see what’s left to do. Do not use rails grade to debug, always test your app manually before running rails grade as the last check. 13.6.1 Text Companion: Form Action and params "],["video-segment-independence-of-routes.html", "13.7 Video Segment: Independence of Routes", " 13.7 Video Segment: Independence of Routes Notes: time stamp 00:31:46 to 00:43:13 use /random/results RCAV developed before /random/new to highlight independence of routes You will complete most of the rest of the assignment on your own, but let’s talk about one more thing using the /random/new URL path. We can have a look at the target and see that when we type in the “Minimum” using “1.5” and “Maximum” using “4.5” and click the button, we are routed to /random/results?user_min=1.5&amp;user_max=4.5. So this is the route we want to work. I want to point out here that in theory the /random/new page with the form and the /random/results page with the result are entirely independent. I could just build /random/results without /random/new, but then the user would need to manually type into the address bar their inputs after a query string: ?user_min=1.5&amp;user_max=4.5. Try and just change the URL to /random/results?user_min=0&amp;user_max=2. The page will change when you hit enter and we never used the form page. The point is, every RCAV is independent of every other RCAV. Clicking the button on our previous form for /square/new triggered a new and independent RCAV. We need to think of these things as independent, we are just cleverly arranging things such that there is a cause and effect, but this does not exist without our clever arrangement. So you can choose whatever names you want for inputs, parameters, or anything else. You just need to make sure whatever names you choose, that everything matches up so that at the end of the day you can retrieve the information you need. Don’t expect Rails to guess your intention, you need to instruct Rails what you want to do and it will follow your instructions to the letter. Let’s start the task of getting /random/new and /random/results to actually work. But let’s begin the other way around from before, by getting /random/results going first. So first step is to manually in my app enter the URL /random/results, get my familiar “No route matches” error and begin the RCAV cycle. First we add the route: # config/routes.rb Rails.application.routes.draw do get(&quot;/square/new&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;blank_square_form&quot; }) get(&quot;/square/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_square&quot; }) get(&quot;/random/results&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;calculate_random&quot; }) end {: mark_lines=“9” } Now we refresh our browser, RTEM, and add the action that we named in our controller: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end def calculate_random render({ :template =&gt; &quot;calculation_templates/random_results.html.erb&quot; }) end end {: mark_lines=“18-21” } Now we refresh our browser, RTEM, and add the new view template that we named and put some copy in it: &lt;!-- app/views/calculation_templates/random_results.html.erb --&gt; &lt;h1&gt;howdy&lt;/h1&gt; And if we refresh and get no error message, our RCAV is complete and now we just need to get the view template to actually render what we want. Try to manually navigate the URL to /random/results?user_min=1.5&amp;user_max=4.5. Now go to the GitPod server terminal (as usual Cmd + J to open or close it, and Cmd + K to clear the log for a better view) and you will see the query string transcribed in the Parameters Hash, which we know is accessible anywhere in our Rails app by params = { key =&gt; value}, or, in this case: params = { \"user_min\" =&gt; \"1.5\", \"user_max\" =&gt; \"4.5\" }. Okay so let’s get this out in our action: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def blank_square_form render({ :template =&gt; &quot;calculation_templates/square_form.html.erb&quot; }) end def calculate_square # params = {&quot;elephant&quot;=&gt;&quot;42&quot;} @num = params.fetch(&quot;elephant&quot;).to_f @square_of_num = @num * @num render({ :template =&gt; &quot;calculation_templates/square_results.html.erb&quot; }) end def calculate_random # params = {&quot;user_min&quot;=&gt;&quot;1.5&quot;, &quot;user_max&quot;=&gt;&quot;4.5&quot;} @lower = params.fetch(&quot;user_min&quot;).to_f @upper = params.fetch(&quot;user_max&quot;).to_f render({ :template =&gt; &quot;calculation_templates/random_results.html.erb&quot; }) end end {: mark_lines=“19-22” } And then add these instance variables in the rendered view template: &lt;!-- app/views/calculation_templates/random_results.html.erb --&gt; &lt;h1&gt;howdy&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;Minimum&lt;/dt&gt; &lt;dd&gt;&lt;%= @lower %&gt;&lt;/dd&gt; &lt;dt&gt;Maximum&lt;/dt&gt; &lt;dd&gt;&lt;%= @upper %&gt;&lt;/dd&gt; &lt;dt&gt;Random Number&lt;/dt&gt; &lt;dd&gt;Something&lt;/dd&gt; &lt;/dl&gt; {: mark_lines=“5-14” } Something above is just a placeholder. I leave that to you to calculate in the action and place in the view template. But let’s refresh our new /random/results?user_min=1.5&amp;user_max=4.5 page. We see that indeed the URL query string has been parsed and turned into the instance variables which were then embedded in my view template. Try and just manually change the URL to /random/results?user_min=0&amp;user_max=2. The page will change when you hit enter and we never used the form page. So the two routes are independent. In theory, the savvy user could manually change the URL to get new results, but this isn’t so nice and we can’t expect our users to know how to do this. That’s why we use forms and wire things together. But remember: during the lifecycle of a given RCAV, only that route, action, and view template exist. Time for a /git commit, and a rails grade to see what’s left for you to do. 13.7.1 Text Companion: Independence of Routes "],["finish-and-submit-omnicalc-1.html", "13.8 Finish and Submit Omnicalc 1", " 13.8 Finish and Submit Omnicalc 1 Notes: Below are relevant notes for the rest of the project taken from the README 13.8.1 The Target The way the assignment should work is: If I visit the ROUTE /square/new, I should see a form with a label and an input to enter a number. If I submit that form, I should see the square of the number that I entered. If I visit the ROUTE /square_root/new, I should see a form with a label and an input to enter a number. If I submit that form, I should see the square root of the number that I entered. If I visit the ROUTE /payment/new, I should see a form with labels and inputs to enter three values: The APR (annual percentage rate). The number of years remaining. The present value. If I submit that form, I should see the monthly payment due given the values that I entered. Mind your units! Use this formula: Payment formula Hint 1: The number of periods, n, that we receive from the user is in years. Since we’re calculating monthly payment we multiply it by 12. Hint 2: apr comes in as a string. We should turn it into a float and divide the number by 100 to get the percentage. Hint 3: r in the formula is a percentage per period. One period is equal to one month. The apr we receive from the user is yearly. Hint 4: Create a variable for the numerator and another one for the denominator. If they are instance variables, you can view them within your view page. If your output does not match the target, having done this will make debugging much more manageable. If I visit the ROUTE /random/new, I should see a form with labels and inputs to enter two numbers, a minimum and a maximum. If I submit that form, I should see a random number that falls between the numbers that I entered. You can compare your app against the target, including doing “View Source” to look at some of the static HTML. 13.8.2 Valid, Accessible Forms In order for your tests to pass, you must build valid forms (your Chrome browser may tolerate invalid forms while you are manually testing, but automated test suites reject invalid forms): Each &lt;input&gt; in the form must have a unique id=\"\" attribute. The &lt;label&gt; associated with the &lt;input&gt; should have a for=\"\" attribute that matches the value of the &lt;input&gt;’s id. The copy within the &lt;label&gt; must exactly match the target — spelling, capitalization, and punctuation matter for labels. The same goes for the copy on the button to submit the form. Any invalid HTML within a form will cause the test to fail, e.g. an orphaned closing &lt;/div&gt; tag. Keep your code neatly indented to help avoid this. An example of a valid form; in particular, notice the id=\"\" and for=\"\" attributes: &lt;form action=&quot;/random/results&quot;&gt; &lt;div&gt; &lt;label for=&quot;min_input&quot;&gt; Minimum &lt;/label&gt; &lt;input id=&quot;min_input&quot; type=&quot;text&quot; name=&quot;user_min&quot; placeholder=&quot;E.g. 1.5&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;max_input&quot;&gt; Maximum &lt;/label&gt; &lt;input id=&quot;max_input&quot; type=&quot;text&quot; name=&quot;user_max&quot; placeholder=&quot;E.g. 4.5&quot;&gt; &lt;/div&gt; &lt;button&gt; Pick random number &lt;/button&gt; &lt;/form&gt; 13.8.3 Additional Hints The to_s method can format Floats in more specific ways that help us easily display data in a variety of ways. In particular these two: .to_s(:currency) .to_s(:percentage) could be useful when formating the output of the payment form. "],["fortune-teller.html", "14 Fortune Teller", " 14 Fortune Teller Notes: Original video transcription is in fortune-teller.md Project (graded): https://github.com/appdev-projects/fortune-teller Target: https://fortune-teller.matchthetarget.com/ Useful chapters: adding-routes.md rcav-flowchart.md Routing - RCAV Slides "],["video-segment-routes-and-controllers-in-fortune-teller.html", "14.1 Video Segment: Routes and Controllers in Fortune Teller", " 14.1 Video Segment: Routes and Controllers in Fortune Teller Notes: time stamp 00:03:28 to 00:10:50 practice routing stepping away from app/controllers/application_controller.rb, and using app/controllers/numbers_controller.rb inheritance: NumbersController &lt; ApplicationController &lt; ActionController::Base Our plan for today is to practice the very important thing for this week which is routing. How do you connect a particular visit to a URL to a Ruby method, and then generate some dynamic HTML and send it back. So that will be the day today. Practicing that over and over. BENP: insert references to previous RCAV material here, like adding-routes.md and RCAV-flowchart.md This fortune teller project will be the first in a series of debugging projects. So rather than building up an app from scratch, we’ll start with a completed app that we have planted pernicious bugs in. You have to go through and figure out how to Read The Error Messages, RTEM. Again, RTEM is the most important skill to develop, not being able to just scan the code and spot what’s wrong. Let the error messages help you. If navigate to your app in the browser, you should be on the homepage /lottery/lucky which shows you five lucky numbers in a bulleted list. Each time we refresh, the numbers are changing. So this is a dynamic page and not a static page in the /public folder on GitPod. Let’s see what we are starting out with by going to our application on the GitPod workspace and opening our file config/routes.rb: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end BENP: not sure about the ... notation above to indicate code In many senses, this is the most important file. This is the list of all of the URLs that users are allowed to visit in our app, so it’s also a great place for us to start when we’re trying to get to know a new codebase. If we look at this we can see there are two routes users can currently visit /lottery/lucky and /. We can return to our browser and test those two URLs. They will bring us to the same lucky numbers page. But if I try to visit anything else, like if I click on any of the navbar links, all other URLs don’t work right now. One thing we notice right away is that both paths in our config/routes.rb are using the same controller and action: { :controller =&gt; \"numbers\", :action =&gt; \"winners\" }. And also, this controller called \"numbers\", is different from \"application\". The app/controllers/application_controller.rb is the file we have always used up to this point, as this is the ApplicationController that comes with every Rails application out-of-the-box. But, we can create our own controllers to keep things more organized. If you specify something after :controller =&gt; besides \"application\", like \"numbers\", then you need to create the file yourself in the app/controllers/ folder. If we navigate to that folder, we see we have six controllers now. application_controller.rb is in there, but if we open it we see it’s empty: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base end because we haven’t used it in our app. Instead if we open the \"numbers\" controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController ... end end We see that we’ve inherited (&lt;) from ApplicationController, so we get all the power – all the methods – that our ApplicationController inherited from the Rails ActionController::Base. ApplicationController is a “child” of ActionController::Base and ApplicationController is a “parent” of NumbersController. Written out that would look like NumbersController &lt; ApplicationController &lt; ActionController::Base. BENP: added that last two sentences based off some student questions in video This is a better way of organizing our controllers because in any standard app you are going to have dozens or hundreds of actions and ApplicationController would get cluttered if we put them all in the same file. We may ask, with multiple controllers, can we share data (e.g., instance variables with the @-notation) across the controllers? The answer is, not really. Because when someone visits a particular URL in our app, at that moment Rails goes and looks up a single controller action and runs it. At any given moment, only one route is every being used by a user. So it doesn’t matter if I have ten thousand actions in ApplicationController or spread across multiple child controllers, but they don’t need to every communicate with each other. The action is run, we send the HTML back, and the request is done until the user visits another route. 14.1.1 Text Companion: Routes and Controllers in Fortune Teller "],["video-segment-.each-loop-on-instance-variable.html", "14.2 Video Segment: .each Loop on @ Instance Variable", " 14.2 Video Segment: .each Loop on @ Instance Variable Notes: time stamp 00:10:50 to 00:17:37 from @zebra instance variable array to .each loop in the view template for /lottery/lucky embedded Ruby tags &lt;%= %&gt; vs. &lt;% %&gt; Okay, so as we saw in our config/routes.rb, the action triggered when visiting /lottery/lucky or / is called winners in our controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“4-14”} We chose to write this by first creating a new array (@zebra = Array.new), then we used the times method to generate a random number in a variable called giraffe and push the number into the @zebra array five times. There are other ways to do this, like creating five separate variables and putting a random number in each, that would have worked, but in this case I’m rendering the template \"lottery_stuff/woohoo.html.erb\", with only one instance variable, the array @zebra. Let’s look at that template in app/views/lottery_stuff: &lt;!-- app/views/lottery_stuff/woohoo.html.erb --&gt; &lt;h1&gt;Lucky numbers&lt;/h1&gt; &lt;p&gt;Your lucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;% @zebra.each do |elephant| %&gt; &lt;li&gt; &lt;%= elephant %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8-12”} BENP: Again, notes about using elephant, zebra, giraffe. I wonder if it’s better to use thoughtful variable names from the beginning and avoid this. The crucial part is highlighted. In our .erb template, we are using .each on our instance variable array @zebra. Inside of the looping block, we write HTML to display the variable using the &lt;%= %&gt; embedded Ruby tag. We could name the block variable elephant whatever we want (as long as we change the name in the loop as well as between the pipes ||). It only exists in our loop and is not from the controller action. This instance variable loop-and-display technique is something we are going to be doing a lot. This is a main reason we spent all that time learning about .each. Very often we have records from a database table and we need to format and display those records with this technique. We could change the above code and see what happens. Let’s do this: &lt;!-- app/views/lottery_stuff/woohoo.html.erb --&gt; &lt;h1&gt;Lucky numbers&lt;/h1&gt; &lt;p&gt;Your lucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;%= @zebra.each do |elephant| %&gt; &lt;li&gt; &lt;%= elephant %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“8”} We added an = sign to the first embedded Ruby tag. Now if we refresh the app in our browser on the /lottery/lucky page, we will see the full array printed below our list, because we have made this previously invisible line (this tag: &lt;% %&gt;) visible (this tag: &lt;%= %&gt;). When done looping, .each returns the array itself when it is called. We don’t typically want or need to view this though. You can remove that added = sign from the HTML view template after you do this, because this line is not meant to be displayed, but rather to control the flow of our embedded Ruby. We already saw this with if statements for our Rock Paper Scissors RCAV project. 14.2.1 Text Companion: .each Loop on @ Instance Variable "],["video-segment-rcav-lotteryunlucky.html", "14.3 Video Segment: RCAV /lottery/unlucky", " 14.3 Video Segment: RCAV /lottery/unlucky Notes: time stamp 00:17:37 to 00:27:18 RCAV practice. re-do the /lottery/lucky but with different copy. try to type everything, avoid copy-paste Our first task in the README, was to study /lottery/lucky, and we’ve done that. Now let’s take a moment to build /lottery/unlucky. This is basically the same page, just with some different copy. Follow the usual RCAV. If you want a reference sheet you can have a look here. BENP: do we want that chapter linked still? We click the navbar or manually enter the URL to get to /lottery/unlucky, and we see the “No route matches” error. So we go into config/routes.rb and add that: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/lottery/unlucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;losers&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end {: mark_lines=“10”} Now we can refresh the browser and see we need to add the losers action to our controller: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def losers end def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“4-6”} Now it is up to you to complete the action code and render the result in a view template that will be very similar (though not identical) to app/views/lottery_stuff/woohoo.html.erb. Try to type everything out by yourself and avoid any copy-pasting. This is good practice! BENP: Break here where the students worked on this from 00:19:30 to 00:25:00 Let’s look at the completed action code: # app/controllers/numbers_controller.rb class NumbersController &lt; ApplicationController def losers @numbers = Array.new 5.times do a_number = rand(1...100) @numbers.push(a_number) end render({ :template =&gt; &quot;lottery_stuff/ohno.html.erb&quot;}) end def winners @zebra = Array.new 5.times do giraffe = rand(1...100) @zebra.push(giraffe) end render({ :template =&gt; &quot;lottery_stuff/woohoo.html.erb&quot;}) end end {: mark_lines=“5-13”} Note that we used some different variable names, and these are up to us to choose: @numbers for the array of random numbers and we call each individual number a_number. And we also can create the specified view template and filled it in. We start with this: &lt;!-- app/views/lottery_stuff/ohno.html.erb --&gt; &lt;h1&gt;Unluck numbers&lt;/h1&gt; &lt;p&gt;Your unlucky numbers for today are:&lt;/p&gt; &lt;%= @numbers %&gt; Now refreshing /lottery/unlucky should display our copy and our array of numbers with no formatting. Nice, almost there. Let’s add a loop and put our numbers into the proper format: &lt;!-- app/views/lottery_stuff/ohno.html.erb --&gt; &lt;h1&gt;Unluck numbers&lt;/h1&gt; &lt;p&gt;Your unlucky numbers for today are:&lt;/p&gt; &lt;ul&gt; &lt;%= @numbers.each do |num| %&gt; &lt;li&gt; &lt;%= num %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“7-12”} And now /lottery/unlucky should match the target. Test it manually to see, and when you’ve done that… Time for a /git commit, and maybe even a rails grade to see what’s left to do. 14.3.1 Text Companion: RCAV /lottery/unlucky "],["video-segment-navbar-and-zodiac-debugging.html", "14.4 Video Segment: Navbar and Zodiac Debugging", " 14.4 Video Segment: Navbar and Zodiac Debugging Notes: time stamp 00:27:18 to 00:36:30 aside to app/views/layouts/application.html.erb to show debug /zodiacs/aries together RTEM In the target, there are three navbar sections. We already did the top lottery section. There are twelve links in the horoscopes section. If you click the link you will see that each displays some text and then lucky numbers again. Below the horoscipes there is a section for dice, which simulates rolling a certain number of dice with a certain number of sides. For instance, “5d6” means roll five six-sided dice. In our app (not the target), none of the horoscope or dice links work. Here’s your task. First, the required part of this homework is debugging the 12 zodiacs. There are already links and routes. BENP: An aside starts below, could be moved elsehwere By the way, where does all the navbar HTML come from? In the templates we made (e.g., app/views/lottery_stuff/woohoo.html.erb), we did not include any header information in the HTML code. That’s because all of this is in the wrapper file, specifically app/views/layouts/application.html.erb: &lt;!-- app/views/layouts/application.html.erb --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Fortune Teller&lt;/title&gt; &lt;%= csrf_meta_tags %&gt; &lt;!-- Expand the number of characters we can use in the document beyond basic ASCII  --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- Make it responsive to small screens --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;%= csp_meta_tag %&gt; &lt;%= stylesheet_link_tag &#39;application&#39;, media: &#39;all&#39; %&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;%= yield %&gt; &lt;/body&gt; &lt;/html&gt; Where we have the ..., you should see all of the navbar links in an HTML table, which is applied as a header to all of our pages. The pages are placed where we see the &lt;%= yield %&gt; tag. This app/views/layouts/application.html.erb file that comes with every Rails app is where you would place anything that you want on all of your pages. Okay, back to the zodiac debugging. If we go to our routes, we will see: # config/routes.rb Rails.application.routes.draw do # PART 1: EACH IN ERB # =================== get(&quot;/lottery/lucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;winners&quot; }) get(&quot;/lottery/unlucky&quot;, { :controller =&gt; &quot;numbers&quot;, :action =&gt; &quot;losers&quot; }) # Let users visit URLs: # - /lottery/unlucky # PART 2: R→C→A→V DEBUGGING # ====================== # Uncomment each route below ONE AT A TIME and debug. # Do NOT uncomment more than one at a time, or you&#39;ll be dealing with multiple syntax errors at once. # get(&quot;/zodiacs/aries&quot;, { :controller =&gt; fire, action =&gt; &quot;ram&quot; }) # get(&quot;/zodiacs/leo&quot;, { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;lion&quot; }) # get(&quot;/zodiacs/sagittarius&quot; { :controller =&gt; &quot;fire&quot;, :action =&gt; &quot;archer&quot; }) ... end {: mark_lines=“22-24”} And we can just begin uncommenting (remove the leading # from the line) each route and debugging them one at a time. Uncomment each route ONE AT A TIME and debug it ONE AT A TIME. Don’t uncomment multiple at once, or you’ll have multiple syntax errors at once and the error messages can’t help you. Let’s begin by uncommenting get(\"/zodiacs/aries\", { :controller =&gt; fire, action =&gt; \"ram\" }) and then in our app try to visit the given path: /zodiacs/aries. Now RTEM: There&#39;s a problem with your routes.rb file. unrecognized `fire&#39; . So let’s look at our routes file, and what do we see? Oops, where is says :controller =&gt; fire, it should say :controller =&gt; \"fire\", with string quotation marks. Without the quotations, Ruby thinks fire is a local variable because it begins with a lowercase letter. But we never defined a variable called fire, that is the name we assigned to our controller and we have a controller file called app/controllers/fire_controller.rb, which is what we want Rails to look for. Okay, we made this change and now we refresh our browser on /zodiacs/aries, and we get a new error: There&#39;s a problem with your routes.rb file. unrecognized `aciton&#39; . Did you mean? action_path Because in our route we have action =&gt; \"ram\", which should be :action =&gt; \"ram\", adding a colon to make action into a symbol in the hash. And refresh /zodiacs/aries again, and another error to deal with: ActionController::RoutingError at /zodiacs/aries uninitialized constant FireController Did you mean? FiresController AirController Hmm. This means we have not defined the class FireController. So let’s look in our app/controllers/ directory and we see a controller called fires_controller.rb. There is an extra s on fires, whereas we wrote in our route: :controller =&gt; \"fire\". So rename the controller to fire_controller.rb and refresh again /zodiacs/aries, and we succeeded! One thing to note. If you think you did everything correctly but are still getting error messages, then go to GitPod, shut down your server in the terminal by using Ctrl + C, and restart with bin/server. This sometimes happens with filename or foldername changes. Time for a /git commit, and maybe even a rails grade to see what’s left to do. And now you can proceed on your own with the config/routes.rb file as we’ve done above. Uncomment, RTEM, and proceed. 14.4.1 Text Companion: Navbar and Zodiac Debugging "],["finish-and-submit-fortune-teller.html", "14.5 Finish and Submit Fortune Teller", " 14.5 Finish and Submit Fortune Teller Notes: Below are relevant notes for the rest of the project taken from the README 14.5.1 Debugging checklist READ the error message. Extract as much useful information from it as possible. If there’s no error message, find another way to give yourself feedback; make the invisible visible. Use the server log. Print things; in this new world, that means use embedded Ruby tags (&lt;%= %&gt;) in the view templates. We can’t use the p method anymore since we aren’t writing command line programs anymore. If all else fails — the error message isn’t helpful, or there isn’t one and you can’t spot the issue visually — delete the offending code (or comment it out), and re-type the R→C→A→V from scratch. Hopefully you’ve been making lots of git commits, so there’s no fear in doing so. 14.5.2 More RCAV Practice In the nav, there are links to 18 pages that simulate rolling dice in various combinations that are useful for board games (six-sided dice, from one die up to six dice) and other, more exotic dice combinations that are useful for e.g. Dungeons &amp; Dragons. Right now, none of those URLs work; and the routes don’t even exist. Implement them, one at a time. Try to type them out rather than copy-pasting; the point is to build muscle memory and encounter error messages in a controlled setting. There are no automated tests for Part 3; this is just extra reps for practice. 14.5.3 Reflections Of the error messages that you encountered during debugging, which ones were most helpful? Which ones were least helpful? In this project, the subfolders within app/views/ that we store our ERB templates in had various different suffixes: app/views/lottery_stuff/ app/views/flame_interface/ app/views/nature_templates/ app/views/wind_html/ app/views/aqua/ (no suffix) If you had to pick one style for us to use consistently in the future, which do you prefer? Or can you think of a different subfolder naming convention that you would prefer more? You now know how to respond to visits to URLs with dynamically generated HTML. This is, fundamentally, how Twitter, GitHub, Basecamp, NYTimes, Airbnb, and every other web application works. But, of course, we have a lot more to learn before we could build, for example, a social network. What are we still missing? What are you most curious to learn next? "],["omnicalc-2.html", "15 Omnicalc 2", " 15 Omnicalc 2 Notes: Original video transcription is in Omnicalc-Part2.md Project (graded): https://github.com/appdev-projects/omnicalc-2 Target: https://omnicalc-2.matchthetarget.com/ username: appdev password: fullstack Useful chapters: forms-query-strings-and-params.md omnicalc-api.md meteorologist-intro-to-apis.md storing-credentials-securely.md google-translate.md sending-emails-and-texts.md Right now a bunch of this found much later in the Day 5 material on Canvas. See my notes below, APIs might need devoted video (maybe one for each API). "],["video-segment-exploring-the-target.html", "15.1 Video Segment: Exploring the Target", " 15.1 Video Segment: Exploring the Target Notes: time stamp 00:38:36 to 00:42:54 doing math, intro to APIs Street to Coordinates Translate with SMS Forms are incredibley important to us. The first layer of building a dynamic application is connecting the Route, Controller, Action, View. Having some variables displayed on the page so it is dynamic and not static HTML. The second thing we need to do is accept information from our users because just generating random stuff on a page is boring, so we’ll be building tons and tons of forms for the rest of the quarter. Omnicalc 2 is very similar to Omnicalc 1, where you began to learn forms in that homework. In this case, if I have a look at config/routes.rb, the file is empty: # config/routes.rb Rails.application.routes.draw do # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end So will need to build up the target step-by-step. When you open this app, you need to enter a username (appdev) and password (fullstack). The reason for this, is because, if we have time, we’re going to do some more fun things than we’ve done so far. Instead of just getting numbers and doing some math, we’ll be doing some more fun things. For example if we look in the target, there’s a “Street to Coordinates” calculator. If you type in and address here, like “5807 S Woodlawn Ave” and click “Lookup Coordinates”, then it displays latitude and longitude. So all the form entry steps are the same as what you’ve already done, but the application does much more here. How did we get from a street address to these coordinates? What’s the Ruby for that? Well, we’re going to learn how to do that. Even more cool, there’s a link in the target called “Translate”. Ff we fill out this form, maybe with “Ruby is the best!” in the first box, and then select a language from the second drop down menu (e.g., Chinese (simplified)), and put in a phone number in the last box with the country code (e.g., +1 for USA), and finally hit translate, then the text gets translated and the number we entered gets a text message with that translation! It’s still all about entering in forms, but the way we achieve these responses is very empowering. This is known as Application Programming Interface, or API, programming. This means that other companies, like Google, will allow us to Create, Read, Update, and Delete information in their databases, and they will send back information that they have. We don’t need to create their data, we can use their resources. Both the street to coordinates and translation service above is provided by Google (actually the text messaging part is another company called Twilio). We also have link to “Street to Weather” or “Coordinates to Weather”. These use two APIs, one for Google to get the location, and the second is the DarkSky API to get back a detailed weather forecast. 15.1.1 Text Companion: Exploring the Target "],["video-segment-reviewing-query-strings.html", "15.2 Video Segment: Reviewing Query Strings", " 15.2 Video Segment: Reviewing Query Strings Notes: time stamp 00:42:54 to 00:50:45 examine target /wizard_add and implement using query string and params All that said, the important goal of this project (and the required part) is building forms, so let’s do one of the four forms together now: Add, Subtract, Multiply, Divide. We will focus on the “Add” form. Let’s visit /add in our Rails app browser. As expected we get a “No route matches” error. So we will need to build this up step-by-step. But first, observe the target app. In each calculator there are two actions. There is one action that just displays the form. Then when I fill out the form and press the button, it takes me to a different URL. If we fill out “Add” with “4” in the first number and “10” in the second, then press the button, the resulting URL on the “Addition” page looks like /wizard_add?first_num=4&amp;second_num=10. Any of the other forms on our target works this same way: the information we put in the form is placed as variables in the URL query string preceded by the ? character. If I know how this form works, I can just type directly into the URL with new variable values, and I will get a new result. I never even need to visit the form page. I want to emphasize here, the form and second action that does the work are two totally separate independent actions. We use forms because we want a nice interface for our users. It is polite to add a form for our users, who are not developers like us. We’ll implement /add now, but we will go backwards. First, I’m going to implement the second step /wizard_add: # config/routes.rb Rails.application.routes.draw do get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“5”} My selection for the :controller and :action names above, mean I’ll need to create these in out app. So in the app/controllers/ folder we need to make a new file math_controller.rb and fill it in with our inherited ApplicationController functionality and our new action: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_results render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end And our selection to just render some HTML, means that we also need to create the view template. So in the app/views/ folder we need to first make a new folder math_templates/ and then a new file in that folder called add_results.html.erb. And in this file we can put some placeholder text to render: &lt;!-- app/views/math_templates/add_results.html.erb --&gt; hi Now if we didn’t make any typos and visit or refresh /wizard_add, we will see our rendered HTML. You will also already see a navbar, that we included in the app, and this, as you have already seen, is in the app/views/layout/application.html.erb file that is applied to every page. Now if a user includes a query string in the URL, like /wizard_add?zebra=bob, there is no effect on the routing when we press enter. But if we look into our server log in the GitPod terminal tab running your server (Cmd-K or Ctrl-K to clear it out), we can find: ... HTML Parameters: {&quot;zebra&quot;=&gt;&quot;bob&quot;} Rendering math_templates/add_results.html.erb Rendered math_templates/add_results.html.erb within layouts/application ... Our query string that is automatically split, parsed, and added to params. All before I have built the form. Let’s use the expected query string: /wizard_add?first_num=4&amp;second_num=10. And observe now in the server log: ... HTML Parameters: {&quot;first_num&quot;=&gt;&quot;4&quot;, &quot;second_num&quot;=&gt;&quot;10&quot;} Rendering math_templates/add_results.html.erb Rendered math_templates/add_results.html.erb within layouts/application ... {: mark_lines=“3”} We can now pull out this information in our action: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_result @first = params.fetch(&quot;first_num&quot;) @second = params.fetch(&quot;second_num&quot;) @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“5-9”} And display the instance variables on our view template: &lt;!-- app/views/math_templates/add_results.html.erb --&gt; &lt;%= @result %&gt; {: mark_lines=“3”} And if we now refresh /wizard_add?first_num=4&amp;second_num=10, we see the result displayed as “410”. Why? Because we are adding two strings in our action! We need to remember to convert them to floats or integers to do math on them: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_results @first = params.fetch(&quot;first_num&quot;).to_f @second = params.fetch(&quot;second_num&quot;).to_f @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“5 7”} And now we should get “14.0” on our page. We won’t flesh out all the copy and formatting to get our HTML view template to match the target page, but this should be straightforward. 15.2.1 Text Companion: Reviewing Query Strings "],["video-segment-reviewing-forms.html", "15.3 Video Segment: Reviewing Forms", " 15.3 Video Segment: Reviewing Forms Notes: time stamp 00:50:45 to 00:58:00 examine target /add and implement using forms Our results page works, but it’s a pain for our users to type in the URL query string. If they make any mistake like typing “first_number” instead of “first_num”, like /wizard_add?first_number=4&amp;second_num=10, they would get the error: param is missing or the value is empty: first_num because in our add_result action in our MathController, we have @first = params.fetch(\"first_num\").to_f. But \"first_num\" does not exist in our params variable, because the user accidentally named it first_number in the URL. Hence, we need a form for the user to type into. So the usual RCAV here: # config/routes.rb Rails.application.routes.draw do get(&quot;/add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_form&quot; }) get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“5”} Then: # app/controllers/math_controller.rb class MathController &lt; ApplicationController def add_form render({ :template =&gt; &quot;math_templates/add_form.html.erb&quot; }) end def add_results @first = params.fetch(&quot;first_num&quot;).to_f @second = params.fetch(&quot;second_num&quot;).to_f @result = @first + @second render({ :template =&gt; &quot;math_templates/add_results.html.erb&quot; }) end end {: mark_lines=“4-6”} Put some copy in the new view template we create: &lt;!-- app/views/math_templates/add_form.html.erb --&gt; hi And when we see our URL /add loads with no error, we can put together our form in the view template to finish things off: &lt;!-- app/views/math_templates/add_form.html.erb --&gt; &lt;form action=&quot;/wizard_add&quot;&gt; &lt;input name=&quot;first_num&quot;&gt; &lt;input name=&quot;second_num&quot;&gt; &lt;button&gt; Add &lt;/button&gt; &lt;/form&gt; {: mark_lines=“3-11”} The all important action=\"/wizard_add\" attribute in the opening &lt;form&gt; tag, tells the form that when we click the &lt;button&gt;, then route to /wizard_add, which activates the first RCAV we built to do the computation. This is the most basic, working version of the form, but you will need to add a lot more like the input labels. Of course, we want a valid form, so you will need to include the matching for=\"\" and id=\"\" attributes for each &lt;label&gt; and associated &lt;input&gt;, and make sure everything matches the target. BENP: could link to forms-query-strings-and-params.md chapter or whatever that content becomes Complete the rest of the assignment on your own and make sure to be /git committing anytime you get something working with rails grade. You will need to wire up all RCAVs and the associated forms for “Add”, “Subtract”, “Divide”, and “Mulitply”. BENP: From below, I think a new chapter /recording / chapter is in order. 15.3.1 Text Companion: Reviewing Forms "],["video-segment-intro-to-apis-with-street-to-coordinates.html", "15.4 Video Segment: Intro to APIs with Street to Coordinates", " 15.4 Video Segment: Intro to APIs with Street to Coordinates Notes: time stamp 01:00:00 to 01:21:00 there is a bunch of explanation here about APIs implementing /experiment for “Street to Coordinates” API keys JSON Google Maps API JSON to Hash with JSON.parse(open(@url).read) Let’s begin to experiment with APIs in our app. One of the homework videos for next week includes some API work, but we will get a taste here. First we will add a route to experiment with: # config/routes.rb Rails.application.routes.draw do get(&quot;/add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_form&quot; }) get(&quot;/wizard_add&quot;, { :controller =&gt; &quot;math&quot;, :action =&gt; &quot;add_results&quot; }) get(&quot;/experiment&quot;, { :controller =&gt; &quot;application&quot;, :action =&gt; &quot;experiment&quot; }) # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html end {: mark_lines=“9”} We are just going to use the application_controller.rb file as our controller and add an action there experiment. # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“3-6”} We just put the new template again in the app/views/math_templates/ folder, just to experiment.html.erb. And here is a bunch of handy links (BENP: originally from README, can we remove some links? yes definitely) with information on APIs: JSONView Chrome extension Dark Sky forecast at the Merchandise Mart for humans Dark Sky forecast at the Merchandise Mart for machines: https://api.darksky.net/forecast/REPLACE_THIS_PATH_SEGMENT_WITH_YOUR_API_TOKEN/41.8887,-87.6355 Dark Sky API docs Map of Merchandise Mart for humans Map of Merchandise Mart for machines: https://maps.googleapis.com/maps/api/geocode/json?address=Merchandise%20Mart%20Chicago&amp;key=REPLACE_THIS_QUERY_STRING_PARAMETER_WITH_YOUR_API_TOKEN Google Geocoding API docs How to store secrets securely on Gitpod If we look at the target and navigate to “Street to Coordinates”, BENP: video cuts out … the reason for that is, it costs money. Each time we’re making an API call, they are tracking our use and charging us if we are above some limit. GoogleMaps has a very high limit of API calls before charging begins, but the text messaging in the “Translate” page costs money for every message. That is why we have password secured the target in this case. So this is something to keep in mind: if you start to play around with APIs and sign up for an account with a credit card, then be careful with your API credentials! In this project any necessary API credentials are made available to you BENP: these are from Canvas and probably should not be / or should be changed in the final material. ALL API KEYS LABELLED AS TODO: TWILIO_ACCOUNT_SID : TODO TWILIO_AUTH_TOKEN : TODO TWILIO_SENDING_PHONE_NUMBER : TODO MAILGUN_API_KEY : TODO MAILGUN_SENDING_DOMAIN : TODO GMAPS_KEY : TODO DARK_SKY_KEY : TODO TRANSLATE_PROJECT : omnicalc TRANSLATE_CREDENTIALS : { TODO } So you can feel free to play around. But with your own credentials, be careful and protect them. BENP: could link to storing-credentials-securely.md content here How do I begin to think about tackling “Street to Coordinates”? I have an address and I want the latitude and longitude. I don’t want to use my company resources to building up a huge database of this information that I can lookup in. So let’s use Google’s Geocoding API. The first step of any API work is doing some homework. Search around on the internet for different options and read through some of the documentation. If we look around in the Google documentation, we would find a URL: https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY What do we see? We have an address: https://maps.googleapis.com/maps/api/geocode/json and a query string: ?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY. And we can see the query string includes an address= variable, and a key= variable. If we try to visit the URL as it is, we would see a page like: // 20221217132605 // https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=YOUR_API_KEY { &quot;error_message&quot;: &quot;The provided API key is invalid. &quot;, &quot;results&quot;: [ ], &quot;status&quot;: &quot;REQUEST_DENIED&quot; } We see an error message. Because we need to replace YOUR_API_KEY, with our API key! So we can go into a new tab and try to do that with our GMAPS_KEY BENP: this key is expired and needs to be changed everywhere above and below: https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=TODO And when we enter this address in the tab, we should see a very long JSON file displayed in our browser, something like: // 20221217131844 // https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&amp;key=TODO { &quot;results&quot;: [ { &quot;address_components&quot;: ... } ... ] } There may be several hundred lines displayed and it may not be broken into readable lines if you don’t have a third party extension like JSON Viewer for Chrome. If you examine the page, you will see lots of information about the address we entered. JSON, or Javascript Object Notation, is not the same format as HTML. JSON is somewhat similar to CSV, and there is another format called XML that many APIs use. These are all just different data formats that are much easier to parse programmatically compared to HTML. If I change the query string in my URL to whatever I want (even with spaces): https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO Then the JSON information will change to give me information on that address 5807 S Woodlawn Ave. If I look carefully and scroll down, I could even find the following: ... &quot;location&quot;: { &quot;lat&quot;: 41.7891387, &quot;lng&quot;: -87.5954555 }, ... Ahh, just what we needed to display on our “Street to Coordinates” result page! Wow, APIs seem intimidating, but in reality it’s just a URL that we provide and we get back information from a database owned by some company. Once we get to the stage of entering a URL with some form data and receiving a response, then it’s actually pretty simple to finish our app. Now it’s time to actually get our form and results working. We’ll start by just copying our working URL into the experiment action in our GitPod app: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“5”} (You may see %20 characters in the place of the URL spaces we put in, like 5807%20S%20Woodlawn%20Ave. You can copy those in too, they just mean “space”.) And now we can use some cool methods for opening (open built into Ruby): # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url) render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“7”} Now if we open our view template and inject this instance variable in: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; &lt;%= @raw %&gt; {: mark_lines=“3”} then load the URL /experiment in our app browser, we will see “#” or something similar. This is an object of class String, which contains that page. We can call another method on this in the view template: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; &lt;%= @raw.read %&gt; {: mark_lines=“3”} which will get the body of the page and return is as a string when we refresh the browser. This will be the entire (long) JSON string. We can put all this into the action: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url).read render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“7”} We could now remove the .read from our HTML view template. We can go into our action and change address=5807 S Woodlawn Ave in the URL to whatever we want (e.g., address=Miami FL), and if we refresh /experiment then we will see the JSON changing. The page now dynamically reacts using information from the Google API. Now, we can also parse the JSON (which is currently just a long String variable) to get just the information we want. We don’t want to directly parse the string (e.g., with .split()). There is a much better way: we can convert it into a Hash using the built in class JSON and one of its methods, parse(), to convert it to a Hash. Then we can take our Hash, bury through the key/value pairs (there are Hashes within the Hash!), and figure out where the latitude and longitude values are to then pull out (.fetch()) as instance variables and put on our webpage. Alltogether that looks like: # app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base def experiment @url = &quot;https://maps.googleapis.com/maps/api/geocode/json?address=5807 S Woodlawn Ave&amp;key=TODO&quot; @raw = open(@url).read @parsed = JSON.parse(@raw) # parsed is now a Hash class # and we bury down into the hash with the key/value pairs # to get what we want @results = @parsed.fetch(&quot;results&quot;) @geom = @results.fetch(&quot;geometry&quot;) @loc = @geom.fetch(&quot;location&quot;) @lat = @loc.fetch(&quot;lat&quot;) @lng = @loc.fetch(&quot;lng&quot;) render({ :template =&gt; &quot;math_templates/experiment.html.erb&quot; }) end end {: mark_lines=“9-17”} And display that in our experiment template: &lt;!-- app/views/math_templates/experiment.html.erb --&gt; Latitude &lt;%= @lat %&gt;, Longitude &lt;%= @lng %&gt; {: mark_lines=“3”} Now, we hard-coded an address 5807 S Woodlawn Ave into our experiment action in the @url variable, so we would need this to come from an associated input form so the user could change this string. That is not required, but is good practice if you implement it. 15.4.1 Text Companion: Intro to APIs with Street to Coordinates "],["finish-and-submit-omnicalc-2.html", "15.5 Finish and Submit Omnicalc 2", " 15.5 Finish and Submit Omnicalc 2 Notes: Below are relevant notes for the rest of the project taken from the README API stretch goal should maybe go in a separate place? BENP: I think all of this additional API stuff needs to go in a separate document with links to google-translate.md and sending-emails-and-texts.md documents that right now are just linked as optional exercises on the Day 5 material on Canvas 15.5.1 Your tasks Street to Coordinates: Figure out how to turn an arbitrary street address (find a place that is sort of rainy right now to test with) into a latitude/longitude using the Geocoding API. Coordinates to weather: Figure out how to turn a latitude/longitude pair into a weather forecast using the Dark Sky API Show the information displayed in the target: Current Temperature Current summaray Outlooks for next sixy minutes, several hours, several days Street to Weather: Put the above two together — given an arbitrary street address, display the forecast. 15.5.2 Stretch goal Stretch goal: check whether there is a &gt;50% chance of precipitation at any point during the next 12 hours. If so, we will print “You should take an umbrella!” Explore the API documentation to see what information is available to help you check this. Something that might or might not be useful: the Time.at method. (Humans have many, many different ways of representing dates. For the purposes of different pieces of software being able to agree on dates and times, most systems when talking to each other use Epoch time notation, or the number of seconds that have passed since midnight UTC on January 1st (minus leap seconds). Dark Sky, for example, includes times in this format. You can use Time.at() to convert to something more familiar, if you want to.) Put all of the pieces together; given an arbitrary address: print the current temperature print outlook for the next hour print whether a person should carry an umbrella. 15.5.3 Using gems to interact with APIs Interacting with APIs can be easier if someone has written a Ruby library (or “gem”) with methods that already know the URLs, parse the JSON, and return exactly the values we want. 15.5.3.1 Google Cloud Translate See this Chapter for a guide to using the Google Translate API via its first-party gem. Read more at the gem docs: Ruby gem documentation 15.5.3.2 Twilio See this Chapter for a guide to sending text messages via the Twilio API. 15.5.3.3 Stretch goal Make your app behave like the target! Accept some text from the user, ask for a target language, translate the text, and SMS it to a phone number. "],["refactoring-fortune-teller-with-dynamic-routes.html", "16 Refactoring Fortune Teller with Dynamic Routes", " 16 Refactoring Fortune Teller with Dynamic Routes Notes: There is no video yet, everything is in the chapter refactoring-fortune-teller-with-dynamic-routes.md, copied in below Project (graded): https://github.com/appdev-projects/refactoring-fortune-teller Target: https://refactoring-fortune-teller.matchthetarget.com Useful chapters: refactoring-fortune-teller-with-dynamic-routes.md rcav-flowchart.md This chapter is the companion to the refactoring-fortune-teller project, which is the sequel to the the fortune-teller project. "],["part-1-dice.html", "16.1 Part 1: Dice", " 16.1 Part 1: Dice Notes: dynamic route segments Copied from refactoring-fortune-teller-with-dynamic-routes.md chapter section get(\"/roll/:number_of_dice/:how_many_sides\", { :controller =&gt; \"dice\", :action =&gt; \"infinity_and_beyond\" }) params.fetch(\"number_of_dice\") and params.fetch(\"how_many_sides\") Our starting point code for refactoring-fortune-teller is the target code for fortune-teller. So, in the code you’re starting with, the horoscopes from Part 2 of fortune-teller have already been debugged, and the dice from Part 3 of fortune-teller have already been built out. In refactoring-fortune-teller, our goal is to keep everything working exactly the same way that it is; we’re not going to add much. But we’re going to get rid of 90% of the lines of code, while keeping the functionality the same. How? With dynamic route segments. Consider our new target: https://refactoring-fortune-teller.matchthetarget.com/roll/2/6 Seems like the same thing that we had before, right? Well, try this URL instead: https://refactoring-fortune-teller.matchthetarget.com/roll/42/1337 That’s a lot of 1337-sided dice. Try any combination of two numbers you want in the second and third segments of the path. You’ll see that they all work! Obviously, I didn’t just happen to add routes for the exact pairs of numbers you chose. Instead, there’s only one route handling all of the dice rolls; it matches URLs that starts with /roll/ and have two more segments, but allows any values to appear in the last two segments. In the action, Rails allows us to examine what values were in those spots, and customize the response accordingly. How do we get access to the values? Through our old friend, the params hash! Let’s see how: First, in your own app, try visiting a URL like this: /roll/2/6 It should work. First, follow the R→C→A→V through and familiarize yourself with the code. Now, try visiting a URL like this: /roll/42/513 You will get a “no route matches” error. Let’s first make it so that users can visit any URL of the form /roll/X/Y and it will not throw an error, no matter what X and Y are: If we set up a route like this (for now let’s send it to the existing two_six action): BENP: Why not :dice and :sides in place of :zebra and :giraffe? I see this is done later, but maybe just do it right away to compress the section a bit further. This follows my notes in Fortune Teller Part1. get(&quot;/roll/:zebra/:giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) and then try visiting /roll/42/513 again, the route does match, and you get sent to the old action for two six-sided dice. What happens if you change the route to: get(&quot;/roll/zebra/giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) (removing the colons before zebra and giraffe) and visit /roll/42/513 again? “No route matches.” Ok, put the colons back: get(&quot;/roll/:zebra/:giraffe&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;two_six&quot; }) So, by beginning a segment of a path with a colon, we’re making it dynamic. Rails will, for the purpose of routing, allow anything there; it’s like a wildcard. Now, watch your server log while visiting the URL: Parameters: { &quot;zebra&quot; =&gt; &quot;42&quot;, &quot;giraffe&quot; =&gt; &quot;513&quot; } It’s just like when we got inputs from the query string! Except, in this case, the keys in the hash were determined by us in advance, in the route; rather than being tacked on to the end of the URL itself by the visitor (or a form). Try visiting the following URL paths in your browser: /roll/alice/bob /roll/42/513/alice /42/513 Which ones throw a “no route matches” error and which ones don’t? What appears in the params hash in your server log?6 Okay, from here, we .fetch the data from the params hash, just as we did before when learning about query strings. Let’s make up a new action, instead of messing with two_six; and let’s use more meaningful labels for the dynamic segments than :zebra and :giraffe: BENP: see previous zebra note. Could remove above text and below code get(&quot;/roll/:number_of_dice/:how_many_sides&quot;, { :controller =&gt; &quot;dice&quot;, :action =&gt; &quot;infinity_and_beyond&quot; }) Now, when we visit /roll/42/513, we get a “missing action” error, as expected. Let’s define the infinity_and_beyond action and make it say “hi” as usual: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... BENP: Above: I have used ... rather than # ... in other code blocks. Will need to be changed. &lt;%# app/views/dice_templates/infinity.html.erb %&gt; &lt;h1&gt;hi&lt;/h1&gt; BENP: Above and throughout, we have a specific erb code style? I have just been using html in previous transcription docs. These may need to be changed here or in my notes. Test it out and make sure you wired up your R→C→A→V correctly; if not, read the error messages, RTEM, and debug. Now, let’s .fetch the information from the params hash that we need to make this response intelligent: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond @num_dice = params.fetch(&quot;number_of_dice&quot;) @num_faces = params.fetch(&quot;how_many_sides&quot;) render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... {: mark_lines=“5-6”} I made the variables instances variables instead of local variables, by starting them with @, under the assumption that I will want to use them in the view template. And we can use logic similar to the logic in all the other actions to actually create an array of “dice rolls”: # app/controllers/dice_controller.rb class DiceController &lt; ApplicationController def infinity_and_beyond @num_dice = params.fetch(&quot;number_of_dice&quot;) @num_faces = params.fetch(&quot;how_many_sides&quot;) @array_of_rolls = Array.new @num_dice.to_i.times do @array_of_rolls.push(rand(@num_faces.to_i) + 1) end render({template =&gt; &quot;dice_templates/infinity.html.erb&quot;}) end # ... {: mark_lines=“8 10-12”} and then draw them in the template: &lt;%# app/views/dice_templates/infinity.html.erb %&gt; &lt;h1&gt; &lt;%= @num_dice %&gt;d&lt;%= @num_faces %&gt; &lt;/h1&gt; &lt;ul&gt; &lt;% @array_of_rolls.each do |a_roll| %&gt; &lt;li&gt; &lt;%= a_roll %&gt; &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; {: mark_lines=“3-14”} And, voilà, it should work — and it should work for any combination of dice and faces! Including the 18 combinations that we had before. Comment out all the old routes and click on all the links in the nav — they still work! Gleefully, delete all the old routes, actions, and view templates — we love deleting code. That’s less costly code to maintain. But wait! Are you sure you didn’t forget and break some old functionality that we had before? How can we be sure? A question to ponder. Did you actually go visit those URLs? Why not? Do or do not; there is no read.↩︎ "],["part-2-horoscopes.html", "16.2 Part 2: Horoscopes", " 16.2 Part 2: Horoscopes Notes: dynamic route segments, our own classes Copied from refactoring-fortune-teller-with-dynamic-routes.md chapter section Zodiac class in app/models/ get(\"/zodiacs/:the_sign\", { :controller =&gt; \"fortunes\", :action =&gt; \"horoscopes\" }) String#to_sym regressions and refactoring, importance of automated tests Let’s try to do something similar for the zodiacs; that is, let’s see if we can use a dynamic route segment to reduce the amount of code. It won’t be quite as straightforward as with the dice, because there’s actual data (the horoscopes) that isn’t the same on each page; it’s not as formulaic as generating random numbers based on the ones that are in the URL. But, if we had a way to look up the horoscope given the astrological sign that’s in the URL, then the rest of every action would be the same. Generate lucky numbers, and populate a template that’s the same for every action. Imagine you had a hash of hashes that had all of the signs and horoscopes within it, something like an API response — then could you make a single RCAV that supported all 12 zodiacs? If you had a hash like this available to you: { :aries =&gt; { :name =&gt; &quot;Aries&quot;, :horoscope =&gt; &quot;As your professional dreams unfold, Aries, you may worry about the downside. First, there are new responsibilities that you might doubt your ability to fulfill. Second, you might be catapulted into an uncomfortable new realm of office politics. Don&#39;t let these matters put a damper on your enthusiasm. You have what it takes to fulfill the first concern and the wisdom to avoid the second. Onward and upward.&quot; }, :leo =&gt; { :name =&gt; &quot;Leo&quot;, :horoscope =&gt; &quot;Success on all levels is filling your life and making you feel absolutely wonderful, Leo. The downside of this is that you might be a little too conscientious. Are you putting in a lot of extra hours? Be discriminating about this and don&#39;t work harder than necessary. You could get stressed to the point of taxing your strength too much, and that won&#39;t help you. Pace yourself.&quot; }, # etc } Fortunately, you do. I’ve created a class called Zodiac, and I gave it class-level method called list which returns that exact hash above7. Give the Zodiac class a try. For example, in the FireController#ram action, you can replace: @horoscope = &quot;As your professional dreams unfold, Aries, you may worry about the downside. First, there are new responsibilities that you might doubt your ability to fulfill. Second, you might be catapulted into an uncomfortable new realm of office politics. Don&#39;t let these matters put a damper on your enthusiasm. You have what it takes to fulfill the first concern and the wisdom to avoid the second. Onward and upward.&quot; With: all_zodiacs = Zodiac.list this_zodiac = all_zodiacs.fetch(:aries) @horoscope = this_zodiac.fetch(:horoscope) Verify that your /zodiacs/aries action still works just like before. If you’re curious, the Zodiac class is in the app/models/ folder — you can go have a look at it, if you like. When we want to define a new Ruby class within a Rails app, we create a file for it in the app/models/ folder. The filename is important — it should exactly match the class name, but lowercased BENP: snake_cased instead of lowercased?, just like when we create controller classes (e.g., fire_controller.rb containing FireController). In this case, I created a file called zodiac.rb within app/models/, and boom — everywhere within the Rails application (all controllers, all views, even within other models), we have access to the Zodiac class; and we can call Zodiac.list. We’ll talk a lot more about models in the coming weeks, but for now you can just use the Zodiac.list method I provided; just know that it returns a hash of hashes with the keys as shown above. You know how to work with hashes. Now, your task is: with what you’ve learned about dynamic route segments, and with the ability to look up a horoscope given a sign, can you replace all 12 of the R→C→A→Vs for zodiacs with just one R→C→A→V? get(&quot;/zodiacs/:the_sign&quot;, { :controller =&gt; &quot;fortunes&quot;, :action =&gt; &quot;horoscopes&quot; }) You can pick whatever controller and action name you like, but when you’re done the application should function exactly the same as before. 16.2.1 String#to_sym If we try to access an element in a Hash that looks like this: zodiacs = { :aries =&gt; &quot;stuff&quot;, :leo =&gt; &quot;more stuff&quot;, } with a String key \"leo\": zodiacs.fetch(&quot;leo&quot;) we’ll get the familiar error message: KeyError (key not found: &quot;leo&quot;) because the String, \"leo\", is not the same as the Symbol, :leo. Remember that all values in the params hash come to us as Strings. Just as we had to convert these Strings to Floats with .to_f before doing math on them in Omnicalc, we’ll have to convert them to Symbols if we want to use them to key into the Hash returned by Zodiac.list. Fortunately, there’s a handy method .to_sym that will do just that: &quot;hello&quot;.to_sym # =&gt; :hello With the .to_sym method in hand, you should be able to use params and Zodiac.list to replace all 12 actions with 1! Can you define a class and a class-level method like this? You ought to be able to, with what you’ve learned about Our own classes and Hashes.↩︎ "],["regressions.html", "16.3 Regressions", " 16.3 Regressions How can you be sure that it functions exactly the same as before? Well, in this case, since we had automated tests for Part 2, you can run rails grade! Isn’t it a nice, safe feeling to be able to run the tests to know that you didn’t introduce any regressions? "],["refactoring.html", "16.4 Refactoring", " 16.4 Refactoring What we just did is called refactoring: In computer programming and software design, code refactoring is the process of restructuring existing computer code — changing the factoring — without changing its external behavior. Refactoring is intended to improve the design, structure, and/or implementation of the software (its non-functional attributes), while preserving its functionality. Potential advantages of refactoring may include improved code readability and reduced complexity; these can improve the source code’s maintainability and create a simpler, cleaner, or more expressive internal architecture or object model to improve extensibility. Wikipedia, “Code refactoring” Refactoring is a crucial part of the software development process. First, we write messy, clunky, repetitive, but easy to understand and most importantly functional code; then, only after having wrapped our heads around the problem by solving it, we sit back and take a moment to think about whether there might be a more readable or less complex or more performant solution. However, once we have a working solution, it’s often very tempting to just leave it alone; why mess with a good thing and risk introducing bugs? Especially if you’re dealing with a large, old, complicated system that you didn’t build entirely yourself; it can be irresponsible to refactor willy nilly if you don’t fully understand what you’re changing (see Chesterton’s fence). And yet, we do need to make changes to our codebase over time; even if we’re satisfied to never refactor, we at some point have to add new features or make security patches. How do we make sure we don’t inadvertently break anything or introduce bugs? No matter how good our quality assurance team is, it’s not realistic to expect them to manually examine every user path through the app and verify that it still works, with every combination of possible inputs, every single time any developer makes any change. The answer: automated tests. This is why developers invest so much time and effort in writing automated test suites (this is what you’ve been running every time you do a rails grade). Automated tests are nothing more than a separate Ruby script that, essentially, web scrapes our own app, clicks every link, fills out every form, with every possible combination of inputs, and makes sure that the app is doing the right thing under all scenarios. As you might imagine, this self-web-scraping script takes a long time to write; often, longer than a feature itself. But, if you plan to maintain a codebase over the long term (not always true for e.g. a throwaway prototype), it is well worth the investment. "],["finish-and-submit-refactoring-fortune-teller.html", "16.5 Finish and Submit Refactoring Fortune Teller", " 16.5 Finish and Submit Refactoring Fortune Teller 16.5.1 Optional extra challenge Can you refactor RPS RCAV to use only one action instead of three for the URLs /rock, /paper, and /scissors? "],["terminology-technical-reference.html", "A Terminology Technical Reference", " A Terminology Technical Reference "],["ruby-technical-reference.html", "B Ruby Technical Reference", " B Ruby Technical Reference "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
